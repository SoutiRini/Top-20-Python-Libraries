{"func1": {"source file: ": "_arrow_utils1.py","line number: ": "12","func name: ": "pyarrow_array_to_numpy_and_mask","func arg: ": "(arr, dtype)","comments: ": "Convert a primitive pyarrow.Array to a numpy array and boolean mask based on the buffers of the Array.\n\nParameters ---------- arr : pyarrow.Array dtype : numpy.dtype\n##### Returns\n"}}{"func1": {"source file: ": "_base1.py","line number: ": "271","func name: ": "read_excel","func arg: ": "(io, sheet_name, header, names, index_col, usecols, squeeze, dtype, engine, converters, true_values, false_values, skiprows, nrows, na_values, keep_default_na, verbose, parse_dates, date_parser, thousands, comment, skipfooter, convert_float, mangle_dupe_cols, **kwds)","comments: ": ""}}{"func1": {"source file: ": "_core1.py","line number: ": "13","func name: ": "hist_series","func arg: ": "(by, ax, grid, xlabelsize, xrot, ylabelsize, yrot, figsize, bins, backend, **kwargs)","comments: ": "Draw histogram of the input series using matplotlib.\n\nParameters ---------- by : object, optional If passed, then used to form histograms for separate groups. ax : matplotlib axis object If not passed, uses gca(). grid : bool, default True Whether to show axis grid lines. xlabelsize : int, default None If specified changes the x-axis label size. xrot : float, default None Rotation of x axis labels. ylabelsize : int, default None If specified changes the y-axis label size. yrot : float, default None Rotation of y axis labels. figsize : tuple, default None Figure size in inches by default. bins : int or sequence, default 10 Number of histogram bins to be used. If an integer is given, bins + 1 bin edges are calculated and returned. If bins is a sequence, gives bin edges, including left edge of first bin and right edge of last bin. In this case, bins is returned unmodified. backend : str, default None Backend to use instead of the backend specified in the option ``plotting.backend``. For instance, 'matplotlib'. Alternatively, to specify the ``plotting.backend`` for the whole session, set ``pd.options.plotting.backend``.\n\n.. versionadded:: 1.0.0\n\n**kwargs To be passed to the actual plotting function.\n##### Returns\n* **matplotlib.axes.Axes.hist **: Plot a histogram using matplotlib.\n\n"},"func2": {"source file: ": "_core1.py","line number: ": "89","func name: ": "hist_frame","func arg: ": "(data, column, by, grid, xlabelsize, xrot, ylabelsize, yrot, ax, sharex, sharey, figsize, layout, bins, backend, **kwargs)","comments: ": "Make a histogram of the DataFrame's.\n\nA `histogram`_ is a representation of the distribution of data. This function calls :meth:`matplotlib.pyplot.hist`, on each series in the DataFrame, resulting in one histogram per column.\n\n.. _histogram: https://en.wikipedia.org/wiki/Histogram\n\nParameters ---------- data : DataFrame The pandas object holding the data. column : str or sequence If passed, will be used to limit data to a subset of columns. by : object, optional If passed, then used to form histograms for separate groups. grid : bool, default True Whether to show axis grid lines. xlabelsize : int, default None If specified changes the x-axis label size. xrot : float, default None Rotation of x axis labels. For example, a value of 90 displays the x labels rotated 90 degrees clockwise. ylabelsize : int, default None If specified changes the y-axis label size. yrot : float, default None Rotation of y axis labels. For example, a value of 90 displays the y labels rotated 90 degrees clockwise. ax : Matplotlib axes object, default None The axes to plot the histogram on. sharex : bool, default True if ax is None else False In case subplots=True, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in. Note that passing in both an ax and sharex=True will alter all x axis labels for all subplots in a figure. sharey : bool, default False In case subplots=True, share y axis and set some y axis labels to invisible. figsize : tuple The size in inches of the figure to create. Uses the value in `matplotlib.rcParams` by default. layout : tuple, optional Tuple of (rows, columns) for the layout of the histograms. bins : int or sequence, default 10 Number of histogram bins to be used. If an integer is given, bins + 1 bin edges are calculated and returned. If bins is a sequence, gives bin edges, including left edge of first bin and right edge of last bin. In this case, bins is returned unmodified. backend : str, default None Backend to use instead of the backend specified in the option ``plotting.backend``. For instance, 'matplotlib'. Alternatively, to specify the ``plotting.backend`` for the whole session, set ``pd.options.plotting.backend``.\n\n.. versionadded:: 1.0.0\n\n**kwargs All other plotting keyword arguments to be passed to :meth:`matplotlib.pyplot.hist`.\n##### Returns\n* **matplotlib.pyplot.hist **: Plot a histogram using matplotlib.\n\n* **.. plot**: \n\n"},"func3": {"source file: ": "_core1.py","line number: ": "390","func name: ": "boxplot","func arg: ": "(data, column, by, ax, fontsize, rot, grid, figsize, layout, return_type, **kwargs)","comments: ": ""},"func4": {"source file: ": "_core1.py","line number: ": "421","func name: ": "boxplot_frame","func arg: ": "(column, by, ax, fontsize, rot, grid, figsize, layout, return_type, backend, **kwargs)","comments: ": ""},"func5": {"source file: ": "_core1.py","line number: ": "451","func name: ": "boxplot_frame_groupby","func arg: ": "(grouped, subplots, column, fontsize, rot, grid, ax, figsize, layout, sharex, sharey, backend, **kwargs)","comments: ": "Make box plots from DataFrameGroupBy data.\n\nParameters ---------- grouped : Grouped DataFrame subplots : bool * ``False``\n\n- no subplots will be used * ``True``\n\n- create a subplot for each group.\n\ncolumn : column name or list of names, or vector Can be any valid input to groupby. fontsize : int or str rot : label rotation angle grid : Setting this to True will show the grid ax : Matplotlib axis object, default None figsize : A tuple (width, height) in inches layout : tuple (optional) The layout of the plot: (rows, columns). sharex : bool, default False Whether x-axes will be shared among subplots.\n\n.. versionadded:: 0.23.1 sharey : bool, default True Whether y-axes will be shared among subplots.\n\n.. versionadded:: 0.23.1 backend : str, default None Backend to use instead of the backend specified in the option ``plotting.backend``. For instance, 'matplotlib'. Alternatively, to specify the ``plotting.backend`` for the whole session, set ``pd.options.plotting.backend``.\n\n.. versionadded:: 1.0.0\n\n**kwargs All other plotting keyword arguments to be passed to matplotlib's boxplot function.\n##### Returns\n"},"func6": {"source file: ": "_core1.py","line number: ": "1594","func name: ": "_find_backend","func arg: ": "(backend)","comments: ": "Find a pandas plotting backend>\n\nParameters ---------- backend : str The identifier for the backend. Either an entrypoint item registered with pkg_resources, or a module name.\n\nNotes ----- Modifies _backends with imported backends as a side effect.\n##### Returns\n"},"func7": {"source file: ": "_core1.py","line number: ": "1645","func name: ": "_get_plot_backend","func arg: ": "(backend)","comments: ": "Return the plotting backend to use (e.g. `pandas.plotting._matplotlib`).\n\nThe plotting system of pandas has been using matplotlib, but the idea here is that it can also work with other third-party backends. In the future, this function will return the backend from a pandas option, and all the rest of the code in this file will use the backend specified there for the plotting.\n\nThe backend is imported lazily, as matplotlib is a soft dependency, and pandas can be used without it being installed.\n"}}{"func1": {"source file: ": "_decorators1.py","line number: ": "24","func name: ": "deprecate","func arg: ": "(name, alternative, version, alt_name, klass, stacklevel, msg)","comments: ": "Return a new function that emits a deprecation warning on use.\n\nTo use this method for a deprecated function, another function `alternative` with the same signature must exist. The deprecated function will emit a deprecation warning, and in the docstring it will contain the deprecation directive with the provided version so it can be detected for future removal.\n\nParameters ---------- name : str Name of function to deprecate. alternative : func Function to use instead. version : str Version of pandas in which the method has been deprecated. alt_name : str, optional Name to use in preference of alternative.__name__. klass : Warning, default FutureWarning stacklevel : int, default 2 msg : str The message to display in the warning. Default is '{name} is deprecated. Use {alt_name} instead.'\n"},"func2": {"source file: ": "_decorators1.py","line number: ": "99","func name: ": "deprecate_kwarg","func arg: ": "(old_arg_name, new_arg_name, mapping, stacklevel)","comments: ": "Decorator to deprecate a keyword argument of a function.\n\nParameters ---------- old_arg_name : str Name of argument in function to deprecate new_arg_name : str or None Name of preferred argument in function. Use None to raise warning that ``old_arg_name`` keyword is deprecated. mapping : dict or callable If mapping is present, use it to translate old arguments to new arguments. A callable must do its own value checking; values not found in a dict will be forwarded unchanged.\n\nExamples -------- The following deprecates 'cols', using 'columns' instead\n\n>>> @deprecate_kwarg(old_arg_name='cols', new_arg_name='columns') ... def f(columns=''): ...\n\n\n\n print(columns) ... >>> f(columns='should work ok') should work ok\n\n>>> f(cols='should raise warning') FutureWarning: cols is deprecated, use columns instead warnings.warn(msg, FutureWarning) should raise warning\n\n>>> f(cols='should error', columns=\"can't pass do both\") TypeError: Can only specify 'cols' or 'columns', not both\n\n>>> @deprecate_kwarg('old', 'new', {'yes': True, 'no': False}) ... def f(new=False): ...\n\n\n\n print('yes!' if new else 'no!') ... >>> f(old='yes') FutureWarning: old='yes' is deprecated, use new=True instead warnings.warn(msg, FutureWarning) yes!\n\nTo raise a warning that a keyword will be removed entirely in the future\n\n>>> @deprecate_kwarg(old_arg_name='cols', new_arg_name=None) ... def f(cols='', another_param=''): ...\n\n\n\n print(cols) ... >>> f(cols='should raise warning') FutureWarning: the 'cols' keyword is deprecated and will be removed in a future version please takes steps to stop use of 'cols' should raise warning >>> f(another_param='should not raise warning') should not raise warning\n\n>>> f(cols='should raise warning', another_param='') FutureWarning: the 'cols' keyword is deprecated and will be removed in a future version please takes steps to stop use of 'cols' should raise warning\n"},"func3": {"source file: ": "_decorators1.py","line number: ": "221","func name: ": "rewrite_axis_style_signature","func arg: ": "(name, extra_params)","comments: ": ""},"func4": {"source file: ": "_decorators1.py","line number: ": "338","func name: ": "indent","func arg: ": "(text, indents)","comments: ": ""}}{}{}{"func1": {"source file: ": "_exceptions1.py","line number: ": "6","func name: ": "rewrite_exception","func arg: ": "(old_name, new_name)","comments: ": "Rewrite the message of an exception.\n\n\n"}}{"func1": {"source file: ": "_json1.py","line number: ": "39","func name: ": "to_json","func arg: ": "(path_or_buf, obj, orient, date_format, double_precision, force_ascii, date_unit, default_handler, lines, compression, index, indent)","comments: ": ""},"func2": {"source file: ": "_json1.py","line number: ": "350","func name: ": "read_json","func arg: ": "(path_or_buf, orient, typ, dtype, convert_axes, convert_dates, keep_default_dates, numpy, precise_float, date_unit, encoding, lines, chunksize, compression)","comments: ": "Convert a JSON string to pandas object.\n\nParameters ---------- path_or_buf : a valid JSON str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.json``.\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``. orient : str Indication of expected JSON string format. Compatible JSON strings can be produced by ``to_json()`` with a corresponding orient value. The set of possible orients is:\n\n- ``'split'`` : dict like ``{index -> [index], columns -> [columns], data -> [values]}``\n\n- ``'records'`` : list like ``[{column -> value}, ... , {column -> value}]``\n\n- ``'index'`` : dict like ``{index -> {column -> value}}``\n\n- ``'columns'`` : dict like ``{column -> {index -> value}}``\n\n- ``'values'`` : just the values array\n\nThe allowed and default values depend on the value of the `typ` parameter.\n\n* when ``typ == 'series'``,\n\n- allowed orients are ``{'split','records','index'}``\n\n- default is ``'index'``\n\n- The Series index must be unique for orient ``'index'``.\n\n* when ``typ == 'frame'``,\n\n- allowed orients are ``{'split','records','index', 'columns','values', 'table'}``\n\n- default is ``'columns'``\n\n- The DataFrame index must be unique for orients ``'index'`` and ``'columns'``.\n\n- The DataFrame columns must be unique for orients ``'index'``, ``'columns'``, and ``'records'``.\n\n.. versionadded:: 0.23.0 'table' as an allowed value for the ``orient`` argument\n\ntyp : {'frame', 'series'}, default 'frame' The type of object to recover.\n\ndtype : bool or dict, default None If True, infer dtypes; if a dict of column to dtype, then use those; if False, then don't infer dtypes at all, applies only to the data.\n\nFor all ``orient`` values except ``'table'``, default is True.\n\n.. versionchanged:: 0.25.0\n\nNot applicable for ``orient='table'``.\n\nconvert_axes : bool, default None Try to convert the axes to the proper dtypes.\n\nFor all ``orient`` values except ``'table'``, default is True.\n\n.. versionchanged:: 0.25.0\n\nNot applicable for ``orient='table'``.\n\nconvert_dates : bool or list of str, default True List of columns to parse for dates. If True, then try to parse datelike columns. A column label is datelike if\n\n* it ends with ``'_at'``,\n\n* it ends with ``'_time'``,\n\n* it begins with ``'timestamp'``,\n\n* it is ``'modified'``, or\n\n* it is ``'date'``.\n\nkeep_default_dates : bool, default True If parsing dates, then parse the default datelike columns.\n\nnumpy : bool, default False Direct decoding to numpy arrays. Supports numeric data only, but non-numeric column and index labels are supported. Note also that the JSON ordering MUST be the same for each term if numpy=True.\n\n.. deprecated:: 1.0.0\n\nprecise_float : bool, default False Set to enable usage of higher precision (strtod) function when decoding string to double values. Default (False) is to use fast but less precise builtin functionality.\n\ndate_unit : str, default None The timestamp unit to detect if converting dates. The default behaviour is to try and detect the correct precision, but if this is not desired then pass one of 's', 'ms', 'us' or 'ns' to force parsing only seconds, milliseconds, microseconds or nanoseconds respectively.\n\nencoding : str, default is 'utf-8' The encoding to use to decode py3 bytes.\n\nlines : bool, default False Read the file as a json object per line.\n\nchunksize : int, optional Return JsonReader object for iteration. See the `line-delimited json docs <https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#line-delimited-json>`_ for more information on ``chunksize``. This can only be passed if `lines=True`. If this is None, the file will be read into memory all at once.\n\n.. versionadded:: 0.21.0\n\ncompression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer' For on-the-fly decompression of on-disk data. If 'infer', then use gzip, bz2, zip or xz if path_or_buf is a string ending in '.gz', '.bz2', '.zip', or 'xz', respectively, and no decompression otherwise. If using 'zip', the ZIP file must contain only one data file to be read in. Set to None for no decompression.\n\n.. versionadded:: 0.21.0\n##### Returns\n* **DataFrame.to_json **: Convert a DataFrame to a JSON string.\n\n* **Series.to_json **: Convert a Series to a JSON string.\n\n* **Specific to ``orient='table'``, if a **: class\n\n* ****: func\n\n* **subsequent read operation will incorrectly set the **: class\n\n* **``None``. This is because `index` is also used by **: func\n\n* **to denote a missing **: class\n\n* **limitation is encountered with a **: class\n\n* **Encoding/decoding a Dataframe using ``'split'`` formatted JSON**: \n\n* **'{\"columns\"**: [\"col 1\",\"col 2\"],\n  \"index\"\n\n* **Encoding/decoding a Dataframe using ``'index'`` formatted JSON**: \n\n* **'{\"row 1\"**: {\"col 1\"\n\n* **'[{\"col 1\"**: \"a\",\"col 2\"\n\n* **'{\"schema\"**: {\"fields\"\n\n"}}{"func1": {"source file: ": "_misc1.py","line number: ": "6","func name: ": "table","func arg: ": "(ax, data, rowLabels, colLabels, **kwargs)","comments: ": "Helper function to convert DataFrame and Series to matplotlib.table.\n\nParameters ---------- ax : Matplotlib axes object data : DataFrame or Series Data for table contents. **kwargs Keyword arguments to be passed to matplotlib.table.table. If `rowLabels` or `colLabels` is not specified, data index or column name will be used.\n##### Returns\n"},"func2": {"source file: ": "_misc1.py","line number: ": "30","func name: ": "register","func arg: ": "()","comments: ": "Register Pandas Formatters and Converters with matplotlib.\n\nThis function modifies the global ``matplotlib.units.registry`` dictionary. Pandas adds custom converters for\n\n* pd.Timestamp * pd.Period * np.datetime64 * datetime.datetime * datetime.date * datetime.time\n\nSee Also -------- deregister_matplotlib_converters\n"},"func3": {"source file: ": "_misc1.py","line number: ": "52","func name: ": "deregister","func arg: ": "()","comments: ": "Remove pandas' formatters and converters.\n\nRemoves the custom converters added by :func:`register`. This attempts to set the state of the registry back to the state before pandas registered its own units. Converters for pandas' own types like Timestamp and Period are removed completely. Converters for types pandas overwrites, like ``datetime.datetime``, are restored to their original value.\n\nSee Also -------- register_matplotlib_converters\n"},"func4": {"source file: ": "_misc1.py","line number: ": "71","func name: ": "scatter_matrix","func arg: ": "(frame, alpha, figsize, ax, grid, diagonal, marker, density_kwds, hist_kwds, range_padding, **kwargs)","comments: ": "Draw a matrix of scatter plots.\n\nParameters ---------- frame : DataFrame alpha : float, optional Amount of transparency applied. figsize : (float,float), optional A tuple (width, height) in inches. ax : Matplotlib axis object, optional grid : bool, optional Setting this to True will show the grid. diagonal : {'hist', 'kde'} Pick between 'kde' and 'hist' for either Kernel Density Estimation or Histogram plot in the diagonal. marker : str, optional Matplotlib marker type, default '.'. density_kwds : keywords Keyword arguments to be passed to kernel density estimate plot. hist_kwds : keywords Keyword arguments to be passed to hist function. range_padding : float, default 0.05 Relative extension of axis range in x and y with respect to (x_max\n\n- x_min) or (y_max\n\n- y_min). **kwargs Keyword arguments to be passed to scatter function.\n##### Returns\n"},"func5": {"source file: ": "_misc1.py","line number: ": "138","func name: ": "radviz","func arg: ": "(frame, class_column, ax, color, colormap, **kwds)","comments: ": "Plot a multidimensional dataset in 2D.\n\nEach Series in the DataFrame is represented as a evenly distributed slice on a circle. Each data point is rendered in the circle according to the value on each Series. Highly correlated `Series` in the `DataFrame` are placed closer on the unit circle.\n\nRadViz allow to project a N-dimensional data set into a 2D space where the influence of each dimension can be interpreted as a balance between the influence of all dimensions.\n\nMore info available at the `original article <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.135.889>`_ describing RadViz.\n\nParameters ---------- frame : `DataFrame` Pandas object holding the data. class_column : str Column name containing the name of the data point category. ax : :class:`matplotlib.axes.Axes`, optional A plot instance to which to add the information. color : list[str] or tuple[str], optional Assign a color to each category. Example: ['blue', 'green']. colormap : str or :class:`matplotlib.colors.Colormap`, default None Colormap to select colors from. If string, load colormap with that name from matplotlib. **kwds Options to pass to matplotlib scatter plotting method.\n##### Returns\n* **class**: `matplotlib.axes.Axes`\n\n* **plotting.andrews_curves **: Plot clustering visualization.\n\n* **.. plot**: \n\n"},"func6": {"source file: ": "_misc1.py","line number: ": "211","func name: ": "andrews_curves","func arg: ": "(frame, class_column, ax, samples, color, colormap, **kwargs)","comments: ": "Generate a matplotlib plot of Andrews curves, for visualising clusters of multivariate data.\n\nAndrews curves have the functional form:\n\nf(t) = x_1/sqrt(2) + x_2 sin(t) + x_3 cos(t) + x_4 sin(2t) + x_5 cos(2t) + ...\n\nWhere x coefficients correspond to the values of each dimension and t is linearly spaced between -pi and +pi. Each row of frame then corresponds to a single curve.\n\nParameters ---------- frame : DataFrame Data to be plotted, preferably normalized to (0.0, 1.0). class_column : Name of the column containing class names ax : matplotlib axes object, default None samples : Number of points to plot in each curve color : list or tuple, optional Colors to use for the different classes. colormap : str or matplotlib colormap object, default None Colormap to select colors from. If string, load colormap with that name from matplotlib. **kwargs Options to pass to matplotlib plotting method.\n##### Returns\n* **class**: `matplotlip.axis.Axes`\n\n"},"func7": {"source file: ": "_misc1.py","line number: ": "258","func name: ": "bootstrap_plot","func arg: ": "(series, fig, size, samples, **kwds)","comments: ": "Bootstrap plot on mean, median and mid-range statistics.\n\nThe bootstrap plot is used to estimate the uncertainty of a statistic by relaying on random sampling with replacement [1]_. This function will generate bootstrapping plots for mean, median and mid-range statistics for the given number of samples of the given size.\n\n.. [1] \"Bootstrapping (statistics)\" in\n\n\n\n https://en.wikipedia.org/wiki/Bootstrapping_%28statistics%29\n\nParameters ---------- series : pandas.Series Pandas Series from where to get the samplings for the bootstrapping. fig : matplotlib.figure.Figure, default None If given, it will use the `fig` reference for plotting instead of creating a new one with default parameters. size : int, default 50 Number of data points to consider during each sampling. It must be greater or equal than the length of the `series`. samples : int, default 500 Number of times the bootstrap procedure is performed. **kwds Options to pass to matplotlib plotting method.\n##### Returns\n* **DataFrame.plot **: Basic plotting for DataFrame objects.\n\n* **Series.plot **: Basic plotting for Series objects.\n\n* **.. plot**: \n\n"},"func8": {"source file: ": "_misc1.py","line number: ": "310","func name: ": "parallel_coordinates","func arg: ": "(frame, class_column, cols, ax, color, use_columns, xticks, colormap, axvlines, axvlines_kwds, sort_labels, **kwargs)","comments: ": "Parallel coordinates plotting.\n\nParameters ---------- frame : DataFrame class_column : str Column name containing class names. cols : list, optional A list of column names to use. ax : matplotlib.axis, optional Matplotlib axis object. color : list or tuple, optional Colors to use for the different classes. use_columns : bool, optional If true, columns will be used as xticks. xticks : list or tuple, optional A list of values to use for xticks. colormap : str or matplotlib colormap, default None Colormap to use for line colors. axvlines : bool, optional If true, vertical lines will be added at each xtick. axvlines_kwds : keywords, optional Options to be passed to axvline method for vertical lines. sort_labels : bool, default False Sort class_column labels, useful when assigning colors. **kwargs Options to pass to matplotlib plotting method.\n##### Returns\n* **class**: `matplotlib.axis.Axes`\n\n* **>>> df = pd.read_csv('https**: //raw.github.com/pandas-dev/pandas/master'\n'/pandas/tests/data/csv/iris.csv')\n\n"},"func9": {"source file: ": "_misc1.py","line number: ": "384","func name: ": "lag_plot","func arg: ": "(series, lag, ax, **kwds)","comments: ": "Lag plot for time series.\n\nParameters ---------- series : Time series lag : lag of the scatter plot, default 1 ax : Matplotlib axis object, optional **kwds Matplotlib scatter method keyword arguments.\n##### Returns\n* **class**: `matplotlib.axis.Axes`\n\n"},"func10": {"source file: ": "_misc1.py","line number: ": "404","func name: ": "autocorrelation_plot","func arg: ": "(series, ax, **kwargs)","comments: ": "Autocorrelation plot for time series.\n\nParameters ---------- series : Time series ax : Matplotlib axis object, optional **kwargs Options to pass to matplotlib plotting method.\n##### Returns\n* **class**: `matplotlib.axis.Axes`\n\n"}}{"func1": {"source file: ": "_normalize1.py","line number: ": "18","func name: ": "convert_to_line_delimits","func arg: ": "(s)","comments: ": "Helper function that converts JSON lists to line delimited JSON.\n\n\n"},"func2": {"source file: ": "_normalize1.py","line number: ": "32","func name: ": "nested_to_record","func arg: ": "(ds, prefix, sep, level, max_level)","comments: ": "A simplified json_normalize\n\nConverts a nested dict into a flat dict (\"record\"), unlike json_normalize, it does not attempt to extract a subset of the data.\n\nParameters ---------- ds : dict or list of dicts prefix: the prefix, optional, default: \"\" sep : str, default '.' Nested records will generate names separated by sep, e.g., for sep='.', { 'foo' : { 'bar' : 0 } } -> foo.bar level: int, optional, default: 0 The number of levels in the json string.\n\nmax_level: int, optional, default: None The max depth to normalize.\n\n.. versionadded:: 0.25.0\n##### Returns\n* **IN[52]**: nested_to_record(dict(flat1=1,dict1=dict(c=1,d=2),\n  nested=dict(e=dict(c=1,d=2),d=2)))\n\n* **Out[52]**: \n\n* **{'dict1.c'**: 1,\n 'dict1.d'\n\n"},"func3": {"source file: ": "_normalize1.py","line number: ": "114","func name: ": "_json_normalize","func arg: ": "(data, record_path, meta, meta_prefix, record_prefix, errors, sep, max_level)","comments: ": "Normalize semi-structured JSON data into a flat table.\n\nParameters ---------- data : dict or list of dicts Unserialized JSON objects. record_path : str or list of str, default None Path in each object to list of records. If not passed, data will be assumed to be an array of records. meta : list of paths (str or list of str), default None Fields to use as metadata for each record in resulting table. meta_prefix : str, default None If True, prefix records with dotted (?) path, e.g. foo.bar.field if meta is ['foo', 'bar']. record_prefix : str, default None If True, prefix records with dotted (?) path, e.g. foo.bar.field if path to records is ['foo', 'bar']. errors : {'raise', 'ignore'}, default 'raise' Configures error handling.\n\n* 'ignore' : will ignore KeyError if keys listed in meta are not always present. * 'raise' : will raise KeyError if keys listed in meta are not always present. sep : str, default '.' Nested records will generate names separated by sep. e.g., for sep='.', {'foo': {'bar': 0}} -> foo.bar. max_level : int, default None Max number of levels(depth of dict) to normalize. if None, normalizes all levels.\n\n.. versionadded:: 0.25.0\n"}}{}{}{"func1": {"source file: ": "_optional1.py","line number: ": "36","func name: ": "_get_version","func arg: ": "(module)","comments: ": ""},"func2": {"source file: ": "_optional1.py","line number: ": "47","func name: ": "import_optional_dependency","func arg: ": "(name, extra, raise_on_missing, on_version)","comments: ": "Import an optional dependency.\n\nBy default, if a dependency is missing an ImportError with a nice message will be raised. If a dependency is present, but too old, we raise.\n\nParameters ---------- name : str The module name. This should be top-level only, so that the version may be checked. extra : str Additional text to include in the ImportError message. raise_on_missing : bool, default True Whether to raise if the optional dependency is not found. When False and the module is not present, None is returned. on_version : str {'raise', 'warn'} What to do when a dependency's version is too old.\n\n* raise : Raise an ImportError * warn : Warn that the version is too old. Returns None * ignore: Return the module, even if the version is too old. It's expected that users validate the version locally when using ``on_version=\"ignore\"`` (see. ``io/html.py``)\n##### Returns\n* **maybe_module **: Optional[ModuleType]\nThe imported module, when found and the version is correct.\nNone is returned when the package is not found and `raise_on_missing`\nis False, or when the package's version is too old and `on_version`\nis ``'warn'``.\n\n"}}{"func1": {"source file: ": "_print_versions1.py","line number: ": "14","func name: ": "get_sys_info","func arg: ": "()","comments: ": "Returns system information as a list\n\n\n"},"func2": {"source file: ": "_print_versions1.py","line number: ": "61","func name: ": "show_versions","func arg: ": "(as_json)","comments: ": ""},"func3": {"source file: ": "_print_versions1.py","line number: ": "127","func name: ": "main","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "_ranges1.py","line number: ": "15","func name: ": "generate_regular_range","func arg: ": "(start, end, periods, freq)","comments: ": "Generate a range of dates with the spans between dates described by the given `freq` DateOffset.\n\nParameters ---------- start : Timestamp or None first point of produced date range end : Timestamp or None last point of produced date range periods : int number of periods in produced date range freq : DateOffset describes space between dates in produced date range\n##### Returns\n"},"func2": {"source file: ": "_ranges1.py","line number: ": "86","func name: ": "_generate_range_overflow_safe","func arg: ": "(endpoint, periods, stride, side)","comments: ": "Calculate the second endpoint for passing to np.arange, checking to avoid an integer overflow.  Catch OverflowError and re-raise as OutOfBoundsDatetime.\n\nParameters ---------- endpoint : int nanosecond timestamp of the known endpoint of the desired range periods : int number of periods in the desired range stride : int nanoseconds between periods in the desired range side : {'start', 'end'} which end of the range `endpoint` refers to\n##### Returns\n* **other_end **: int\n\n"},"func3": {"source file: ": "_ranges1.py","line number: ": "153","func name: ": "_generate_range_overflow_safe_signed","func arg: ": "(endpoint, periods, stride, side)","comments: ": "A special case for _generate_range_overflow_safe where `periods * stride` can be calculated without overflowing int64 bounds.\n\n\n"}}{"func1": {"source file: ": "_table_schema1.py","line number: ": "29","func name: ": "as_json_table_type","func arg: ": "(x)","comments: ": "Convert a NumPy / pandas type to its corresponding json_table.\n\nParameters ---------- x : array or dtype\n##### Returns\n* **t **: str\nthe Table Schema data types\n\n"},"func2": {"source file: ": "_table_schema1.py","line number: ": "77","func name: ": "set_default_names","func arg: ": "(data)","comments: ": "Sets index names to 'index' for regular, or 'level_x' for Multi\n\n\n"},"func3": {"source file: ": "_table_schema1.py","line number: ": "99","func name: ": "convert_pandas_type_to_json_field","func arg: ": "(arr, dtype)","comments: ": ""},"func4": {"source file: ": "_table_schema1.py","line number: ": "126","func name: ": "convert_json_field_to_pandas_type","func arg: ": "(field)","comments: ": "Converts a JSON field descriptor into its corresponding NumPy / pandas type\n\nParameters ---------- field A JSON field descriptor\n##### Returns\n"},"func5": {"source file: ": "_table_schema1.py","line number: ": "190","func name: ": "build_table_schema","func arg: ": "(data, index, primary_key, version)","comments: ": "Create a Table schema from ``data``.\n\nParameters ---------- data : Series, DataFrame index : bool, default True Whether to include ``data.index`` in the schema. primary_key : bool or None, default True Column names to designate as the primary key. The default `None` will set `'primaryKey'` to the index level or levels if the index is unique. version : bool, default True Whether to include a field `pandas_version` with the version of pandas that generated the schema.\n##### Returns\n* **schema **: dict\n\n* **... {'A'**: [1, 2, 3],\n\n* **...  'B'**: ['a', 'b', 'c'],\n\n* **...  'C'**: pd.date_range('2016-01-01', freq='d', periods=3),\n\n* **{'fields'**: [{'name'\n\n* **{'name'**: 'C', 'type'\n\n* **'pandas_version'**: '0.20.0',\n\n* **'primaryKey'**: ['idx']}\n\n"},"func6": {"source file: ": "_table_schema1.py","line number: ": "271","func name: ": "parse_table_schema","func arg: ": "(json, precise_float)","comments: ": "Builds a DataFrame from a given schema\n\nParameters ---------- json : A JSON table schema precise_float : boolean Flag controlling precision when decoding string to double values, as dictated by ``read_json``\n##### Returns\n* **df **: DataFrame\n\n"}}{"func1": {"source file: ": "_test_decorators1.py","line number: ": "41","func name: ": "safe_import","func arg: ": "(mod_name, min_version)","comments: ": "Parameters: ----------- mod_name : str Name of the module to be imported min_version : str, default None Minimum required version of the specified mod_name\n\n\n##### Returns\n"},"func2": {"source file: ": "_test_decorators1.py","line number: ": "94","func name: ": "_skip_if_no_mpl","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "_test_decorators1.py","line number: ": "102","func name: ": "_skip_if_has_locale","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "_test_decorators1.py","line number: ": "108","func name: ": "_skip_if_not_us_locale","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "_test_decorators1.py","line number: ": "114","func name: ": "_skip_if_no_scipy","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "_test_decorators1.py","line number: ": "123","func name: ": "skip_if_installed","func arg: ": "(package)","comments: ": "Skip a test if a package is installed.\n\nParameters ---------- package : str The name of the package.\n"},"func7": {"source file: ": "_test_decorators1.py","line number: ": "137","func name: ": "skip_if_no","func arg: ": "(package, min_version)","comments: ": "Generic function to help skip tests when required packages are not present on the testing system.\n\nThis function returns a pytest mark with a skip condition that will be evaluated during test collection. An attempt will be made to import the specified ``package`` and optionally ensure it meets the ``min_version``\n\nThe mark can be used as either a decorator for a test function or to be applied to parameters in pytest.mark.parametrize calls or parametrized fixtures.\n\nIf the import and version check are unsuccessful, then the test function (or test case when used in conjunction with parametrization) will be skipped.\n\nParameters ---------- package: str The name of the required package. min_version: str or None, default None Optional minimum version of the package.\n##### Returns\n"},"func8": {"source file: ": "_test_decorators1.py","line number: ": "199","func name: ": "skip_if_np_lt","func arg: ": "(ver_str, reason, **kwds)","comments: ": ""},"func9": {"source file: ": "_test_decorators1.py","line number: ": "209","func name: ": "parametrize_fixture_doc","func arg: ": "()","comments: ": "Intended for use as a decorator for parametrized fixture, this function will wrap the decorated function with a pytest ``parametrize_fixture_doc`` mark. That mark will format initial fixture docstring by replacing placeholders {0}, {1} etc with parameters passed as arguments.\n\nParameters ---------- args: iterable Positional arguments for docstring.\n##### Returns\n"},"func10": {"source file: ": "_test_decorators1.py","line number: ": "236","func name: ": "check_file_leaks","func arg: ": "(func)","comments: ": "Decorate a test function tot check that we are not leaking file descriptors.\n\n\n"},"func11": {"source file: ": "_test_decorators1.py","line number: ": "257","func name: ": "async_mark","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "_tester1.py","line number: ": "10","func name: ": "test","func arg: ": "(extra_args)","comments: ": ""}}{"func1": {"source file: ": "_testing1.py","line number: ": "80","func name: ": "set_testing_mode","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "_testing1.py","line number: ": "87","func name: ": "reset_testing_mode","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "_testing1.py","line number: ": "97","func name: ": "reset_display_options","func arg: ": "()","comments: ": "Reset the display options for printing and representing objects.\n\n\n"},"func4": {"source file: ": "_testing1.py","line number: ": "104","func name: ": "round_trip_pickle","func arg: ": "(obj, path)","comments: ": "Pickle an object and then read it again.\n\nParameters ---------- obj : any object The object to pickle and then re-read. path : str, path object or file-like object, default None The path where the pickled object is written and then read.\n##### Returns\n"},"func5": {"source file: ": "_testing1.py","line number: ": "130","func name: ": "round_trip_pathlib","func arg: ": "(writer, reader, path)","comments: ": "Write an object to file specified by a pathlib.Path and read it back\n\nParameters ---------- writer : callable bound to pandas object IO writing function (e.g. DataFrame.to_csv ) reader : callable IO reading function (e.g. pd.read_csv ) path : str, default None The path where the object is written and then read.\n##### Returns\n"},"func6": {"source file: ": "_testing1.py","line number: ": "159","func name: ": "round_trip_localpath","func arg: ": "(writer, reader, path)","comments: ": "Write an object to file specified by a py.path LocalPath and read it back.\n\nParameters ---------- writer : callable bound to pandas object IO writing function (e.g. DataFrame.to_csv ) reader : callable IO reading function (e.g. pd.read_csv ) path : str, default None The path where the object is written and then read.\n##### Returns\n"},"func7": {"source file: ": "_testing1.py","line number: ": "189","func name: ": "decompress_file","func arg: ": "(path, compression)","comments: ": "Open a compressed file and return a file object.\n\nParameters ---------- path : str The path where the file is read from.\n\ncompression : {'gzip', 'bz2', 'zip', 'xz', None} Name of the decompression to use\n##### Returns\n"},"func8": {"source file: ": "_testing1.py","line number: ": "231","func name: ": "write_to_compressed","func arg: ": "(compression, path, data, dest)","comments: ": "Write data to a compressed file.\n\nParameters ---------- compression : {'gzip', 'bz2', 'zip', 'xz'} The compression type to use. path : str The file path to write the data. data : str The data to write. dest : str, default \"test\" The destination file (for ZIP only)\n"},"func9": {"source file: ": "_testing1.py","line number: ": "280","func name: ": "assert_almost_equal","func arg: ": "(left, right, check_dtype, check_less_precise, **kwargs)","comments: ": "Check that the left and right objects are approximately equal.\n\nBy approximately equal, we refer to objects that are numbers or that contain numbers which may be equivalent to specific levels of precision.\n\nParameters ---------- left : object right : object check_dtype : bool or {'equiv'}, default 'equiv' Check dtype if both a and b are the same type. If 'equiv' is passed in, then `RangeIndex` and `Int64Index` are also considered equivalent when doing type checking. check_less_precise : bool or int, default False Specify comparison precision. 5 digits (False) or 3 digits (True) after decimal points are compared. If int, then specify the number of digits to compare.\n\nWhen comparing two numbers, if the first number has magnitude less than 1e-5, we compare the two numbers directly and check whether they are equivalent within the specified precision. Otherwise, we compare the **ratio** of the second number to the first number and check whether it is equivalent to 1 within the specified precision.\n"},"func10": {"source file: ": "_testing1.py","line number: ": "366","func name: ": "_check_isinstance","func arg: ": "(left, right, cls)","comments: ": "Helper method for our assert_* methods that ensures that the two objects being compared have the right type before proceeding with the comparison.\n\nParameters ---------- left : The first object being compared. right : The second object being compared. cls : The class type to check against.\n"},"func11": {"source file: ": "_testing1.py","line number: ": "394","func name: ": "assert_dict_equal","func arg: ": "(left, right, compare_keys)","comments: ": ""},"func12": {"source file: ": "_testing1.py","line number: ": "400","func name: ": "randbool","func arg: ": "(size, p)","comments: ": ""},"func13": {"source file: ": "_testing1.py","line number: ": "411","func name: ": "rands_array","func arg: ": "(nchars, size, dtype)","comments: ": "Generate an array of byte strings.\n\n\n"},"func14": {"source file: ": "_testing1.py","line number: ": "426","func name: ": "randu_array","func arg: ": "(nchars, size, dtype)","comments: ": "Generate an array of unicode strings.\n\n\n"},"func15": {"source file: ": "_testing1.py","line number: ": "441","func name: ": "rands","func arg: ": "(nchars)","comments: ": "Generate one random byte string.\n\nSee `rands_array` if you want to create an array of random strings.\n"},"func16": {"source file: ": "_testing1.py","line number: ": "451","func name: ": "randu","func arg: ": "(nchars)","comments: ": "Generate one random unicode string.\n\nSee `randu_array` if you want to create an array of random unicode strings.\n"},"func17": {"source file: ": "_testing1.py","line number: ": "461","func name: ": "close","func arg: ": "(fignum)","comments: ": ""},"func18": {"source file: ": "_testing1.py","line number: ": "476","func name: ": "ensure_clean","func arg: ": "(filename, return_filelike)","comments: ": "Gets a temporary path and agrees to remove on close.\n\nParameters ---------- filename : str (optional) if None, creates a temporary file which is then removed when out of scope. if passed, creates temporary file with filename as ending. return_filelike : bool (default False) if True, returns a file-like which is *always* cleaned. Necessary for savefig and other functions which want to append extensions.\n"},"func19": {"source file: ": "_testing1.py","line number: ": "525","func name: ": "ensure_clean_dir","func arg: ": "()","comments: ": "Get a temporary directory path and agrees to remove on close.\n\nYields ------ Temporary directory path\n"},"func20": {"source file: ": "_testing1.py","line number: ": "544","func name: ": "ensure_safe_environment_variables","func arg: ": "()","comments: ": "Get a context manager to safely set environment variables\n\nAll changes will be undone on close, hence environment variables set within this contextmanager will neither persist nor change global state.\n"},"func21": {"source file: ": "_testing1.py","line number: ": "563","func name: ": "equalContents","func arg: ": "(arr1, arr2)","comments: ": "Checks if the set of unique elements of arr1 and arr2 are equivalent.\n\n\n"},"func22": {"source file: ": "_testing1.py","line number: ": "570","func name: ": "assert_index_equal","func arg: ": "(left, right, exact, check_names, check_less_precise, check_exact, check_categorical, obj)","comments: ": "Check that left and right Index are equal.\n\nParameters ---------- left : Index right : Index exact : bool or {'equiv'}, default 'equiv' Whether to check the Index class, dtype and inferred_type are identical. If 'equiv', then RangeIndex can be substituted for Int64Index as well. check_names : bool, default True Whether to check the names attribute. check_less_precise : bool or int, default False Specify comparison precision. Only used when check_exact is False. 5 digits (False) or 3 digits (True) after decimal points are compared. If int, then specify the digits to compare. check_exact : bool, default True Whether to compare number exactly. check_categorical : bool, default True Whether to compare internal Categorical exactly. obj : str, default 'Index' Specify object name being compared, internally used to show appropriate assertion message.\n"},"func23": {"source file: ": "_testing1.py","line number: ": "702","func name: ": "assert_class_equal","func arg: ": "(left, right, exact, obj)","comments: ": "Checks classes are equal.\n\n\n"},"func24": {"source file: ": "_testing1.py","line number: ": "731","func name: ": "assert_attr_equal","func arg: ": "(attr, left, right, obj)","comments: ": "checks attributes are equal. Both objects must have attribute.\n\nParameters ---------- attr : str Attribute name being compared. left : object right : object obj : str, default 'Attributes' Specify object name being compared, internally used to show appropriate assertion message\n"},"func25": {"source file: ": "_testing1.py","line number: ": "775","func name: ": "assert_is_valid_plot_return_object","func arg: ": "(objs)","comments: ": ""},"func26": {"source file: ": "_testing1.py","line number: ": "794","func name: ": "isiterable","func arg: ": "(obj)","comments: ": ""},"func27": {"source file: ": "_testing1.py","line number: ": "798","func name: ": "assert_is_sorted","func arg: ": "(seq)","comments: ": "Assert that the sequence is sorted.\n\n\n"},"func28": {"source file: ": "_testing1.py","line number: ": "806","func name: ": "assert_categorical_equal","func arg: ": "(left, right, check_dtype, check_category_order, obj)","comments: ": "Test that Categoricals are equivalent.\n\nParameters ---------- left : Categorical right : Categorical check_dtype : bool, default True Check that integer dtype of the codes are the same check_category_order : bool, default True Whether the order of the categories should be compared, which implies identical integer codes.\n\nIf False, only the resulting values are compared.\n\nThe ordered attribute is checked regardless. obj : str, default 'Categorical' Specify object name being compared, internally used to show appropriate assertion message\n"},"func29": {"source file: ": "_testing1.py","line number: ": "848","func name: ": "assert_interval_array_equal","func arg: ": "(left, right, exact, obj)","comments: ": "Test that two IntervalArrays are equivalent.\n\nParameters ---------- left, right : IntervalArray The IntervalArrays to compare. exact : bool or {'equiv'}, default 'equiv' Whether to check the Index class, dtype and inferred_type are identical. If 'equiv', then RangeIndex can be substituted for Int64Index as well. obj : str, default 'IntervalArray' Specify object name being compared, internally used to show appropriate assertion message\n"},"func30": {"source file: ": "_testing1.py","line number: ": "870","func name: ": "assert_period_array_equal","func arg: ": "(left, right, obj)","comments: ": ""},"func31": {"source file: ": "_testing1.py","line number: ": "877","func name: ": "assert_datetime_array_equal","func arg: ": "(left, right, obj)","comments: ": ""},"func32": {"source file: ": "_testing1.py","line number: ": "886","func name: ": "assert_timedelta_array_equal","func arg: ": "(left, right, obj)","comments: ": ""},"func33": {"source file: ": "_testing1.py","line number: ": "893","func name: ": "raise_assert_detail","func arg: ": "(obj, message, left, right, diff)","comments: ": ""},"func34": {"source file: ": "_testing1.py","line number: ": "918","func name: ": "assert_numpy_array_equal","func arg: ": "(left, right, strict_nan, check_dtype, err_msg, check_same, obj)","comments: ": "Check that 'np.ndarray' is equivalent.\n\nParameters ---------- left, right : numpy.ndarray or iterable The two arrays to be compared. strict_nan : bool, default False If True, consider NaN and None to be different. check_dtype : bool, default True Check dtype if both a and b are np.ndarray. err_msg : str, default None If provided, used as assertion message. check_same : None|'copy'|'same', default None Ensure left and right refer/do not refer to the same memory area. obj : str, default 'numpy array' Specify object name being compared, internally used to show appropriate assertion message.\n"},"func35": {"source file: ": "_testing1.py","line number: ": "995","func name: ": "assert_extension_array_equal","func arg: ": "(left, right, check_dtype, check_less_precise, check_exact)","comments: ": "Check that left and right ExtensionArrays are equal.\n\nParameters ---------- left, right : ExtensionArray The two arrays to compare check_dtype : bool, default True Whether to check if the ExtensionArray dtypes are identical. check_less_precise : bool or int, default False Specify comparison precision. Only used when check_exact is False. 5 digits (False) or 3 digits (True) after decimal points are compared. If int, then specify the digits to compare. check_exact : bool, default False Whether to compare number exactly.\n\nNotes ----- Missing values are checked separately from valid values. A mask of missing values is computed for each and checked to match. The remaining all-valid values are cast to object dtype and checked.\n"},"func36": {"source file: ": "_testing1.py","line number: ": "1048","func name: ": "assert_series_equal","func arg: ": "(left, right, check_dtype, check_index_type, check_series_type, check_less_precise, check_names, check_exact, check_datetimelike_compat, check_categorical, check_category_order, obj)","comments: ": "Check that left and right Series are equal.\n\nParameters ---------- left : Series right : Series check_dtype : bool, default True Whether to check the Series dtype is identical. check_index_type : bool or {'equiv'}, default 'equiv' Whether to check the Index class, dtype and inferred_type are identical. check_series_type : bool, default True Whether to check the Series class is identical. check_less_precise : bool or int, default False Specify comparison precision. Only used when check_exact is False. 5 digits (False) or 3 digits (True) after decimal points are compared. If int, then specify the digits to compare.\n\nWhen comparing two numbers, if the first number has magnitude less than 1e-5, we compare the two numbers directly and check whether they are equivalent within the specified precision. Otherwise, we compare the **ratio** of the second number to the first number and check whether it is equivalent to 1 within the specified precision. check_names : bool, default True Whether to check the Series and Index names attribute. check_exact : bool, default False Whether to compare number exactly. check_datetimelike_compat : bool, default False Compare datetime-like which is comparable ignoring dtype. check_categorical : bool, default True Whether to compare internal Categorical exactly. check_category_order : bool, default True Whether to compare category order of internal Categoricals\n\n.. versionadded:: 1.0.2 obj : str, default 'Series' Specify object name being compared, internally used to show appropriate assertion message.\n"},"func37": {"source file: ": "_testing1.py","line number: ": "1209","func name: ": "assert_frame_equal","func arg: ": "(left, right, check_dtype, check_index_type, check_column_type, check_frame_type, check_less_precise, check_names, by_blocks, check_exact, check_datetimelike_compat, check_categorical, check_like, obj)","comments: ": "Check that left and right DataFrame are equal.\n\nThis function is intended to compare two DataFrames and output any differences. Is is mostly intended for use in unit tests. Additional parameters allow varying the strictness of the equality checks performed.\n\nParameters ---------- left : DataFrame First DataFrame to compare. right : DataFrame Second DataFrame to compare. check_dtype : bool, default True Whether to check the DataFrame dtype is identical. check_index_type : bool or {'equiv'}, default 'equiv' Whether to check the Index class, dtype and inferred_type are identical. check_column_type : bool or {'equiv'}, default 'equiv' Whether to check the columns class, dtype and inferred_type are identical. Is passed as the ``exact`` argument of :func:`assert_index_equal`. check_frame_type : bool, default True Whether to check the DataFrame class is identical. check_less_precise : bool or int, default False Specify comparison precision. Only used when check_exact is False. 5 digits (False) or 3 digits (True) after decimal points are compared. If int, then specify the digits to compare.\n\nWhen comparing two numbers, if the first number has magnitude less than 1e-5, we compare the two numbers directly and check whether they are equivalent within the specified precision. Otherwise, we compare the **ratio** of the second number to the first number and check whether it is equivalent to 1 within the specified precision. check_names : bool, default True Whether to check that the `names` attribute for both the `index` and `column` attributes of the DataFrame is identical. by_blocks : bool, default False Specify how to compare internal data. If False, compare by columns. If True, compare by blocks. check_exact : bool, default False Whether to compare number exactly. check_datetimelike_compat : bool, default False Compare datetime-like which is comparable ignoring dtype. check_categorical : bool, default True Whether to compare internal Categorical exactly. check_like : bool, default False If True, ignore the order of index & columns. Note: index labels must match their respective rows (same as in columns)\n\n- same labels must be with the same data. obj : str, default 'DataFrame' Specify object name being compared, internally used to show appropriate assertion message.\n\nSee Also -------- assert_series_equal : Equivalent method for asserting Series equality. DataFrame.equals : Check DataFrame equality.\n\nExamples -------- This example shows comparing two DataFrames that are equal but with columns of differing dtypes.\n\n>>> from pandas._testing import assert_frame_equal >>> df1 = pd.DataFrame({'a': [1, 2], 'b': [3, 4]}) >>> df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})\n\ndf1 equals itself.\n\n>>> assert_frame_equal(df1, df1)\n\ndf1 differs from df2 as column 'b' is of a different type.\n\n>>> assert_frame_equal(df1, df2) Traceback (most recent call last): ... AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=\"b\") are different\n\nAttribute \"dtype\" are different [left]:\n\nint64 [right]: float64\n\nIgnore differing dtypes in columns with check_dtype.\n\n>>> assert_frame_equal(df1, df2, check_dtype=False)\n"},"func38": {"source file: ": "_testing1.py","line number: ": "1386","func name: ": "assert_equal","func arg: ": "(left, right, **kwargs)","comments: ": "Wrapper for tm.assert_*_equal to dispatch to the appropriate test function.\n\nParameters ---------- left, right : Index, Series, DataFrame, ExtensionArray, or np.ndarray The two items to be compared. **kwargs All keyword arguments are passed through to the underlying assert method.\n"},"func39": {"source file: ": "_testing1.py","line number: ": "1424","func name: ": "box_expected","func arg: ": "(expected, box_cls, transpose)","comments: ": "Helper function to wrap the expected output of a test in a given box_class.\n\nParameters ---------- expected : np.ndarray, Index, Series box_cls : {Index, Series, DataFrame}\n##### Returns\n"},"func40": {"source file: ": "_testing1.py","line number: ": "1464","func name: ": "to_array","func arg: ": "(obj)","comments: ": ""},"func41": {"source file: ": "_testing1.py","line number: ": "1480","func name: ": "assert_sp_array_equal","func arg: ": "(left, right, check_dtype, check_kind, check_fill_value, consolidate_block_indices)","comments: ": "Check that the left and right SparseArray are equal.\n\nParameters ---------- left : SparseArray right : SparseArray check_dtype : bool, default True Whether to check the data dtype is identical. check_kind : bool, default True Whether to just the kind of the sparse index for each column. check_fill_value : bool, default True Whether to check that left.fill_value matches right.fill_value consolidate_block_indices : bool, default False Whether to consolidate contiguous blocks for sparse arrays with a BlockIndex. Some operations, e.g. concat, will end up with block indices that could be consolidated. Setting this to true will create a new BlockIndex for that array, with consolidated block indices.\n"},"func42": {"source file: ": "_testing1.py","line number: ": "1547","func name: ": "assert_contains_all","func arg: ": "(iterable, dic)","comments: ": ""},"func43": {"source file: ": "_testing1.py","line number: ": "1552","func name: ": "assert_copy","func arg: ": "(iter1, iter2, **eql_kwargs)","comments: ": "iter1, iter2: iterables that produce elements comparable with assert_almost_equal\n\nChecks that the elements are equal, but not the same object. (Does not check that items in sequences are also not the same object)\n"},"func44": {"source file: ": "_testing1.py","line number: ": "1570","func name: ": "getCols","func arg: ": "(k)","comments: ": ""},"func45": {"source file: ": "_testing1.py","line number: ": "1575","func name: ": "makeStringIndex","func arg: ": "(k, name)","comments: ": ""},"func46": {"source file: ": "_testing1.py","line number: ": "1579","func name: ": "makeUnicodeIndex","func arg: ": "(k, name)","comments: ": ""},"func47": {"source file: ": "_testing1.py","line number: ": "1583","func name: ": "makeCategoricalIndex","func arg: ": "(k, n, name, **kwargs)","comments: ": "make a length k index or n categories\n\n\n"},"func48": {"source file: ": "_testing1.py","line number: ": "1591","func name: ": "makeIntervalIndex","func arg: ": "(k, name, **kwargs)","comments: ": "make a length k IntervalIndex\n\n\n"},"func49": {"source file: ": "_testing1.py","line number: ": "1597","func name: ": "makeBoolIndex","func arg: ": "(k, name)","comments: ": ""},"func50": {"source file: ": "_testing1.py","line number: ": "1605","func name: ": "makeIntIndex","func arg: ": "(k, name)","comments: ": ""},"func51": {"source file: ": "_testing1.py","line number: ": "1609","func name: ": "makeUIntIndex","func arg: ": "(k, name)","comments: ": ""},"func52": {"source file: ": "_testing1.py","line number: ": "1613","func name: ": "makeRangeIndex","func arg: ": "(k, name, **kwargs)","comments: ": ""},"func53": {"source file: ": "_testing1.py","line number: ": "1617","func name: ": "makeFloatIndex","func arg: ": "(k, name)","comments: ": ""},"func54": {"source file: ": "_testing1.py","line number: ": "1622","func name: ": "makeDateIndex","func arg: ": "(k, freq, name, **kwargs)","comments: ": ""},"func55": {"source file: ": "_testing1.py","line number: ": "1628","func name: ": "makeTimedeltaIndex","func arg: ": "(k, freq, name, **kwargs)","comments: ": ""},"func56": {"source file: ": "_testing1.py","line number: ": "1632","func name: ": "makePeriodIndex","func arg: ": "(k, name, **kwargs)","comments: ": ""},"func57": {"source file: ": "_testing1.py","line number: ": "1638","func name: ": "makeMultiIndex","func arg: ": "(k, names, **kwargs)","comments: ": ""},"func58": {"source file: ": "_testing1.py","line number: ": "1672","func name: ": "_make_timeseries","func arg: ": "(start, end, freq, seed)","comments: ": "Make a DataFrame with a DatetimeIndex\n\nParameters ---------- start : str or Timestamp, default \"2000-01-01\" The start of the index. Passed to date_range with `freq`. end : str or Timestamp, default \"2000-12-31\" The end of the index. Passed to date_range with `freq`. freq : str or Freq The frequency to use for the DatetimeIndex seed : int, optional The random state seed.\n\n* name : object dtype with string names * id : int dtype with * x, y : float dtype\n\nExamples -------- >>> _make_timeseries() id\n\n\n\nname\n\n\n\n\n\n\n\n x\n\n\n\n\n\n\n\n y timestamp 2000-01-01\n\n 982\n\n Frank\n\n0.031261\n\n0.986727 2000-01-02\n\n1025\n\n Edith -0.086358 -0.032920 2000-01-03\n\n 982\n\n Edith\n\n0.473177\n\n0.298654 2000-01-04\n\n1009\n\n Sarah\n\n0.534344 -0.750377 2000-01-05\n\n 963\n\n Zelda -0.271573\n\n0.054424 ...\n\n\n\n\n\n\n\n\n\n...\n\n\n\n ...\n\n\n\n\n\n ...\n\n\n\n\n\n ... 2000-12-27\n\n 980\n\nIngrid -0.132333 -0.422195 2000-12-28\n\n 972\n\n Frank -0.376007 -0.298687 2000-12-29\n\n1009\n\nUrsula -0.865047 -0.503133 2000-12-30\n\n1000\n\nHannah -0.063757 -0.507336 2000-12-31\n\n 972\n\n\n\n Tim -0.869120\n\n0.531685\n"},"func59": {"source file: ": "_testing1.py","line number: ": "1723","func name: ": "all_index_generator","func arg: ": "(k)","comments: ": "Generator which can be iterated over to get instances of all the various index classes.\n\nParameters ---------- k: length of each of the index instances\n"},"func60": {"source file: ": "_testing1.py","line number: ": "1748","func name: ": "index_subclass_makers_generator","func arg: ": "()","comments: ": ""},"func61": {"source file: ": "_testing1.py","line number: ": "1762","func name: ": "all_timeseries_index_generator","func arg: ": "(k)","comments: ": "Generator which can be iterated over to get instances of all the classes which represent time-series.\n\nParameters ---------- k: length of each of the index instances\n"},"func62": {"source file: ": "_testing1.py","line number: ": "1776","func name: ": "makeFloatSeries","func arg: ": "(name)","comments: ": ""},"func63": {"source file: ": "_testing1.py","line number: ": "1781","func name: ": "makeStringSeries","func arg: ": "(name)","comments: ": ""},"func64": {"source file: ": "_testing1.py","line number: ": "1786","func name: ": "makeObjectSeries","func arg: ": "(name)","comments: ": ""},"func65": {"source file: ": "_testing1.py","line number: ": "1793","func name: ": "getSeriesData","func arg: ": "()","comments: ": ""},"func66": {"source file: ": "_testing1.py","line number: ": "1798","func name: ": "makeTimeSeries","func arg: ": "(nper, freq, name)","comments: ": ""},"func67": {"source file: ": "_testing1.py","line number: ": "1804","func name: ": "makePeriodSeries","func arg: ": "(nper, name)","comments: ": ""},"func68": {"source file: ": "_testing1.py","line number: ": "1810","func name: ": "getTimeSeriesData","func arg: ": "(nper, freq)","comments: ": ""},"func69": {"source file: ": "_testing1.py","line number: ": "1814","func name: ": "getPeriodData","func arg: ": "(nper)","comments: ": ""},"func70": {"source file: ": "_testing1.py","line number: ": "1819","func name: ": "makeTimeDataFrame","func arg: ": "(nper, freq)","comments: ": ""},"func71": {"source file: ": "_testing1.py","line number: ": "1824","func name: ": "makeDataFrame","func arg: ": "()","comments: ": ""},"func72": {"source file: ": "_testing1.py","line number: ": "1829","func name: ": "getMixedTypeDict","func arg: ": "()","comments: ": ""},"func73": {"source file: ": "_testing1.py","line number: ": "1842","func name: ": "makeMixedDataFrame","func arg: ": "()","comments: ": ""},"func74": {"source file: ": "_testing1.py","line number: ": "1846","func name: ": "makePeriodFrame","func arg: ": "(nper)","comments: ": ""},"func75": {"source file: ": "_testing1.py","line number: ": "1851","func name: ": "makeCustomIndex","func arg: ": "(nentries, nlevels, prefix, names, ndupe_l, idx_type)","comments: ": "Create an index/multindex with given dimensions, levels, names, etc'\n\nnentries\n\n- number of entries in index nlevels\n\n- number of levels (> 1 produces multindex) prefix\n\n- a string prefix for labels names\n\n- (Optional), bool or list of strings. if True will use default names, if false will use no names, if a list is given, the name of each level in the index will be taken from the list. ndupe_l\n\n- (Optional), list of ints, the number of rows for which the label will repeated at the corresponding level, you can specify just the first few, the rest will use the default ndupe_l of 1. len(ndupe_l) <= nlevels. idx_type\n\n- \"i\"/\"f\"/\"s\"/\"u\"/\"dt\"/\"p\"/\"td\". If idx_type is not None, `idx_nlevels` must be 1. \"i\"/\"f\" creates an integer/float index, \"s\"/\"u\" creates a string/unicode index \"dt\" create a datetime index. \"td\" create a datetime index.\n\nif unspecified, string labels will be generated.\n"},"func76": {"source file: ": "_testing1.py","line number: ": "1956","func name: ": "makeCustomDataframe","func arg: ": "(nrows, ncols, c_idx_names, r_idx_names, c_idx_nlevels, r_idx_nlevels, data_gen_f, c_ndupe_l, r_ndupe_l, dtype, c_idx_type, r_idx_type)","comments: ": "nrows,  ncols - number of data rows/cols c_idx_names, idx_names  - False/True/list of strings,  yields No names , default names or uses the provided names for the levels of the corresponding index. You can provide a single string when c_idx_nlevels ==1. c_idx_nlevels - number of levels in columns index. > 1 will yield MultiIndex r_idx_nlevels - number of levels in rows index. > 1 will yield MultiIndex data_gen_f - a function f(row,col) which return the data value at that position, the default generator used yields values of the form \"RxCy\" based on position. c_ndupe_l, r_ndupe_l - list of integers, determines the number of duplicates for each label at a given level of the corresponding index. The default `None` value produces a multiplicity of 1 across all levels, i.e. a unique index. Will accept a partial list of length N < idx_nlevels, for just the first N levels. If ndupe doesn't divide nrows/ncol, the last label might have lower multiplicity. dtype - passed to the DataFrame constructor as is, in case you wish to have more control in conjunction with a custom `data_gen_f` r_idx_type, c_idx_type -  \"i\"/\"f\"/\"s\"/\"u\"/\"dt\"/\"td\". If idx_type is not None, `idx_nlevels` must be 1. \"i\"/\"f\" creates an integer/float index, \"s\"/\"u\" creates a string/unicode index \"dt\" create a datetime index. \"td\" create a timedelta index.\n\nif unspecified, string labels will be generated.\n\nExamples:\n\n# 5 row, 3 columns, default names on both, single index on both axis >> makeCustomDataframe(5,3)\n\n# make the data a random int between 1 and 100 >> mkdf(5,3,data_gen_f=lambda r,c:randint(1,100))\n\n# 2-level multiindex on rows with each label duplicated # twice on first level, default names on both axis, single # index on both axis >> a=makeCustomDataframe(5,3,r_idx_nlevels=2,r_ndupe_l=[2])\n\n# DatetimeIndex on row, index with unicode labels on columns # no names on either axis >> a=makeCustomDataframe(5,3,c_idx_names=False,r_idx_names=False, r_idx_type=\"dt\",c_idx_type=\"u\")\n\n# 4-level multindex on rows with names provided, 2-level multindex # on columns with default labels and default names. >> a=makeCustomDataframe(5,3,r_idx_nlevels=4, r_idx_names=[\"FEE\",\"FI\",\"FO\",\"FAM\"], c_idx_nlevels=2)\n\n>> a=mkdf(5,3,r_idx_nlevels=2,c_idx_nlevels=4)\n"},"func77": {"source file: ": "_testing1.py","line number: ": "2060","func name: ": "_create_missing_idx","func arg: ": "(nrows, ncols, density, random_state)","comments: ": ""},"func78": {"source file: ": "_testing1.py","line number: ": "2087","func name: ": "makeMissingCustomDataframe","func arg: ": "(nrows, ncols, density, random_state, c_idx_names, r_idx_names, c_idx_nlevels, r_idx_nlevels, data_gen_f, c_ndupe_l, r_ndupe_l, dtype, c_idx_type, r_idx_type)","comments: ": "Parameters ---------- Density : float, optional Float in (0, 1) that gives the percentage of non-missing numbers in the DataFrame. random_state : {np.random.RandomState, int}, optional Random number generator or random seed.\n\nSee makeCustomDataframe for descriptions of the rest of the parameters.\n"},"func79": {"source file: ": "_testing1.py","line number: ": "2134","func name: ": "makeMissingDataframe","func arg: ": "(density, random_state)","comments: ": ""},"func80": {"source file: ": "_testing1.py","line number: ": "2141","func name: ": "optional_args","func arg: ": "(decorator)","comments: ": "allows a decorator to take optional positional and keyword arguments. Assumes that taking a single, callable, positional argument means that it is decorating a function, i.e. something like this\n\n@my_decorator def function(): pass\n\nCalls decorator with decorator(f, *args, **kwargs)\n"},"func81": {"source file: ": "_testing1.py","line number: ": "2205","func name: ": "_get_default_network_errors","func arg: ": "()","comments: ": ""},"func82": {"source file: ": "_testing1.py","line number: ": "2212","func name: ": "can_connect","func arg: ": "(url, error_classes)","comments: ": "Try to connect to the given url. True if succeeds, False if IOError raised\n\nParameters ---------- url : basestring The URL to try to connect to\n##### Returns\n* **connectable **: bool\nReturn True if no IOError (unable to connect) or URLError (bad url) was\nraised\n\n"},"func83": {"source file: ": "_testing1.py","line number: ": "2241","func name: ": "network","func arg: ": "(t, url, raise_on_error, check_before_test, error_classes, skip_errnos, _skip_on_messages)","comments: ": "Label a test as requiring network connection and, if an error is encountered, only raise if it does not find a network connection.\n\nIn comparison to ``network``, this assumes an added contract to your test: you must assert that, under normal conditions, your test will ONLY fail if it does not have network connectivity.\n\nYou can call this in 3 ways: as a standard decorator, with keyword arguments, or with a positional argument that is the url to check.\n\nParameters ---------- t : callable The test requiring network connectivity. url : path The url to test via ``pandas.io.common.urlopen`` to check for connectivity. Defaults to 'http://www.google.com'. raise_on_error : bool If True, never catches errors. check_before_test : bool If True, checks connectivity before running the test case. error_classes : tuple or Exception error classes to ignore. If not in ``error_classes``, raises the error. defaults to IOError. Be careful about changing the error classes here. skip_errnos : iterable of int Any exception that has .errno or .reason.erno set to one of these values will be skipped with an appropriate message. _skip_on_messages: iterable of string any exception e for which one of the strings is a substring of str(e) will be skipped with an appropriate message. Intended to suppress errors where an errno isn't available.\n\nNotes ----- * ``raise_on_error`` supercedes ``check_before_test``\n##### Returns\n* **t **: callable\nThe decorated test ``t``, with checks for connectivity errors.\n\n* **connection to another URL (defaults to google.com)**: \n\n* **test on failure**: \n\n"},"func84": {"source file: ": "_testing1.py","line number: ": "2376","func name: ": "assert_produces_warning","func arg: ": "(expected_warning, filter_level, clear, check_stacklevel, raise_on_extra_warnings)","comments: ": "Context manager for running code expected to either raise a specific warning, or not raise any warnings. Verifies that the code raises the expected warning, and that it does not raise any other unexpected warnings. It is basically a wrapper around ``warnings.catch_warnings``.\n\nParameters ---------- expected_warning : {Warning, False, None}, default Warning The type of Exception raised. ``exception.Warning`` is the base class for all warnings. To check that no warning is returned, specify ``False`` or ``None``. filter_level : str or None, default \"always\" Specifies whether warnings are ignored, displayed, or turned into errors. Valid values are:\n\n* \"error\"\n\n- turns matching warnings into exceptions * \"ignore\"\n\n- discard the warning * \"always\"\n\n- always emit a warning * \"default\"\n\n- print the warning the first time it is generated from each location * \"module\"\n\n- print the warning the first time it is generated from each module * \"once\"\n\n- print the warning the first time it is generated\n\nclear : str, default None If not ``None`` then remove any previously raised warnings from the ``__warningsregistry__`` to ensure that no warning messages are suppressed by this context manager. If ``None`` is specified, the ``__warningsregistry__`` keeps track of which warnings have been shown, and does not show them again. check_stacklevel : bool, default True If True, displays the line that called the function containing the warning to show were the function is called. Otherwise, the line that implements the function is displayed. raise_on_extra_warnings : bool, default True Whether extra warnings not of the type `expected_warning` should cause the test to fail.\n\nExamples -------- >>> import warnings >>> with assert_produces_warning(): ...\n\n\n\n warnings.warn(UserWarning()) ... >>> with assert_produces_warning(False): ...\n\n\n\n warnings.warn(RuntimeWarning()) ... Traceback (most recent call last): ... AssertionError: Caused unexpected warning(s): ['RuntimeWarning']. >>> with assert_produces_warning(UserWarning): ...\n\n\n\n warnings.warn(RuntimeWarning()) Traceback (most recent call last): ... AssertionError: Did not see expected warning of class 'UserWarning'.\n\n..warn:: This is *not* thread-safe.\n"},"func85": {"source file: ": "_testing1.py","line number: ": "2535","func name: ": "with_csv_dialect","func arg: ": "(name, **kwargs)","comments: ": "Context manager to temporarily register a CSV dialect for parsing CSV.\n\nParameters ---------- name : str The name of the dialect. kwargs : mapping The parameters for the dialect.\n"},"func86": {"source file: ": "_testing1.py","line number: ": "2567","func name: ": "use_numexpr","func arg: ": "(use, min_elements)","comments: ": ""},"func87": {"source file: ": "_testing1.py","line number: ": "2582","func name: ": "test_parallel","func arg: ": "(num_threads, kwargs_list)","comments: ": "Decorator to run the same function multiple times in parallel.\n\nParameters ---------- num_threads : int, optional The number of times the function is run in parallel. kwargs_list : list of dicts, optional The list of kwargs to update original function kwargs on different threads. Notes ----- This decorator does not pass the return value of the decorated function.\n\nOriginal from scikit-image:\n\nhttps://github.com/scikit-image/scikit-image/pull/1519\n"},"func88": {"source file: ": "_testing1.py","line number: ": "2661","func name: ": "set_timezone","func arg: ": "(tz)","comments: ": "Context manager for temporarily setting a timezone.\n\nParameters ---------- tz : str A string representing a valid timezone.\n\nExamples --------\n\n>>> from datetime import datetime >>> from dateutil.tz import tzlocal >>> tzlocal().tzname(datetime.now()) 'IST'\n\n>>> with set_timezone('US/Eastern'): ...\n\n\n\n tzlocal().tzname(datetime.now()) ... 'EDT'\n"},"func89": {"source file: ": "_testing1.py","line number: ": "2705","func name: ": "_make_skipna_wrapper","func arg: ": "(alternative, skipna_alternative)","comments: ": "Create a function for calling on an array.\n\nParameters ---------- alternative : function The function to be called on the array with no NaNs. Only used when 'skipna_alternative' is None. skipna_alternative : function The function to be called on the original array\n##### Returns\n"},"func90": {"source file: ": "_testing1.py","line number: ": "2737","func name: ": "convert_rows_list_to_csv_str","func arg: ": "(rows_list)","comments: ": "Convert list of CSV rows to single CSV-formatted string for current OS.\n\nThis method is used for creating expected value of to_csv() method.\n\nParameters ---------- rows_list : List[str] Each element represents the row of csv.\n##### Returns\n"}}{"func1": {"source file: ": "_util1.py","line number: ": "8","func name: ": "register_writer","func arg: ": "(klass)","comments: ": "Add engine to the excel writer registry.io.excel.\n\nYou must use this method to integrate with ``to_excel``.\n\nParameters ---------- klass : ExcelWriter\n"},"func2": {"source file: ": "_util1.py","line number: ": "24","func name: ": "_get_default_writer","func arg: ": "(ext)","comments: ": "Return the default writer for the given extension.\n\nParameters ---------- ext : str The excel file extension for which to get the default engine.\n##### Returns\n"},"func3": {"source file: ": "_util1.py","line number: ": "47","func name: ": "get_writer","func arg: ": "(engine_name)","comments: ": ""},"func4": {"source file: ": "_util1.py","line number: ": "54","func name: ": "_excel2num","func arg: ": "(x)","comments: ": "Convert Excel column name like 'AB' to 0-based column index.\n\nParameters ---------- x : str The Excel column name to convert to a 0-based column index.\n##### Returns\n* **num **: int\nThe column index corresponding to the name.\n\n"},"func5": {"source file: ": "_util1.py","line number: ": "86","func name: ": "_range2cols","func arg: ": "(areas)","comments: ": "Convert comma separated list of column names and ranges to indices.\n\nParameters ---------- areas : str A string containing a sequence of column ranges (or areas).\n##### Returns\n* **cols **: list\nA list of 0-based column indices.\n\n* **>>> _range2cols('A**: E')\n\n* **>>> _range2cols('A,C,Z**: AB')\n\n"},"func6": {"source file: ": "_util1.py","line number: ": "119","func name: ": "_maybe_convert_usecols","func arg: ": "(usecols)","comments: ": "Convert `usecols` into a compatible format for parsing in `parsers.py`.\n\nParameters ---------- usecols : object The use-columns object to potentially convert.\n##### Returns\n* **converted **: object\nThe compatible format of `usecols`.\n\n"},"func7": {"source file: ": "_util1.py","line number: ": "149","func name: ": "_validate_freeze_panes","func arg: ": "(freeze_panes)","comments: ": ""},"func8": {"source file: ": "_util1.py","line number: ": "166","func name: ": "_trim_excel_header","func arg: ": "(row)","comments: ": ""},"func9": {"source file: ": "_util1.py","line number: ": "174","func name: ": "_fill_mi_header","func arg: ": "(row, control_row)","comments: ": "Forward fill blank entries in row but only inside the same parent index.\n\nUsed for creating headers in Multiindex. Parameters ---------- row : list List of items in a single row. control_row : list of bool Helps to determine if particular column is in same parent index as the previous value. Used to stop propagation of empty cells between different indexes.\n"},"func10": {"source file: ": "_util1.py","line number: ": "205","func name: ": "_pop_header_name","func arg: ": "(row, index_col)","comments: ": "Pop the header name for MultiIndex parsing.\n\nParameters ---------- row : list The data row to parse for the header name. index_col : int, list The index columns for our data. Assumed to be non-null.\n##### Returns\n* **header_name **: str\nThe extracted header name.\n\n* **trimmed_row **: list\nThe original data row with the header name removed.\n\n"}}{"func1": {"source file: ": "_validators1.py","line number: ": "13","func name: ": "_check_arg_length","func arg: ": "(fname, args, max_fname_arg_count, compat_args)","comments: ": "Checks whether 'args' has length of at most 'compat_args'. Raises a TypeError if that is not the case, similar to in Python when a function is called with too many arguments.\n\n\n"},"func2": {"source file: ": "_validators1.py","line number: ": "33","func name: ": "_check_for_default_values","func arg: ": "(fname, arg_val_dict, compat_args)","comments: ": "Check that the keys in `arg_val_dict` are mapped to their default values as specified in `compat_args`.\n\nNote that this function is to be called only when it has been checked that arg_val_dict.keys() is a subset of compat_args\n"},"func3": {"source file: ": "_validators1.py","line number: ": "71","func name: ": "validate_args","func arg: ": "(fname, args, max_fname_arg_count, compat_args)","comments: ": "Checks whether the length of the `*args` argument passed into a function has at most `len(compat_args)` arguments and whether or not all of these elements in `args` are set to their default values.\n\nParameters ---------- fname : str The name of the function being passed the `*args` parameter args : tuple The `*args` parameter passed into a function max_fname_arg_count : int The maximum number of arguments that the function `fname` can accept, excluding those in `args`. Used for displaying appropriate error messages. Must be non-negative. compat_args : dict A dictionary of keys and their associated default values. In order to accommodate buggy behaviour in some versions of `numpy`, where a signature displayed keyword arguments but then passed those arguments **positionally** internally when calling downstream implementations, a dict ensures that the original order of the keyword arguments is enforced.\n"},"func4": {"source file: ": "_validators1.py","line number: ": "111","func name: ": "_check_for_invalid_keys","func arg: ": "(fname, kwargs, compat_args)","comments: ": "Checks whether 'kwargs' contains any keys that are not in 'compat_args' and raises a TypeError if there is one.\n\n\n"},"func5": {"source file: ": "_validators1.py","line number: ": "124","func name: ": "validate_kwargs","func arg: ": "(fname, kwargs, compat_args)","comments: ": "Checks whether parameters passed to the **kwargs argument in a function `fname` are valid parameters as specified in `*compat_args` and whether or not they are set to their default values.\n\nParameters ---------- fname : str The name of the function being passed the `**kwargs` parameter kwargs : dict The `**kwargs` parameter passed into `fname` compat_args: dict A dictionary of keys that `kwargs` is allowed to have and their associated default values\n"},"func6": {"source file: ": "_validators1.py","line number: ": "151","func name: ": "validate_args_and_kwargs","func arg: ": "(fname, args, kwargs, max_fname_arg_count, compat_args)","comments: ": "Checks whether parameters passed to the *args and **kwargs argument in a function `fname` are valid parameters as specified in `*compat_args` and whether or not they are set to their default values.\n\nParameters ---------- fname: str The name of the function being passed the `**kwargs` parameter args: tuple The `*args` parameter passed into a function kwargs: dict The `**kwargs` parameter passed into `fname` max_fname_arg_count: int The minimum number of arguments that the function `fname` requires, excluding those in `args`. Used for displaying appropriate error messages. Must be non-negative. compat_args: dict A dictionary of keys that `kwargs` is allowed to have and their associated default values.\n"},"func7": {"source file: ": "_validators1.py","line number: ": "207","func name: ": "validate_bool_kwarg","func arg: ": "(value, arg_name)","comments: ": "Ensures that argument passed in arg_name is of type bool.\n\n\n"},"func8": {"source file: ": "_validators1.py","line number: ": "217","func name: ": "validate_axis_style_args","func arg: ": "(data, args, kwargs, arg_name, method_name)","comments: ": "Argument handler for mixed index, columns / axis functions\n\nIn an attempt to handle both `.method(index, columns)`, and `.method(arg, axis=.)`, we have to do some bad things to argument parsing. This translates all arguments to `{index=., columns=.}` style.\n\nParameters ---------- data : DataFrame args : tuple All positional arguments from the user kwargs : dict All keyword arguments from the user arg_name, method_name : str Used for better error messages\n##### Returns\n* **kwargs **: dict\nA dictionary of keyword arguments. Doesn't modify ``kwargs``\ninplace, so update them with the return value here.\n\n* **>>> df._validate_axis_style_args((str.upper,), {'columns'**: id},\n\n* **{'columns'**: <function id>, 'index'\n\n"},"func9": {"source file: ": "_validators1.py","line number: ": "311","func name: ": "validate_fillna_kwargs","func arg: ": "(value, method, validate_scalar_dict_value)","comments: ": "Validate the keyword arguments to 'fillna'.\n\nThis checks that exactly one of 'value' and 'method' is specified. If 'method' is specified, this validates that it's a valid method.\n\nParameters ---------- value, method : object The 'value' and 'method' keyword arguments for 'fillna'. validate_scalar_dict_value : bool, default True Whether to validate that 'value' is a scalar or dict. Specifically, validate that it is not a list or tuple.\n##### Returns\n* **value, method **: object\n\n"},"func10": {"source file: ": "_validators1.py","line number: ": "349","func name: ": "validate_percentile","func arg: ": "(q)","comments: ": "Validate percentiles (used by describe and quantile).\n\nThis function checks if the given float oriterable of floats is a valid percentile otherwise raises a ValueError.\n\nParameters ---------- q: float or iterable of floats A single percentile or an iterable of percentiles.\n##### Returns\n"}}{"func1": {"source file: ": "_version1.py","line number: ": "22","func name: ": "get_versions","func arg: ": "()","comments: ": ""}}{}{}{}{}{"func1": {"source file: ": "accessor2.py","line number: ": "118","func name: ": "delegate_names","func arg: ": "(delegate, accessors, typ, overwrite)","comments: ": "Add delegated names to a class using a class decorator.  This provides an alternative usage to directly calling `_add_delegate_accessors` below a class definition.\n\nParameters ---------- delegate : object The class to get methods/properties & doc-strings. accessors : Sequence[str] List of accessor to add. typ : {'property', 'method'} overwrite : bool, default False Overwrite the method/property in the target class if it exists.\n##### Returns\n* **class CategoricalAccessor(PandasDelegate)**: [...]\n\n"},"func2": {"source file: ": "accessor2.py","line number: ": "196","func name: ": "_register_accessor","func arg: ": "(name, cls)","comments: ": ""},"func3": {"source file: ": "accessor2.py","line number: ": "289","func name: ": "register_dataframe_accessor","func arg: ": "(name)","comments: ": ""},"func4": {"source file: ": "accessor2.py","line number: ": "301","func name: ": "register_series_accessor","func arg: ": "(name)","comments: ": ""},"func5": {"source file: ": "accessor2.py","line number: ": "313","func name: ": "register_index_accessor","func arg: ": "(name)","comments: ": ""}}{}{"func1": {"source file: ": "algorithms1.py","line number: ": "64","func name: ": "_ensure_data","func arg: ": "(values, dtype)","comments: ": "routine to ensure that our data is of the correct input dtype for lower-level routines\n\nThis will coerce:\n\n- ints -> int64\n\n- uint -> uint64\n\n- bool -> uint64 (TODO this should be uint8)\n\n- datetimelike -> i8\n\n- datetime64tz -> i8 (in local tz)\n\n- categorical -> codes\n\nParameters ---------- values : array-like dtype : pandas_dtype, optional coerce to this dtype\n##### Returns\n* **values **: ndarray\n\n* **pandas_dtype **: str or dtype\n\n"},"func2": {"source file: ": "algorithms1.py","line number: ": "171","func name: ": "_reconstruct_data","func arg: ": "(values, dtype, original)","comments: ": "reverse of _ensure_data\n\nParameters ---------- values : ndarray dtype : pandas_dtype original : ndarray-like\n##### Returns\n"},"func3": {"source file: ": "algorithms1.py","line number: ": "205","func name: ": "_ensure_arraylike","func arg: ": "(values)","comments: ": "ensure that we are arraylike if not already\n\n\n"},"func4": {"source file: ": "algorithms1.py","line number: ": "229","func name: ": "_get_hashtable_algo","func arg: ": "(values)","comments: ": "Parameters ---------- values : arraylike\n\n\n##### Returns\n* **htable **: HashTable subclass\n\n* **values **: ndarray\n\n"},"func5": {"source file: ": "algorithms1.py","line number: ": "247","func name: ": "_get_values_for_rank","func arg: ": "(values)","comments: ": ""},"func6": {"source file: ": "algorithms1.py","line number: ": "255","func name: ": "_get_data_algo","func arg: ": "(values)","comments: ": ""},"func7": {"source file: ": "algorithms1.py","line number: ": "264","func name: ": "_check_object_for_strings","func arg: ": "(values)","comments: ": "Check if we can use string hashtable instead of object hashtable.\n\nParameters ---------- values : ndarray ndtype : str\n##### Returns\n"},"func8": {"source file: ": "algorithms1.py","line number: ": "293","func name: ": "unique","func arg: ": "(values)","comments: ": "Hash table-based unique. Uniques are returned in order of appearance. This does NOT sort.\n\nSignificantly faster than numpy.unique. Includes NA values.\n\nParameters ---------- values : 1d array-like\n##### Returns\n* **numpy.ndarray or ExtensionArray\nThe return can be**: * Index\n\n* **array(['2016-01-01T00**: 00\n\n* **array([Timestamp('2016-01-01 00**: 00\n\n* **DatetimeIndex(['2016-01-01 00**: 00\n\n* **Categories (3, object)**: [a < b < c]\n\n"},"func9": {"source file: ": "algorithms1.py","line number: ": "390","func name: ": "isin","func arg: ": "(comps, values)","comments: ": "Compute the isin boolean array.\n\nParameters ---------- comps : array-like values : array-like\n##### Returns\n"},"func10": {"source file: ": "algorithms1.py","line number: ": "456","func name: ": "_factorize_array","func arg: ": "(values, na_sentinel, size_hint, na_value)","comments: ": "Factorize an array-like to codes and uniques.\n\nThis doesn't do any coercion of types or unboxing before factorization.\n\nParameters ---------- values : ndarray na_sentinel : int, default -1 size_hint : int, optional Passsed through to the hashtable's 'get_labels' method na_value : object, optional A value in `values` to consider missing. Note: only use this parameter when you know that you don't have any values pandas would consider missing in the array (NaN for float data, iNaT for datetimes, etc.).\n##### Returns\n* **codes **: ndarray\n\n* **uniques **: ndarray\n\n"},"func11": {"source file: ": "algorithms1.py","line number: ": "608","func name: ": "factorize","func arg: ": "(values, sort, na_sentinel, size_hint)","comments: ": ""},"func12": {"source file: ": "algorithms1.py","line number: ": "657","func name: ": "value_counts","func arg: ": "(values, sort, ascending, normalize, bins, dropna)","comments: ": "Compute a histogram of the counts of non-null values.\n\nParameters ---------- values : ndarray (1-d) sort : bool, default True Sort by values ascending : bool, default False Sort in ascending order normalize: bool, default False If True then compute a relative histogram bins : integer, optional Rather than count values, group them into half-open bins, convenience for pd.cut, only works with numeric data dropna : bool, default True Don't include counts of NaN\n##### Returns\n"},"func13": {"source file: ": "algorithms1.py","line number: ": "736","func name: ": "_value_counts_arraylike","func arg: ": "(values, dropna)","comments: ": "Parameters ---------- values : arraylike dropna : bool\n\n\n##### Returns\n* **uniques **: np.ndarray or ExtensionArray\n\n* **counts **: np.ndarray\n\n"},"func14": {"source file: ": "algorithms1.py","line number: ": "780","func name: ": "duplicated","func arg: ": "(values, keep)","comments: ": "Return boolean ndarray denoting duplicate values.\n\nParameters ---------- values : ndarray-like Array over which to check for duplicate values. keep : {'first', 'last', False}, default 'first'\n\n- ``first`` : Mark duplicates as ``True`` except for the first occurrence.\n\n- ``last`` : Mark duplicates as ``True`` except for the last occurrence.\n\n- False : Mark all duplicates as ``True``.\n##### Returns\n* **duplicated **: ndarray\n\n"},"func15": {"source file: ": "algorithms1.py","line number: ": "806","func name: ": "mode","func arg: ": "(values, dropna)","comments: ": "Returns the mode(s) of an array.\n\nParameters ---------- values : array-like Array over which to check for duplicate values. dropna : boolean, default True Don't consider counts of NaN/NaT.\n\n.. versionadded:: 0.24.0\n##### Returns\n* **mode **: Series\n\n"},"func16": {"source file: ": "algorithms1.py","line number: ": "852","func name: ": "rank","func arg: ": "(values, axis, method, na_option, ascending, pct)","comments: ": "Rank the values along a given axis.\n\nParameters ---------- values : array-like Array whose values will be ranked. The number of dimensions in this array must not exceed 2. axis : int, default 0 Axis over which to perform rankings. method : {'average', 'min', 'max', 'first', 'dense'}, default 'average' The method by which tiebreaks are broken during the ranking. na_option : {'keep', 'top'}, default 'keep' The method by which NaNs are placed in the ranking.\n\n- ``keep``: rank each NaN value with a NaN ranking\n\n- ``top``: replace each NaN with either +/- inf so that they there are ranked at the top ascending : boolean, default True Whether or not the elements should be ranked in ascending order. pct : boolean, default False Whether or not to the display the returned rankings in integer form (e.g. 1, 2, 3) or in percentile form (e.g. 0.333..., 0.666..., 1).\n"},"func17": {"source file: ": "algorithms1.py","line number: ": "908","func name: ": "checked_add_with_arr","func arg: ": "(arr, b, arr_mask, b_mask)","comments: ": "Perform array addition that checks for underflow and overflow.\n\nPerforms the addition of an int64 array and an int64 integer (or array) but checks that they do not result in overflow first. For elements that are indicated to be NaN, whether or not there is overflow for that element is automatically ignored.\n\nParameters ---------- arr : array addend. b : array or scalar addend. arr_mask : boolean array or None array indicating which elements to exclude from checking b_mask : boolean array or boolean or None array or scalar indicating which element(s) to exclude from checking\n##### Returns\n* **sum **: An array for elements x + b for each element x in arr if b is\n  a scalar or an array for elements x + y for each element pair\n  (x, y) in (arr, b).\n\n"},"func18": {"source file: ": "algorithms1.py","line number: ": "984","func name: ": "quantile","func arg: ": "(x, q, interpolation_method)","comments: ": "Compute sample quantile or quantiles of the input array. For example, q=0.5 computes the median.\n\nThe `interpolation_method` parameter supports three values, namely `fraction` (default), `lower` and `higher`. Interpolation is done only, if the desired quantile lies between two data points `i` and `j`. For `fraction`, the result is an interpolated value between `i` and `j`; for `lower`, the result is `i`, for `higher` the result is `j`.\n\nParameters ---------- x : ndarray Values from which to extract score. q : scalar or array Percentile at which to extract score. interpolation_method : {'fraction', 'lower', 'higher'}, optional This optional parameter specifies the interpolation method to use, when the desired quantile lies between two data points `i` and `j`:\n\n- fraction: `i + (j\n\n- i)*fraction`, where `fraction` is the fractional part of the index surrounded by `i` and `j`. -lower: `i`.\n\n- higher: `j`.\n##### Returns\n* **score **: float\nScore at percentile.\n\n"},"func19": {"source file: ": "algorithms1.py","line number: ": "1275","func name: ": "_view_wrapper","func arg: ": "(f, arr_dtype, out_dtype, fill_wrap)","comments: ": ""},"func20": {"source file: ": "algorithms1.py","line number: ": "1288","func name: ": "_convert_wrapper","func arg: ": "(f, conv_dtype)","comments: ": ""},"func21": {"source file: ": "algorithms1.py","line number: ": "1296","func name: ": "_take_2d_multi_object","func arg: ": "(arr, indexer, out, fill_value, mask_info)","comments: ": ""},"func22": {"source file: ": "algorithms1.py","line number: ": "1319","func name: ": "_take_nd_object","func arg: ": "(arr, indexer, out, axis, fill_value, mask_info)","comments: ": ""},"func23": {"source file: ": "algorithms1.py","line number: ": "1436","func name: ": "_get_take_nd_function","func arg: ": "(ndim, arr_dtype, out_dtype, axis, mask_info)","comments: ": ""},"func24": {"source file: ": "algorithms1.py","line number: ": "1472","func name: ": "take","func arg: ": "(arr, indices, axis, allow_fill, fill_value)","comments: ": "Take elements from an array.\n\n.. versionadded:: 0.23.0\n\nParameters ---------- arr : sequence Non array-likes (sequences without a dtype) are coerced to an ndarray. indices : sequence of integers Indices to be taken. axis : int, default 0 The axis over which to select values. allow_fill : bool, default False How to handle negative values in `indices`.\n\n* False: negative values in `indices` indicate positional indices from the right (the default). This is similar to :func:`numpy.take`.\n\n* True: negative values in `indices` indicate missing values. These values are set to `fill_value`. Any other other negative values raise a ``ValueError``.\n\nfill_value : any, optional Fill value to use for NA-indices when `allow_fill` is True. This may be ``None``, in which case the default NA value for the type (``self.dtype.na_value``) is used.\n\nFor multi-dimensional `arr`, each *element* is filled with `fill_value`.\n##### Returns\n"},"func25": {"source file: ": "algorithms1.py","line number: ": "1565","func name: ": "take_nd","func arg: ": "(arr, indexer, axis, out, fill_value, allow_fill)","comments: ": "Specialized Cython take which sets NaN values in one pass\n\nThis dispatches to ``take`` defined on ExtensionArrays. It does not currently dispatch to ``SparseArray.take`` for sparse ``arr``.\n\nParameters ---------- arr : array-like Input array. indexer : ndarray 1-D array of indices to take, subarrays corresponding to -1 value indices are filed with fill_value axis : int, default 0 Axis to take from out : ndarray or None, default None Optional output array, must be appropriate type to hold input and fill_value together, if indexer has any -1 value entries; call maybe_promote to determine this type for any fill_value fill_value : any, default np.nan Fill value to replace -1 values with allow_fill : boolean, default True If False, indexer is assumed to contain no -1 values so no filling will be done.\n\nThis short-circuits computation of a mask.\n\nResult is undefined if allow_fill == False and -1 is present in indexer.\n##### Returns\n* **subarray **: array-like\nMay be the same type as the input, or cast to an ndarray.\n\n"},"func26": {"source file: ": "algorithms1.py","line number: ": "1672","func name: ": "take_2d_multi","func arg: ": "(arr, indexer, fill_value)","comments: ": "Specialized Cython take which sets NaN values in one pass.\n\n\n"},"func27": {"source file: ": "algorithms1.py","line number: ": "1732","func name: ": "searchsorted","func arg: ": "(arr, value, side, sorter)","comments: ": "Find indices where elements should be inserted to maintain order.\n\n.. versionadded:: 0.25.0\n\nFind the indices into a sorted array `arr` (a) such that, if the corresponding elements in `value` were inserted before the indices, the order of `arr` would be preserved.\n\nAssuming that `arr` is sorted:\n\n======\n\n================================ `side`\n\nreturned index `i` satisfies ======\n\n================================ left\n\n\n\n``arr[i-1] < value <= self[i]`` right\n\n ``arr[i-1] <= value < self[i]`` ======\n\n================================\n\nParameters ---------- arr: array-like Input array. If `sorter` is None, then it must be sorted in ascending order, otherwise `sorter` must be an array of indices that sort it. value : array_like Values to insert into `arr`. side : {'left', 'right'}, optional If 'left', the index of the first suitable location found is given. If 'right', return the last such index.\n\nIf there is no suitable index, return either 0 or N (where N is the length of `self`). sorter : 1-D array_like, optional Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.\n##### Returns\n* **numpy.searchsorted **: Similar method from NumPy.\n\n"},"func28": {"source file: ": "algorithms1.py","line number: ": "1822","func name: ": "diff","func arg: ": "(arr, n, axis, stacklevel)","comments: ": "difference of n between self, analogous to s-s.shift(n)\n\nParameters ---------- arr : ndarray n : int number of periods axis : int axis to shift on stacklevel : int The stacklevel for the lost dtype warning.\n##### Returns\n"},"func29": {"source file: ": "algorithms1.py","line number: ": "1940","func name: ": "safe_sort","func arg: ": "(values, codes, na_sentinel, assume_unique, verify)","comments: ": "Sort ``values`` and reorder corresponding ``codes``.\n\n``values`` should be unique if ``codes`` is not None. Safe for use with mixed types (int, str), orders ints before strs.\n\nParameters ---------- values : list-like Sequence; must be unique if ``codes`` is not None. codes : list_like, optional Indices to ``values``. All out of bound indices are treated as \"not found\" and will be masked with ``na_sentinel``. na_sentinel : int, default -1 Value in ``codes`` to mark \"not found\". Ignored when ``codes`` is None. assume_unique : bool, default False When True, ``values`` are assumed to be unique, which can speed up the calculation. Ignored when ``codes`` is None. verify : bool, default True Check if codes are out of bound for the values and put out of bound codes equal to na_sentinel. If ``verify=False``, it is assumed there are no out of bound codes. Ignored when ``codes`` is None.\n\n.. versionadded:: 0.25.0\n##### Returns\n* **ordered **: ndarray\nSorted ``values``\n\n* **new_codes **: ndarray\nReordered ``codes``; returned when ``codes`` is not None.\n\n"}}{"func1": {"source file: ": "align1.py","line number: ": "20","func name: ": "_align_core_single_unary_op","func arg: ": "(term)","comments: ": ""},"func2": {"source file: ": "align1.py","line number: ": "37","func name: ": "_zip_axes_from_type","func arg: ": "(typ, new_axes)","comments: ": ""},"func3": {"source file: ": "align1.py","line number: ": "44","func name: ": "_any_pandas_objects","func arg: ": "(terms)","comments: ": "Check a sequence of terms for instances of PandasObject.\n\n\n"},"func4": {"source file: ": "align1.py","line number: ": "51","func name: ": "_filter_special_cases","func arg: ": "(f)","comments: ": ""},"func5": {"source file: ": "align1.py","line number: ": "70","func name: ": "_align_core","func arg: ": "(terms)","comments: ": ""},"func6": {"source file: ": "align1.py","line number: ": "127","func name: ": "align_terms","func arg: ": "(terms)","comments: ": "Align a set of terms.\n\n\n"},"func7": {"source file: ": "align1.py","line number: ": "150","func name: ": "reconstruct_object","func arg: ": "(typ, obj, axes, dtype)","comments: ": "Reconstruct an object given its type, raw value, and possibly empty (None) axes.\n\nParameters ---------- typ : object A type obj : object The value to use in the type constructor axes : dict The axes to use to construct the resulting pandas object\n##### Returns\n* **ret **: typ\nAn object of type ``typ`` with the value `obj` and possible axes\n`axes`.\n\n"}}{"func1": {"source file: ": "api1.py","line number: ": "65","func name: ": "get_objs_combined_axis","func arg: ": "(objs, intersect, axis, sort)","comments: ": "Extract combined index: return intersection or union (depending on the value of \"intersect\") of indexes on given axis, or None if all objects lack indexes (e.g. they are numpy arrays).\n\nParameters ---------- objs : list Series or DataFrame objects, may be mix of the two. intersect : bool, default False If True, calculate the intersection between indexes. Otherwise, calculate the union. axis : {0 or 'index', 1 or 'outer'}, default 0 The axis to extract indexes from. sort : bool, default True Whether the result index should come out sorted or not.\n##### Returns\n"},"func2": {"source file: ": "api1.py","line number: ": "93","func name: ": "_get_distinct_objs","func arg: ": "(objs)","comments: ": "Return a list with distinct elements of \"objs\" (different ids). Preserves order.\n\n\n"},"func3": {"source file: ": "api1.py","line number: ": "107","func name: ": "_get_combined_index","func arg: ": "(indexes, intersect, sort)","comments: ": "Return the union or intersection of indexes.\n\nParameters ---------- indexes : list of Index or list objects When intersect=True, do not accept list of lists. intersect : bool, default False If True, calculate the intersection between indexes. Otherwise, calculate the union. sort : bool, default False Whether the result index should come out sorted or not.\n##### Returns\n"},"func4": {"source file: ": "api1.py","line number: ": "149","func name: ": "union_indexes","func arg: ": "(indexes, sort)","comments: ": "Return the union of indexes.\n\nThe behavior of sort and names is not consistent.\n\nParameters ---------- indexes : list of Index or list objects sort : bool, default True Whether the result index should come out sorted or not.\n##### Returns\n"},"func5": {"source file: ": "api1.py","line number: ": "221","func name: ": "_sanitize_and_check","func arg: ": "(indexes)","comments: ": "Verify the type of indexes and convert lists to Index.\n\nCases:\n\n- [list, list, ...]: Return ([list, list, ...], 'list')\n\n- [list, Index, ...]: Return _sanitize_and_check([Index, Index, ...]) Lists are sorted and converted to Index.\n\n- [Index, Index, ...]: Return ([Index, Index, ...], TYPE) TYPE = 'special' if at least one special type, 'array' otherwise.\n\nParameters ---------- indexes : list of Index or list objects\n##### Returns\n* **sanitized_indexes **: list of Index or list objects\n\n* **type **: {'list', 'array', 'special'}\n\n"},"func6": {"source file: ": "api1.py","line number: ": "260","func name: ": "get_consensus_names","func arg: ": "(indexes)","comments: ": "Give a consensus 'names' to indexes.\n\nIf there's exactly one non-empty 'names', return this, otherwise, return empty.\n\nParameters ---------- indexes : list of Index objects\n##### Returns\n"},"func7": {"source file: ": "api1.py","line number: ": "284","func name: ": "all_indexes_same","func arg: ": "(indexes)","comments: ": "Determine if all indexes contain the same elements.\n\nParameters ---------- indexes : list of Index objects\n##### Returns\n"}}{"func1": {"source file: ": "apply1.py","line number: ": "26","func name: ": "frame_apply","func arg: ": "(obj, func, axis, raw, result_type, ignore_failures, args, kwds)","comments: ": "construct and return a row or column based frame apply object\n\n\n"}}{"func1": {"source file: ": "array_ops1.py","line number: ": "42","func name: ": "comp_method_OBJECT_ARRAY","func arg: ": "(op, x, y)","comments: ": ""},"func2": {"source file: ": "array_ops1.py","line number: ": "61","func name: ": "masked_arith_op","func arg: ": "(x, y, op)","comments: ": "If the given arithmetic operation fails, attempt it again on only the non-null elements of the input array(s).\n\nParameters ---------- x : np.ndarray y : np.ndarray, Series, Index op : binary operator\n"},"func3": {"source file: ": "array_ops1.py","line number: ": "119","func name: ": "define_na_arithmetic_op","func arg: ": "(op, str_rep)","comments: ": ""},"func4": {"source file: ": "array_ops1.py","line number: ": "126","func name: ": "na_arithmetic_op","func arg: ": "(left, right, op, str_rep)","comments: ": "Return the result of evaluating op on the passed in values.\n\nIf native types are not compatible, try coersion to object dtype.\n\nParameters ---------- left : np.ndarray right : np.ndarray or scalar str_rep : str or None\n##### Returns\n"},"func5": {"source file: ": "array_ops1.py","line number: ": "156","func name: ": "arithmetic_op","func arg: ": "(left, right, op, str_rep)","comments: ": "Evaluate an arithmetic operation `+`, `-`, `*`, `/`, `//`, `%`, `**`, ...\n\nParameters ---------- left : np.ndarray or ExtensionArray right : object Cannot be a DataFrame or Index.\n\nSeries is *not* excluded. op : {operator.add, operator.sub, ...} Or one of the reversed variants from roperator. str_rep : str\n##### Returns\n"},"func6": {"source file: ": "array_ops1.py","line number: ": "202","func name: ": "comparison_op","func arg: ": "(left, right, op)","comments: ": "Evaluate a comparison operation `=`, `!=`, `>=`, `>`, `<=`, or `<`.\n\nParameters ---------- left : np.ndarray or ExtensionArray right : object Cannot be a DataFrame, Series, or Index. op : {operator.eq, operator.ne, operator.gt, operator.ge, operator.lt, operator.le}\n##### Returns\n"},"func7": {"source file: ": "array_ops1.py","line number: ": "264","func name: ": "na_logical_op","func arg: ": "(x, y, op)","comments: ": ""},"func8": {"source file: ": "array_ops1.py","line number: ": "305","func name: ": "logical_op","func arg: ": "(left, right, op)","comments: ": "Evaluate a logical operation `|`, `&`, or `^`.\n\nParameters ---------- left : np.ndarray or ExtensionArray right : object Cannot be a DataFrame, Series, or Index. op : {operator.and_, operator.or_, operator.xor} Or one of the reversed variants from roperator.\n##### Returns\n"},"func9": {"source file: ": "array_ops1.py","line number: ": "372","func name: ": "get_array_op","func arg: ": "(op, str_rep)","comments: ": "Return a binary array operation corresponding to the given operator op.\n\nParameters ---------- op : function Binary operator from operator or roperator module. str_rep : str or None, default None str_rep to pass to arithmetic_op\n##### Returns\n"}}{"func1": {"source file: ": "array1.py","line number: ": "197","func name: ": "make_data","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "array2.py","line number: ": "197","func name: ": "to_decimal","func arg: ": "(values, context)","comments: ": ""},"func2": {"source file: ": "array2.py","line number: ": "201","func name: ": "make_data","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "array3.py","line number: ": "60","func name: ": "_get_fill","func arg: ": "(arr)","comments: ": "Create a 0-dim ndarray containing the fill value\n\nParameters ---------- arr : SparseArray\n##### Returns\n* **fill_value **: ndarray\n0-dim ndarray with just the fill value.\n\n"},"func2": {"source file: ": "array3.py","line number: ": "84","func name: ": "_sparse_array_op","func arg: ": "(left, right, op, name)","comments: ": "Perform a binary operation between two arrays.\n\nParameters ---------- left : Union[SparseArray, ndarray] right : Union[SparseArray, ndarray] op : Callable The binary operation to perform name str Name of the callable.\n##### Returns\n"},"func3": {"source file: ": "array3.py","line number: ": "174","func name: ": "_wrap_result","func arg: ": "(name, data, sparse_index, fill_value, dtype)","comments: ": "wrap op result to have correct dtype\n\n\n"},"func4": {"source file: ": "array3.py","line number: ": "1488","func name: ": "make_sparse","func arg: ": "(arr, kind, fill_value, dtype, copy)","comments: ": "Convert ndarray to sparse format\n\nParameters ---------- arr : ndarray kind : {'block', 'integer'} fill_value : NaN or another value dtype : np.dtype, optional copy : bool, default False\n##### Returns\n* **(sparse_values, index, fill_value) **: (ndarray, SparseIndex, Scalar)\n\n"},"func5": {"source file: ": "array3.py","line number: ": "1543","func name: ": "_make_index","func arg: ": "(length, indices, kind)","comments: ": ""}}{"func1": {"source file: ": "array4.py","line number: ": "126","func name: ": "make_data","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "base1.py","line number: ": "101","func name: ": "_make_comparison_op","func arg: ": "(op, cls)","comments: ": ""},"func2": {"source file: ": "base1.py","line number: ": "132","func name: ": "_make_arithmetic_op","func arg: ": "(op, cls)","comments: ": ""},"func3": {"source file: ": "base1.py","line number: ": "157","func name: ": "_new_Index","func arg: ": "(cls, d)","comments: ": "This is called upon unpickling, rather than the default which doesn't have arguments and breaks __new__.\n\n\n"},"func4": {"source file: ": "base1.py","line number: ": "5253","func name: ": "ensure_index_from_sequences","func arg: ": "(sequences, names)","comments: ": "Construct an index from sequences of data.\n\nA single sequence returns an Index. Many sequences returns a MultiIndex.\n\nParameters ---------- sequences : sequence of sequences names : sequence of str\n##### Returns\n* **index **: Index or MultiIndex\n\n"},"func5": {"source file: ": "base1.py","line number: ": "5294","func name: ": "ensure_index","func arg: ": "(index_like, copy)","comments: ": "Ensure that we have an index from some index-like object.\n\nParameters ---------- index : sequence An Index or other sequence copy : bool\n##### Returns\n* **index **: Index or MultiIndex\n\n"},"func6": {"source file: ": "base1.py","line number: ": "5361","func name: ": "_ensure_has_len","func arg: ": "(seq)","comments: ": "If seq is an iterator, put its values into a list.\n\n\n"},"func7": {"source file: ": "base1.py","line number: ": "5373","func name: ": "_trim_front","func arg: ": "(strings)","comments: ": "Trims zeros and decimal points.\n\n\n"},"func8": {"source file: ": "base1.py","line number: ": "5383","func name: ": "_validate_join_method","func arg: ": "(method)","comments: ": ""},"func9": {"source file: ": "base1.py","line number: ": "5388","func name: ": "default_index","func arg: ": "(n)","comments: ": ""},"func10": {"source file: ": "base1.py","line number: ": "5394","func name: ": "maybe_extract_name","func arg: ": "(name, obj, cls)","comments: ": "If no name is passed, then extract it from data, validating hashability.\n\n\n"},"func11": {"source file: ": "base1.py","line number: ": "5410","func name: ": "_maybe_cast_with_dtype","func arg: ": "(data, dtype, copy)","comments: ": "If a dtype is passed, cast to the closest matching dtype that is supported by Index.\n\nParameters ---------- data : np.ndarray dtype : np.dtype copy : bool\n##### Returns\n"},"func12": {"source file: ": "base1.py","line number: ": "5464","func name: ": "_maybe_cast_data_without_dtype","func arg: ": "(subarr)","comments: ": "If we have an arraylike input but no passed dtype, try to infer a supported dtype.\n\nParameters ---------- subarr : np.ndarray, Index, or Series\n##### Returns\n* **converted **: np.ndarray or ExtensionArray\n\n* **dtype **: np.dtype or ExtensionDtype\n\n"},"func13": {"source file: ": "base1.py","line number: ": "5535","func name: ": "_try_convert_to_int_array","func arg: ": "(data, copy, dtype)","comments: ": "Attempt to convert an array of data into an integer array.\n\nParameters ---------- data : The data to convert. copy : bool Whether to copy the data or not. dtype : np.dtype\n##### Returns\n* **int_array **: data converted to either an ndarray[int64] or ndarray[uint64]\n\n"}}{}{"func1": {"source file: ": "base3.py","line number: ": "34","func name: ": "try_cast_to_ea","func arg: ": "(cls_or_instance, obj, dtype)","comments: ": "Call to `_from_sequence` that returns the object unchanged on Exception.\n\nParameters ---------- cls_or_instance : ExtensionArray subclass or instance obj : arraylike Values to pass to cls._from_sequence dtype : ExtensionDtype, optional\n##### Returns\n"}}{}{}{"func1": {"source file: ": "blocks1.py","line number: ": "2987","func name: ": "get_block_type","func arg: ": "(values, dtype)","comments: ": "Find the appropriate Block subclass to use for the given values and dtype.\n\nParameters ---------- values : ndarray-like dtype : numpy or pandas dtype\n##### Returns\n* **cls **: class, subclass of Block\n\n"},"func2": {"source file: ": "blocks1.py","line number: ": "3033","func name: ": "make_block","func arg: ": "(values, placement, klass, ndim, dtype)","comments: ": ""},"func3": {"source file: ": "blocks1.py","line number: ": "3059","func name: ": "_extend_blocks","func arg: ": "(result, blocks)","comments: ": "return a new extended blocks, given the result\n\n\n"},"func4": {"source file: ": "blocks1.py","line number: ": "3078","func name: ": "_block_shape","func arg: ": "(values, ndim, shape)","comments: ": "guarantee the shape of the values to be at least 1 d\n\n\n"},"func5": {"source file: ": "blocks1.py","line number: ": "3091","func name: ": "_merge_blocks","func arg: ": "(blocks, dtype, _can_consolidate)","comments: ": ""},"func6": {"source file: ": "blocks1.py","line number: ": "3117","func name: ": "_safe_reshape","func arg: ": "(arr, new_shape)","comments: ": "If possible, reshape `arr` to have shape `new_shape`, with a couple of exceptions (see gh-13012)\n\n1) If `arr` is a ExtensionArray or Index, `arr` will be returned as is. 2) If `arr` is a Series, the `_values` attribute will be reshaped and returned.\n\nParameters ---------- arr : array-like, object to be reshaped new_shape : int or tuple of ints, the new shape\n"},"func7": {"source file: ": "blocks1.py","line number: ": "3139","func name: ": "_putmask_smart","func arg: ": "(v, mask, n)","comments: ": "Return a new ndarray, try to preserve dtype if possible.\n\nParameters ---------- v : `values`, updated in-place (array like) mask : np.ndarray Applies to both sides (array like). n : `new values` either scalar or an array like aligned with `values`\n##### Returns\n* **values **: ndarray with updated values\nthis *may* be a copy of the original\n\n"}}{"func1": {"source file: ": "boolean1.py","line number: ": "114","func name: ": "coerce_to_array","func arg: ": "(values, mask, copy)","comments: ": "Coerce the input values array to numpy arrays with a mask.\n\nParameters ---------- values : 1D list-like mask : bool 1D array, optional copy : bool, default False if True, copy the input\n##### Returns\n"}}{"func1": {"source file: ": "boxplot1.py","line number: ": "175","func name: ": "_grouped_plot_by_column","func arg: ": "(plotf, data, columns, by, numeric_only, grid, figsize, ax, layout, return_type, **kwargs)","comments: ": ""},"func2": {"source file: ": "boxplot1.py","line number: ": "225","func name: ": "boxplot","func arg: ": "(data, column, by, ax, fontsize, rot, grid, figsize, layout, return_type, **kwds)","comments: ": ""},"func3": {"source file: ": "boxplot1.py","line number: ": "349","func name: ": "boxplot_frame","func arg: ": "(column, by, ax, fontsize, rot, grid, figsize, layout, return_type, **kwds)","comments: ": ""},"func4": {"source file: ": "boxplot1.py","line number: ": "381","func name: ": "boxplot_frame_groupby","func arg: ": "(grouped, subplots, column, fontsize, rot, grid, ax, figsize, layout, sharex, sharey, **kwds)","comments: ": ""}}{"func1": {"source file: ": "cast1.py","line number: ": "70","func name: ": "maybe_convert_platform","func arg: ": "(values)","comments: ": "try to do platform conversion, allow ndarray or list here\n\n\n"},"func2": {"source file: ": "cast1.py","line number: ": "83","func name: ": "is_nested_object","func arg: ": "(obj)","comments: ": "return a boolean if we have a nested object, e.g. a Series with 1 or more Series elements\n\nThis may not be necessarily be performant.\n"},"func3": {"source file: ": "cast1.py","line number: ": "100","func name: ": "maybe_downcast_to_dtype","func arg: ": "(result, dtype)","comments: ": "try to cast to the specified dtype (e.g. convert back to bool/int or could be an astype of float64->float32\n\n\n"},"func4": {"source file: ": "cast1.py","line number: ": "167","func name: ": "maybe_downcast_numeric","func arg: ": "(result, dtype, do_round)","comments: ": "Subset of maybe_downcast_to_dtype restricted to numeric dtypes.\n\nParameters ---------- result : ndarray or ExtensionArray dtype : np.dtype or ExtensionDtype do_round : bool\n##### Returns\n"},"func5": {"source file: ": "cast1.py","line number: ": "241","func name: ": "maybe_upcast_putmask","func arg: ": "(result, mask, other)","comments: ": "A safe version of putmask that potentially upcasts the result. The result is replaced with the first N elements of other, where N is the number of True values in mask. If the length of other is shorter than N, other will be repeated.\n\nParameters ---------- result : ndarray The destination array. This will be mutated in-place if no upcasting is necessary. mask : boolean ndarray other : scalar The source value.\n##### Returns\n* **result **: ndarray\n\n* **changed **: bool\nSet to true if the result array was upcasted.\n\n"},"func6": {"source file: ": "cast1.py","line number: ": "347","func name: ": "maybe_promote","func arg: ": "(dtype, fill_value)","comments: ": "Find the minimal dtype that can hold both the given dtype and fill_value.\n\nParameters ---------- dtype : np.dtype or ExtensionDtype fill_value : scalar, default np.nan\n##### Returns\n"},"func7": {"source file: ": "cast1.py","line number: ": "503","func name: ": "_ensure_dtype_type","func arg: ": "(value, dtype)","comments: ": "Ensure that the given value is an instance of the given dtype.\n\ne.g. if out dtype is np.complex64, we should have an instance of that as opposed to a python complex object.\n\nParameters ---------- value : object dtype : np.dtype or ExtensionDtype\n##### Returns\n"},"func8": {"source file: ": "cast1.py","line number: ": "532","func name: ": "infer_dtype_from","func arg: ": "(val, pandas_dtype)","comments: ": "Interpret the dtype from a scalar or array.\n\nParameters ---------- val : object pandas_dtype : bool, default False whether to infer dtype including pandas extension types. If False, scalar/array belongs to pandas extension types is inferred as object\n"},"func9": {"source file: ": "cast1.py","line number: ": "549","func name: ": "infer_dtype_from_scalar","func arg: ": "(val, pandas_dtype)","comments: ": "Interpret the dtype from a scalar.\n\nParameters ---------- pandas_dtype : bool, default False whether to infer dtype including pandas extension types. If False, scalar belongs to pandas extension types is inferred as object\n"},"func10": {"source file: ": "cast1.py","line number: ": "627","func name: ": "infer_dtype_from_array","func arg: ": "(arr, pandas_dtype)","comments: ": "Infer the dtype from an array.\n\nParameters ---------- arr : array pandas_dtype : bool, default False whether to infer dtype including pandas extension types. If False, array belongs to pandas extension types is inferred as object\n##### Returns\n"},"func11": {"source file: ": "cast1.py","line number: ": "682","func name: ": "maybe_infer_dtype_type","func arg: ": "(element)","comments: ": "Try to infer an object's dtype, for use in arithmetic ops.\n\nUses `element.dtype` if that's available. Objects implementing the iterator protocol are cast to a NumPy array, and from there the array's type is used.\n\nParameters ---------- element : object Possibly has a `.dtype` attribute, and possibly the iterator protocol.\n##### Returns\n* **tipo **: type\n\n"},"func12": {"source file: ": "cast1.py","line number: ": "716","func name: ": "maybe_upcast","func arg: ": "(values, fill_value, dtype, copy)","comments: ": "Provide explicit type promotion and coercion.\n\nParameters ---------- values : ndarray or ExtensionArray The array that we want to maybe upcast. fill_value : what we want to fill with dtype : if None, then use the dtype of the values, else coerce to this type copy : bool, default True If True always make a copy even if no upcast is required.\n"},"func13": {"source file: ": "cast1.py","line number: ": "748","func name: ": "invalidate_string_dtypes","func arg: ": "(dtype_set)","comments: ": "Change string like dtypes to object for ``DataFrame.select_dtypes()``.\n\n\n"},"func14": {"source file: ": "cast1.py","line number: ": "757","func name: ": "coerce_indexer_dtype","func arg: ": "(indexer, categories)","comments: ": "coerce the indexer input array to the smallest dtype possible\n\n\n"},"func15": {"source file: ": "cast1.py","line number: ": "769","func name: ": "coerce_to_dtypes","func arg: ": "(result, dtypes)","comments: ": "given a dtypes and a result set, coerce the result elements to the dtypes\n\n\n"},"func16": {"source file: ": "cast1.py","line number: ": "799","func name: ": "astype_nansafe","func arg: ": "(arr, dtype, copy, skipna)","comments: ": "Cast the elements of an array to a given dtype a nan-safe manner.\n\nParameters ---------- arr : ndarray dtype : np.dtype copy : bool, default True If False, a view will be attempted but may fail, if e.g. the item sizes don't align. skipna: bool, default False Whether or not we should skip NaN when casting as a string-type.\n"},"func17": {"source file: ": "cast1.py","line number: ": "902","func name: ": "maybe_convert_objects","func arg: ": "(values, convert_numeric)","comments: ": "If we have an object dtype array, try to coerce dates and/or numbers.\n\nParameters ---------- values : ndarray convert_numeric : bool, default True\n##### Returns\n"},"func18": {"source file: ": "cast1.py","line number: ": "951","func name: ": "soft_convert_objects","func arg: ": "(values, datetime, numeric, timedelta, coerce, copy)","comments: ": "if we have an object dtype, try to coerce dates and/or numbers\n\n\n"},"func19": {"source file: ": "cast1.py","line number: ": "1023","func name: ": "convert_dtypes","func arg: ": "(input_array, convert_string, convert_integer, convert_boolean)","comments: ": "Convert objects to best possible type, and optionally, to types supporting ``pd.NA``.\n\nParameters ---------- input_array : ExtensionArray or PandasArray convert_string : bool, default True Whether object dtypes should be converted to ``StringDtype()``. convert_integer : bool, default True Whether, if possible, conversion can be done to integer extension types. convert_boolean : bool, defaults True Whether object dtypes should be converted to ``BooleanDtypes()``.\n##### Returns\n"},"func20": {"source file: ": "cast1.py","line number: ": "1088","func name: ": "maybe_castable","func arg: ": "(arr)","comments: ": ""},"func21": {"source file: ": "cast1.py","line number: ": "1102","func name: ": "maybe_infer_to_datetimelike","func arg: ": "(value, convert_dates)","comments: ": "we might have a array (or single object) that is datetime like, and no dtype is passed don't change the value unless we find a datetime/timedelta set\n\nthis is pretty strict in that a datetime/timedelta is REQUIRED in addition to possible nulls/string likes\n\nParameters ---------- value : np.array / Series / Index / list-like convert_dates : bool, default False if True try really hard to convert dates (such as datetime.date), other leave inferred dtype 'date' alone\n"},"func22": {"source file: ": "cast1.py","line number: ": "1209","func name: ": "maybe_cast_to_datetime","func arg: ": "(value, dtype, errors)","comments: ": "try to cast the array/value to a datetimelike dtype, converting float nan to iNaT\n\n\n"},"func23": {"source file: ": "cast1.py","line number: ": "1342","func name: ": "find_common_type","func arg: ": "(types)","comments: ": "Find a common data type among the given dtypes.\n\nParameters ---------- types : list of dtypes\n##### Returns\n"},"func24": {"source file: ": "cast1.py","line number: ": "1390","func name: ": "cast_scalar_to_array","func arg: ": "(shape, value, dtype)","comments: ": "Create np.ndarray of specified shape and dtype, filled with values.\n\nParameters ---------- shape : tuple value : scalar value dtype : np.dtype, optional dtype to coerce\n##### Returns\n"},"func25": {"source file: ": "cast1.py","line number: ": "1418","func name: ": "construct_1d_arraylike_from_scalar","func arg: ": "(value, length, dtype)","comments: ": "create a np.ndarray / pandas type of specified shape and dtype filled with values\n\nParameters ---------- value : scalar value length : int dtype : pandas_dtype / np.dtype\n##### Returns\n"},"func26": {"source file: ": "cast1.py","line number: ": "1458","func name: ": "construct_1d_object_array_from_listlike","func arg: ": "(values)","comments: ": "Transform any list-like object in a 1-dimensional numpy array of object dtype.\n\nParameters ---------- values : any iterable which has a len()\n##### Returns\n"},"func27": {"source file: ": "cast1.py","line number: ": "1483","func name: ": "construct_1d_ndarray_preserving_na","func arg: ": "(values, dtype, copy)","comments: ": "Construct a new ndarray, coercing `values` to `dtype`, preserving NA.\n\nParameters ---------- values : Sequence dtype : numpy.dtype, optional copy : bool, default False Note that copies may still be made with ``copy=False`` if casting is required.\n##### Returns\n* **arr **: ndarray[dtype]\n\n"},"func28": {"source file: ": "cast1.py","line number: ": "1524","func name: ": "maybe_cast_to_integer_array","func arg: ": "(arr, dtype, copy)","comments: ": "Takes any dtype and returns the casted version, raising for when data is incompatible with integer/unsigned integer dtypes.\n\n.. versionadded:: 0.24.0\n\nParameters ---------- arr : array-like The array to cast. dtype : str, np.dtype The integer dtype to cast the array to. copy: bool, default False Whether to make a copy of the array before returning.\n##### Returns\n* **int_arr **: ndarray\nAn array of integer or unsigned integer dtype\n\n"}}{}{"func1": {"source file: ": "categorical1.py","line number: ": "11","func name: ": "recode_for_groupby","func arg: ": "(c, sort, observed)","comments: ": "Code the categories to ensure we can groupby for categoricals.\n\nIf observed=True, we return a new Categorical with the observed categories only.\n\nIf sort=False, return a copy of self, coded with categories as returned by .unique(), followed by any categories not appearing in the data. If sort=True, return self.\n\nThis method is needed solely to ensure the categorical index of the GroupBy result has categories in the order of appearance in the data (GH-8868).\n\nParameters ---------- c : Categorical sort : boolean The value of the sort parameter groupby was called with. observed : boolean Account only for the observed values\n##### Returns\n"},"func2": {"source file: ": "categorical1.py","line number: ": "77","func name: ": "recode_from_groupby","func arg: ": "(c, sort, ci)","comments: ": "Reverse the codes_to_groupby to account for sort / observed.\n\nParameters ---------- c : Categorical sort : boolean The value of the sort parameter groupby was called with. ci : CategoricalIndex The codes / categories to recode\n##### Returns\n"}}{"func1": {"source file: ": "categorical2.py","line number: ": "65","func name: ": "_cat_compare_op","func arg: ": "(op)","comments: ": ""},"func2": {"source file: ": "categorical2.py","line number: ": "147","func name: ": "contains","func arg: ": "(cat, key, container)","comments: ": "Helper for membership check for ``key`` in ``cat``.\n\nThis is a helper method for :method:`__contains__` and :class:`CategoricalIndex.__contains__`.\n##### Returns\n* **is_in **: bool\nTrue if ``key`` is in ``self.categories`` and location of\n``key`` in ``categories`` is in ``container``, else False.\n\n"},"func3": {"source file: ": "categorical2.py","line number: ": "2572","func name: ": "_get_codes_for_values","func arg: ": "(values, categories)","comments: ": "utility routine to turn values into codes given the specified categories\n\n\n"},"func4": {"source file: ": "categorical2.py","line number: ": "2604","func name: ": "_recode_for_categories","func arg: ": "(codes, old_categories, new_categories)","comments: ": "Convert a set of codes for to a new set of categories\n\nParameters ---------- codes : np.ndarray old_categories, new_categories : Index\n##### Returns\n* **new_codes **: np.ndarray[np.int64]\n\n"},"func5": {"source file: ": "categorical2.py","line number: ": "2638","func name: ": "_convert_to_list_like","func arg: ": "(list_like)","comments: ": ""},"func6": {"source file: ": "categorical2.py","line number: ": "2652","func name: ": "factorize_from_iterable","func arg: ": "(values)","comments: ": "Factorize an input `values` into `categories` and `codes`. Preserves categorical dtype in `categories`.\n\n*This is an internal function*\n\nParameters ---------- values : list-like\n##### Returns\n* **codes **: ndarray\n\n* **categories **: Index\nIf `values` has a categorical dtype, then `categories` is\na CategoricalIndex keeping the categories and order of `values`.\n\n"},"func7": {"source file: ": "categorical2.py","line number: ": "2690","func name: ": "factorize_from_iterables","func arg: ": "(iterables)","comments: ": "A higher-level wrapper over `factorize_from_iterable`.\n\n*This is an internal function*\n\nParameters ---------- iterables : list-like of list-likes\n##### Returns\n* **codes_list **: list of ndarrays\n\n* **categories_list **: list of Indexes\n\n"}}{}{}{"func1": {"source file: ": "clipboards1.py","line number: ": "10","func name: ": "read_clipboard","func arg: ": "(sep, **kwargs)","comments: ": "Read text from clipboard and pass to read_csv.\n\nParameters ---------- sep : str, default '\\s+' A string or regex delimiter. The default of '\\s+' denotes one or more whitespace characters.\n\n**kwargs See read_csv for the full argument list.\n##### Returns\n"},"func2": {"source file: ": "clipboards1.py","line number: ": "79","func name: ": "to_clipboard","func arg: ": "(obj, excel, sep, **kwargs)","comments: ": "Attempt to write text representation of object to the system clipboard The clipboard can be then pasted into Excel for example.\n\nParameters ---------- obj : the object to write to the clipboard excel : boolean, defaults to True if True, use the provided separator, writing in a csv format for allowing easy pasting into excel. if False, write a string representation of the object to the clipboard sep : optional, defaults to tab other keywords are passed to to_csv\n\nNotes ----- Requirements for your platform\n\n- Linux: xclip, or xsel (with PyQt4 modules)\n\n- Windows:\n\n- OS X\n"}}{"func1": {"source file: ": "common1.py","line number: ": "16","func name: ": "safe_remove","func arg: ": "(path)","comments: ": ""},"func2": {"source file: ": "common1.py","line number: ": "24","func name: ": "safe_close","func arg: ": "(store)","comments: ": ""},"func3": {"source file: ": "common1.py","line number: ": "32","func name: ": "create_tempfile","func arg: ": "(path)","comments: ": "create an unopened named temporary file\n\n\n"},"func4": {"source file: ": "common1.py","line number: ": "39","func name: ": "ensure_clean_store","func arg: ": "(path, mode, complevel, complib, fletcher32)","comments: ": ""},"func5": {"source file: ": "common1.py","line number: ": "58","func name: ": "ensure_clean_path","func arg: ": "(path)","comments: ": "return essentially a named temporary file that is not opened and deleted on exiting; if path is a list, then create and return list of filenames\n\n\n"},"func6": {"source file: ": "common1.py","line number: ": "76","func name: ": "_maybe_remove","func arg: ": "(store, key)","comments: ": "For tests using tables, try removing the table to be sure there is no content from previous tests using the same table name.\n\n\n"}}{}{"func1": {"source file: ": "common3.py","line number: ": "11","func name: ": "assert_invalid_addsub_type","func arg: ": "(left, right, msg)","comments: ": "Helper to assert that left and right can be neither added nor subtracted.\n\nParameters --------- left : object right : object msg : str or None, default None\n"},"func2": {"source file: ": "common3.py","line number: ": "31","func name: ": "get_upcast_box","func arg: ": "(box, vector)","comments: ": "Given two box-types, find the one that takes priority\n\n\n"},"func3": {"source file: ": "common3.py","line number: ": "44","func name: ": "assert_invalid_comparison","func arg: ": "(left, right, box)","comments: ": "Assert that comparison operations with mismatched types behave correctly.\n\nParameters ---------- left : np.ndarray, ExtensionArray, Index, or Series right : object box : {pd.DataFrame, pd.Series, pd.Index, tm.to_array}\n"}}{"func1": {"source file: ": "common4.py","line number: ": "28","func name: ": "_create_consistency_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "common4.py","line number: ": "358","func name: ": "ew_func","func arg: ": "(A, B, com, name, **kwargs)","comments: ": ""},"func3": {"source file: ": "common4.py","line number: ": "362","func name: ": "check_binary_ew","func arg: ": "(name, A, B)","comments: ": ""},"func4": {"source file: ": "common4.py","line number: ": "369","func name: ": "check_binary_ew_min_periods","func arg: ": "(name, min_periods, A, B)","comments: ": ""}}{"func1": {"source file: ": "common5.py","line number: ": "1","func name: ": "_check_mixed_float","func arg: ": "(df, dtype)","comments: ": ""},"func2": {"source file: ": "common5.py","line number: ": "18","func name: ": "_check_mixed_int","func arg: ": "(df, dtype)","comments: ": ""}}{"func1": {"source file: ": "common6.py","line number: ": "78","func name: ": "ensure_float","func arg: ": "(arr)","comments: ": "Ensure that an array object has a float dtype if possible.\n\nParameters ---------- arr : array-like The array whose data type we want to enforce as float.\n##### Returns\n* **float_arr **: The original array cast to the float dtype if\npossible. Otherwise, the original array is returned.\n\n"},"func2": {"source file: ": "common6.py","line number: ": "107","func name: ": "ensure_str","func arg: ": "(value)","comments: ": "Ensure that bytes and non-strings get converted into ``str`` objects.\n\n\n"},"func3": {"source file: ": "common6.py","line number: ": "118","func name: ": "ensure_categorical","func arg: ": "(arr)","comments: ": "Ensure that an array-like object is a Categorical (if not already).\n\nParameters ---------- arr : array-like The array that we want to convert into a Categorical.\n##### Returns\n* **cat_arr **: The original array cast as a Categorical. If it already\n  is a Categorical, we return as is.\n\n"},"func4": {"source file: ": "common6.py","line number: ": "140","func name: ": "ensure_int_or_float","func arg: ": "(arr, copy)","comments: ": "Ensure that an dtype array of some integer dtype has an int64 dtype if possible. If it's not possible, potentially because of overflow, convert the array to float64 instead.\n\nParameters ---------- arr : array-like The array whose data type we want to enforce. copy: bool Whether to copy the original array or reuse it in place, if possible.\n##### Returns\n* **out_arr **: The input array cast as int64 if\n  possible without overflow.\n  Otherwise the input array cast to float64.\n\n"},"func5": {"source file: ": "common6.py","line number: ": "179","func name: ": "ensure_python_int","func arg: ": "(value)","comments: ": "Ensure that a value is a python int.\n\nParameters ---------- value: int or numpy.integer\n##### Returns\n"},"func6": {"source file: ": "common6.py","line number: ": "206","func name: ": "classes","func arg: ": "()","comments: ": "evaluate if the tipo is a subclass of the klasses\n\n\n"},"func7": {"source file: ": "common6.py","line number: ": "211","func name: ": "classes_and_not_datetimelike","func arg: ": "()","comments: ": "evaluate if the tipo is a subclass of the klasses and not a datetimelike\n\n\n"},"func8": {"source file: ": "common6.py","line number: ": "222","func name: ": "is_object_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of the object dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func9": {"source file: ": "common6.py","line number: ": "252","func name: ": "is_sparse","func arg: ": "(arr)","comments: ": "Check whether an array-like is a 1-D pandas sparse array.\n\nCheck that the one-dimensional array-like is a pandas sparse array.\n"},"func10": {"source file: ": "common6.py","line number: ": "300","func name: ": "is_scipy_sparse","func arg: ": "(arr)","comments: ": "Check whether an array-like is a scipy.sparse.spmatrix instance.\n\nParameters ---------- arr : array-like The array-like to check.\n##### Returns\n"},"func11": {"source file: ": "common6.py","line number: ": "339","func name: ": "is_categorical","func arg: ": "(arr)","comments: ": "Check whether an array-like is a Categorical instance.\n\nParameters ---------- arr : array-like The array-like to check.\n##### Returns\n"},"func12": {"source file: ": "common6.py","line number: ": "372","func name: ": "is_datetime64_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of the datetime64 dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func13": {"source file: ": "common6.py","line number: ": "403","func name: ": "is_datetime64tz_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func14": {"source file: ": "common6.py","line number: ": "441","func name: ": "is_timedelta64_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of the timedelta64 dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func15": {"source file: ": "common6.py","line number: ": "472","func name: ": "is_period_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of the Period dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func16": {"source file: ": "common6.py","line number: ": "506","func name: ": "is_interval_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of the Interval dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func17": {"source file: ": "common6.py","line number: ": "542","func name: ": "is_categorical_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether an array-like or dtype is of the Categorical dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype to check.\n##### Returns\n"},"func18": {"source file: ": "common6.py","line number: ": "575","func name: ": "is_string_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of the string dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func19": {"source file: ": "common6.py","line number: ": "618","func name: ": "is_period_arraylike","func arg: ": "(arr)","comments: ": "Check whether an array-like is a periodical array-like or PeriodIndex.\n\nParameters ---------- arr : array-like The array-like to check.\n##### Returns\n"},"func20": {"source file: ": "common6.py","line number: ": "650","func name: ": "is_datetime_arraylike","func arg: ": "(arr)","comments: ": "Check whether an array-like is a datetime array-like or DatetimeIndex.\n\nParameters ---------- arr : array-like The array-like to check.\n##### Returns\n"},"func21": {"source file: ": "common6.py","line number: ": "685","func name: ": "is_dtype_equal","func arg: ": "(source, target)","comments: ": "Check if two dtypes are equal.\n\nParameters ---------- source : The first dtype to compare target : The second dtype to compare\n##### Returns\n"},"func22": {"source file: ": "common6.py","line number: ": "724","func name: ": "is_any_int_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of an integer dtype.\n\nIn this function, timedelta64 instances are also considered \"any-integer\" type objects and will return True.\n\nThis function is internal and should not be exposed in the public API.\n\n.. versionchanged:: 0.24.0\n\nThe nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered as integer by this function.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func23": {"source file: ": "common6.py","line number: ": "775","func name: ": "is_integer_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of an integer dtype.\n\nUnlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n.. versionchanged:: 0.24.0\n\nThe nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered as integer by this function.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func24": {"source file: ": "common6.py","line number: ": "830","func name: ": "is_signed_integer_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a signed integer dtype.\n\nUnlike in `in_any_int_dtype`, timedelta64 instances will return False.\n\n.. versionchanged:: 0.24.0\n\nThe nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered as integer by this function.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func25": {"source file: ": "common6.py","line number: ": "887","func name: ": "is_unsigned_integer_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of an unsigned integer dtype.\n\n.. versionchanged:: 0.24.0\n\nThe nullable Integer dtypes (e.g. pandas.UInt64Dtype) are also considered as integer by this function.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func26": {"source file: ": "common6.py","line number: ": "936","func name: ": "is_int64_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of the int64 dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func27": {"source file: ": "common6.py","line number: ": "987","func name: ": "is_datetime64_any_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of the datetime64 dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func28": {"source file: ": "common6.py","line number: ": "1027","func name: ": "is_datetime64_ns_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of the datetime64[ns] dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func29": {"source file: ": "common6.py","line number: ": "1077","func name: ": "is_timedelta64_ns_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of the timedelta64[ns] dtype.\n\nThis is a very specific dtype, so generic ones like `np.timedelta64` will return False if passed into this function.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func30": {"source file: ": "common6.py","line number: ": "1108","func name: ": "is_datetime_or_timedelta_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a timedelta64 or datetime64 dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func31": {"source file: ": "common6.py","line number: ": "1147","func name: ": "_is_unorderable_exception","func arg: ": "(e)","comments: ": "Check if the exception raised is an unorderable exception.\n\nParameters ---------- e : Exception or sub-class The exception object to check.\n##### Returns\n"},"func32": {"source file: ": "common6.py","line number: ": "1165","func name: ": "is_numeric_v_string_like","func arg: ": "(a, b)","comments: ": "Check if we are comparing a string-like object to a numeric ndarray. NumPy doesn't like to compare such objects, especially numeric arrays and scalar string-likes.\n\nParameters ---------- a : array-like, scalar The first object to check. b : array-like, scalar The second object to check.\n##### Returns\n"},"func33": {"source file: ": "common6.py","line number: ": "1225","func name: ": "is_datetimelike_v_numeric","func arg: ": "(a, b)","comments: ": "Check if we are comparing a datetime-like object to a numeric object. By \"numeric,\" we mean an object that is either of an int or float dtype.\n\nParameters ---------- a : array-like, scalar The first object to check. b : array-like, scalar The second object to check.\n##### Returns\n"},"func34": {"source file: ": "common6.py","line number: ": "1282","func name: ": "needs_i8_conversion","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the array or dtype should be converted to int64.\n\nAn array-like or dtype \"needs\" such a conversion if the array-like or dtype is of a datetime-like dtype\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func35": {"source file: ": "common6.py","line number: ": "1326","func name: ": "is_numeric_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a numeric dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func36": {"source file: ": "common6.py","line number: ": "1369","func name: ": "is_string_like_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a string-like dtype.\n\nUnlike `is_string_dtype`, the object dtype is excluded because it is a mixed dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func37": {"source file: ": "common6.py","line number: ": "1401","func name: ": "is_float_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a float dtype.\n\nThis function is internal and should not be exposed in the public API.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func38": {"source file: ": "common6.py","line number: ": "1435","func name: ": "is_bool_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a boolean dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func39": {"source file: ": "common6.py","line number: ": "1500","func name: ": "is_extension_type","func arg: ": "(arr)","comments: ": "Check whether an array-like is of a pandas extension class instance.\n\n.. deprecated:: 1.0.0 Use ``is_extension_array_dtype`` instead.\n\nExtension classes include categoricals, pandas sparse objects (i.e. classes represented within the pandas library and not ones external to it like scipy sparse matrices), and datetime-like arrays.\n\nParameters ---------- arr : array-like The array-like to check.\n##### Returns\n"},"func40": {"source file: ": "common6.py","line number: ": "1565","func name: ": "is_extension_array_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check if an object is a pandas extension array type.\n\nSee the :ref:`Use Guide <extending.extension-types>` for more.\n\nParameters ---------- arr_or_dtype : object For array-like input, the ``.dtype`` attribute will be extracted.\n##### Returns\n* **array interface. In pandas, this includes**: \n\n"},"func41": {"source file: ": "common6.py","line number: ": "1614","func name: ": "is_complex_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Check whether the provided array or dtype is of a complex dtype.\n\nParameters ---------- arr_or_dtype : array-like The array or dtype to check.\n##### Returns\n"},"func42": {"source file: ": "common6.py","line number: ": "1647","func name: ": "_is_dtype","func arg: ": "(arr_or_dtype, condition)","comments: ": "Return a boolean if the condition is satisfied for the arr_or_dtype.\n\nParameters ---------- arr_or_dtype : array-like, str, np.dtype, or ExtensionArrayType The array-like or dtype object whose dtype we want to extract. condition : callable[Union[np.dtype, ExtensionDtype]]\n##### Returns\n"},"func43": {"source file: ": "common6.py","line number: ": "1672","func name: ": "_get_dtype","func arg: ": "(arr_or_dtype)","comments: ": "Get the dtype instance associated with an array or dtype object.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype object whose dtype we want to extract.\n##### Returns\n* **obj_dtype **: The extract dtype instance from the\npassed in array or dtype object.\n\n"},"func44": {"source file: ": "common6.py","line number: ": "1708","func name: ": "_is_dtype_type","func arg: ": "(arr_or_dtype, condition)","comments: ": "Return a boolean if the condition is satisfied for the arr_or_dtype.\n\nParameters ---------- arr_or_dtype : array-like The array-like or dtype object whose dtype we want to extract. condition : callable[Union[np.dtype, ExtensionDtypeType]]\n##### Returns\n* **bool **: if the condition is satisfied for the arr_or_dtype\n\n"},"func45": {"source file: ": "common6.py","line number: ": "1753","func name: ": "infer_dtype_from_object","func arg: ": "(dtype)","comments: ": "Get a numpy dtype.type-style object for a dtype object.\n\nThis methods also includes handling of the datetime64[ns] and datetime64[ns, TZ] objects.\n\nIf no dtype can be found, we return ``object``.\n\nParameters ---------- dtype : dtype, type The dtype object whose numpy dtype.type-style object we want to extract.\n##### Returns\n* **dtype_object **: The extracted numpy dtype.type-style object.\n\n"},"func46": {"source file: ": "common6.py","line number: ": "1817","func name: ": "_validate_date_like_dtype","func arg: ": "(dtype)","comments: ": "Check whether the dtype is a date-like dtype. Raises an error if invalid.\n\nParameters ---------- dtype : dtype, type The dtype to check.\n"},"func47": {"source file: ": "common6.py","line number: ": "1844","func name: ": "pandas_dtype","func arg: ": "(dtype)","comments: ": "Convert input into a pandas only dtype object or a numpy dtype object.\n\nParameters ---------- dtype : object to be converted\n##### Returns\n"}}{"func1": {"source file: ": "common7.py","line number: ": "11","func name: ": "unpack_zerodim_and_defer","func arg: ": "(name)","comments: ": "Boilerplate for pandas conventions in arithmetic and comparison methods.\n\nParameters ---------- name : str\n##### Returns\n"},"func2": {"source file: ": "common7.py","line number: ": "30","func name: ": "_unpack_zerodim_and_defer","func arg: ": "(method, name)","comments: ": "Boilerplate for pandas conventions in arithmetic and comparison methods.\n\nEnsure method returns NotImplemented when operating against \"senior\" classes.\n\nEnsure zero-dimensional ndarrays are always unpacked.\n\nParameters ---------- method : binary method name : str\n##### Returns\n"}}{"func1": {"source file: ": "common8.py","line number: ": "40","func name: ": "is_url","func arg: ": "(url)","comments: ": "Check to see if a URL has a valid protocol.\n\nParameters ---------- url : str or unicode\n##### Returns\n* **isurl **: bool\nIf `url` has a valid protocol return True otherwise False.\n\n"},"func2": {"source file: ": "common8.py","line number: ": "58","func name: ": "_expand_user","func arg: ": "(filepath_or_buffer)","comments: ": "Return the argument with an initial component of ~ or ~user replaced by that user's home directory.\n\nParameters ---------- filepath_or_buffer : object to be converted if possible\n##### Returns\n* **expanded_filepath_or_buffer **: an expanded filepath or the\n  input if not expandable\n\n"},"func3": {"source file: ": "common8.py","line number: ": "78","func name: ": "validate_header_arg","func arg: ": "(header)","comments: ": ""},"func4": {"source file: ": "common8.py","line number: ": "88","func name: ": "stringify_path","func arg: ": "(filepath_or_buffer)","comments: ": "Attempt to convert a path-like object to a string.\n\nParameters ---------- filepath_or_buffer : object to be converted\n##### Returns\n* **str_filepath_or_buffer **: maybe a string version of the object\n\n"},"func5": {"source file: ": "common8.py","line number: ": "120","func name: ": "is_s3_url","func arg: ": "(url)","comments: ": "Check for an s3, s3n, or s3a url\n\n\n"},"func6": {"source file: ": "common8.py","line number: ": "127","func name: ": "is_gcs_url","func arg: ": "(url)","comments: ": "Check for a gcs url\n\n\n"},"func7": {"source file: ": "common8.py","line number: ": "134","func name: ": "urlopen","func arg: ": "(**kwargs)","comments: ": "Lazy-import wrapper for stdlib urlopen, as that imports a big chunk of the stdlib.\n\n\n"},"func8": {"source file: ": "common8.py","line number: ": "144","func name: ": "get_filepath_or_buffer","func arg: ": "(filepath_or_buffer, encoding, compression, mode)","comments: ": "If the filepath_or_buffer is a url, translate and return the buffer. Otherwise passthrough.\n\nParameters ---------- filepath_or_buffer : a url, filepath (str, py.path.local or pathlib.Path), or buffer compression : {{'gzip', 'bz2', 'zip', 'xz', None}}, optional encoding : the encoding to use to decode bytes, default is 'utf-8' mode : str, optional\n##### Returns\n"},"func9": {"source file: ": "common8.py","line number: ": "205","func name: ": "file_path_to_url","func arg: ": "(path)","comments: ": "converts an absolute native path to a FILE URL.\n\nParameters ---------- path : a path in native format\n##### Returns\n"},"func10": {"source file: ": "common8.py","line number: ": "226","func name: ": "get_compression_method","func arg: ": "(compression)","comments: ": "Simplifies a compression argument to a compression method string and a mapping containing additional arguments.\n\nParameters ---------- compression : str or mapping If string, specifies the compression method. If mapping, value at key 'method' specifies compression method.\n##### Returns\n"},"func11": {"source file: ": "common8.py","line number: ": "259","func name: ": "infer_compression","func arg: ": "(filepath_or_buffer, compression)","comments: ": "Get the compression method for filepath_or_buffer. If compression='infer', the inferred compression method is returned. Otherwise, the input compression method is returned unchanged, unless it's invalid, in which case an error is raised.\n\nParameters ---------- filepath_or_buffer : str or file handle File path or object. compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None} If 'infer' and `filepath_or_buffer` is path-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no compression).\n##### Returns\n"},"func12": {"source file: ": "common8.py","line number: ": "314","func name: ": "get_handle","func arg: ": "(path_or_buf, mode, encoding, compression, memory_map, is_text)","comments: ": "Get file handle for given path/buffer and mode.\n\nParameters ---------- path_or_buf : str or file handle File path or object. mode : str Mode to open path_or_buf with. encoding : str or None Encoding to use. compression : str or dict, default None If string, specifies compression mode. If dict, value at key 'method' specifies compression mode. Compression mode must be one of {'infer', 'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer' and `filepath_or_buffer` is path-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no compression). If dict and compression mode is 'zip' or inferred as 'zip', other entries passed as additional compression options.\n\n.. versionchanged:: 1.0.0\n\nMay now be a dict with key 'method' as compression mode and other keys as compression options if compression mode is 'zip'.\n\nmemory_map : boolean, default False See parsers._parser_params for more information. is_text : boolean, default True whether file/buffer is in text format (csv, json, etc.), or in binary mode (pickle, etc.).\n##### Returns\n* **f **: file-like\nA file-like object.\n\n* **handles **: list of file-like objects\nA list of file-like object that were opened in this function.\n\n"}}{"func1": {"source file: ": "common9.py","line number: ": "39","func name: ": "flatten","func arg: ": "(l)","comments: ": "Flatten an arbitrarily nested sequence.\n\nParameters ---------- l : sequence The non string sequence to flatten\n\nNotes ----- This doesn't consider strings sequences.\n##### Returns\n* **flattened **: generator\n\n"},"func2": {"source file: ": "common9.py","line number: ": "64","func name: ": "consensus_name_attr","func arg: ": "(objs)","comments: ": ""},"func3": {"source file: ": "common9.py","line number: ": "75","func name: ": "maybe_box","func arg: ": "(indexer, values, obj, key)","comments: ": ""},"func4": {"source file: ": "common9.py","line number: ": "85","func name: ": "maybe_box_datetimelike","func arg: ": "(value)","comments: ": ""},"func5": {"source file: ": "common9.py","line number: ": "99","func name: ": "is_bool_indexer","func arg: ": "(key)","comments: ": "Check whether `key` is a valid boolean indexer.\n\nParameters ---------- key : Any Only list-likes may be considered boolean indexers. All other types are not considered a boolean indexer. For array-like input, boolean ndarrays or ExtensionArrays with ``_is_boolean`` set are considered boolean indexers.\n##### Returns\n"},"func6": {"source file: ": "common9.py","line number: ": "151","func name: ": "cast_scalar_indexer","func arg: ": "(val)","comments: ": "To avoid numpy DeprecationWarnings, cast float to integer where valid.\n\nParameters ---------- val : scalar\n##### Returns\n* **outval **: scalar\n\n"},"func7": {"source file: ": "common9.py","line number: ": "169","func name: ": "not_none","func arg: ": "()","comments: ": "Returns a generator consisting of the arguments that are not None.\n\n\n"},"func8": {"source file: ": "common9.py","line number: ": "176","func name: ": "any_none","func arg: ": "()","comments: ": "Returns a boolean indicating if any argument is None.\n\n\n"},"func9": {"source file: ": "common9.py","line number: ": "183","func name: ": "all_none","func arg: ": "()","comments: ": "Returns a boolean indicating if all arguments are None.\n\n\n"},"func10": {"source file: ": "common9.py","line number: ": "190","func name: ": "any_not_none","func arg: ": "()","comments: ": "Returns a boolean indicating if any argument is not None.\n\n\n"},"func11": {"source file: ": "common9.py","line number: ": "197","func name: ": "all_not_none","func arg: ": "()","comments: ": "Returns a boolean indicating if all arguments are not None.\n\n\n"},"func12": {"source file: ": "common9.py","line number: ": "204","func name: ": "count_not_none","func arg: ": "()","comments: ": "Returns the count of arguments that are not None.\n\n\n"},"func13": {"source file: ": "common9.py","line number: ": "211","func name: ": "try_sort","func arg: ": "(iterable)","comments: ": ""},"func14": {"source file: ": "common9.py","line number: ": "219","func name: ": "asarray_tuplesafe","func arg: ": "(values, dtype)","comments: ": ""},"func15": {"source file: ": "common9.py","line number: ": "242","func name: ": "index_labels_to_array","func arg: ": "(labels, dtype)","comments: ": "Transform label or iterable of labels to array, for use in Index.\n\nParameters ---------- dtype : dtype If specified, use as dtype of the resulting array, otherwise infer.\n##### Returns\n"},"func16": {"source file: ": "common9.py","line number: ": "269","func name: ": "maybe_make_list","func arg: ": "(obj)","comments: ": ""},"func17": {"source file: ": "common9.py","line number: ": "275","func name: ": "maybe_iterable_to_list","func arg: ": "(obj)","comments: ": "If obj is Iterable but not list-like, consume into list.\n\n\n"},"func18": {"source file: ": "common9.py","line number: ": "284","func name: ": "is_null_slice","func arg: ": "(obj)","comments: ": "We have a null slice.\n\n\n"},"func19": {"source file: ": "common9.py","line number: ": "296","func name: ": "is_true_slices","func arg: ": "(l)","comments: ": "Find non-trivial slices in \"l\": return a list of booleans with same length.\n\n\n"},"func20": {"source file: ": "common9.py","line number: ": "304","func name: ": "is_full_slice","func arg: ": "(obj, l)","comments: ": "We have a full length slice.\n\n\n"},"func21": {"source file: ": "common9.py","line number: ": "313","func name: ": "get_callable_name","func arg: ": "(obj)","comments: ": ""},"func22": {"source file: ": "common9.py","line number: ": "330","func name: ": "apply_if_callable","func arg: ": "(maybe_callable, obj, **kwargs)","comments: ": "Evaluate possibly callable input using obj and kwargs if it is callable, otherwise return as it is.\n\nParameters ---------- maybe_callable : possibly a callable obj : NDFrame **kwargs\n"},"func23": {"source file: ": "common9.py","line number: ": "348","func name: ": "dict_compat","func arg: ": "(d)","comments: ": "Helper function to convert datetimelike-keyed dicts to Timestamp-keyed dict.\n\nParameters ---------- d: dict like object\n##### Returns\n"},"func24": {"source file: ": "common9.py","line number: ": "365","func name: ": "standardize_mapping","func arg: ": "(into)","comments: ": "Helper function to standardize a supplied mapping.\n\n.. versionadded:: 0.21.0\n\nParameters ---------- into : instance or subclass of collections.abc.Mapping Must be a class, an initialized collections.defaultdict, or an instance of a collections.abc.Mapping subclass.\n##### Returns\n* **mapping **: a collections.abc.Mapping subclass or other constructor\na callable object that can accept an iterator to create\nthe desired Mapping.\n\n"},"func25": {"source file: ": "common9.py","line number: ": "399","func name: ": "random_state","func arg: ": "(state)","comments: ": "Helper function for processing random_state arguments.\n\nParameters ---------- state : int, np.random.RandomState, None. If receives an int, passes to np.random.RandomState() as seed. If receives an np.random.RandomState object, just returns object. If receives `None`, returns np.random. If receives anything else, raises an informative ValueError. Default None.\n##### Returns\n"},"func26": {"source file: ": "common9.py","line number: ": "429","func name: ": "pipe","func arg: ": "(obj, func, **kwargs)","comments: ": "Apply a function ``func`` to object ``obj`` either by passing obj as the first argument to the function or, in the case that the func is a tuple, interpret the first element of the tuple as a function and pass the obj to that function as a keyword argument whose key is the value of the second element of the tuple.\n\nParameters ---------- func : callable or tuple of (callable, str) Function to apply to this object or, alternatively, a ``(callable, data_keyword)`` tuple where ``data_keyword`` is a string indicating the keyword of `callable`` that expects the object. *args : iterable, optional Positional arguments passed into ``func``. **kwargs : dict, optional A dictionary of keyword arguments passed into ``func``.\n##### Returns\n* **object **: the return type of ``func``.\n\n"},"func27": {"source file: ": "common9.py","line number: ": "464","func name: ": "get_rename_function","func arg: ": "(mapper)","comments: ": "Returns a function that will map names/labels, dependent if mapper is a dict, Series or just a function.\n\n\n"}}{"func1": {"source file: ": "common10.py","line number: ": "6","func name: ": "assert_offset_equal","func arg: ": "(offset, base, expected)","comments: ": ""},"func2": {"source file: ": "common10.py","line number: ": "21","func name: ": "assert_is_on_offset","func arg: ": "(offset, date, expected)","comments: ": ""}}{"func1": {"source file: ": "common11.py","line number: ": "526","func name: ": "_check_plot_works","func arg: ": "(f, filterwarnings, **kwargs)","comments: ": ""},"func2": {"source file: ": "common11.py","line number: ": "561","func name: ": "curpath","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "common12.py","line number: ": "8","func name: ": "_ensure_decoded","func arg: ": "(s)","comments: ": "If we have bytes, decode them to unicode.\n\n\n"},"func2": {"source file: ": "common12.py","line number: ": "17","func name: ": "result_type_many","func arg: ": "()","comments: ": "Wrapper around numpy.result_type which overcomes the NPY_MAXARGS (32) argument limit.\n\n\n"}}{}{"func1": {"source file: ": "common14.py","line number: ": "13","func name: ": "_mklbl","func arg: ": "(prefix, n)","comments: ": ""},"func2": {"source file: ": "common14.py","line number: ": "17","func name: ": "_axify","func arg: ": "(obj, key, axis)","comments: ": ""}}{"func1": {"source file: ": "common15.py","line number: ": "30","func name: ": "_dispatch","func arg: ": "(name, **kwargs)","comments: ": "Dispatch to apply.\n\n\n"},"func2": {"source file: ": "common15.py","line number: ": "94","func name: ": "_flex_binary_moment","func arg: ": "(arg1, arg2, f, pairwise)","comments: ": ""},"func3": {"source file: ": "common15.py","line number: ": "225","func name: ": "_get_center_of_mass","func arg: ": "(comass, span, halflife, alpha)","comments: ": ""},"func4": {"source file: ": "common15.py","line number: ": "253","func name: ": "calculate_center_offset","func arg: ": "(window)","comments: ": ""},"func5": {"source file: ": "common15.py","line number: ": "259","func name: ": "calculate_min_periods","func arg: ": "(window, min_periods, num_values, required_min_periods, floor)","comments: ": "Calculates final minimum periods value for rolling aggregations.\n\nParameters ---------- window : passed window value min_periods : passed min periods value num_values : total number of values required_min_periods : required min periods per aggregation function floor : required min periods per aggregation function\n##### Returns\n* **min_periods **: int\n\n"},"func6": {"source file: ": "common15.py","line number: ": "294","func name: ": "zsqrt","func arg: ": "(x)","comments: ": ""},"func7": {"source file: ": "common15.py","line number: ": "309","func name: ": "prep_binary","func arg: ": "(arg1, arg2)","comments: ": ""},"func8": {"source file: ": "common15.py","line number: ": "320","func name: ": "get_weighted_roll_func","func arg: ": "(cfunc)","comments: ": ""}}{"func1": {"source file: ": "compat1.py","line number: ": "6","func name: ": "_mpl_version","func arg: ": "(version, op)","comments: ": ""}}{"func1": {"source file: ": "concat1.py","line number: ": "31","func name: ": "get_dtype_kinds","func arg: ": "(l)","comments: ": "Parameters ---------- l : list of arrays\n\n\n##### Returns\n"},"func2": {"source file: ": "concat1.py","line number: ": "72","func name: ": "concat_compat","func arg: ": "(to_concat, axis)","comments: ": "provide concatenation of an array of arrays each of which is a single 'normalized' dtypes (in that for example, if it's object, then it is a non-datetimelike and provide a combined dtype for the resulting array that preserves the overall dtype if possible)\n\nParameters ---------- to_concat : array of arrays axis : axis to provide concatenation\n##### Returns\n"},"func3": {"source file: ": "concat1.py","line number: ": "140","func name: ": "concat_categorical","func arg: ": "(to_concat, axis)","comments: ": "Concatenate an object/categorical array of arrays, each of which is a single dtype\n\nParameters ---------- to_concat : array of arrays axis : int Axis to provide concatenation in the current implementation this is always 0, e.g. we only have 1D categoricals\n##### Returns\n"},"func4": {"source file: ": "concat1.py","line number: ": "186","func name: ": "union_categoricals","func arg: ": "(to_union, sort_categories, ignore_order)","comments: ": "Combine list-like of Categorical-like, unioning categories.\n\nAll categories must have the same dtype.\n\nParameters ---------- to_union : list-like Categorical, CategoricalIndex, or Series with dtype='category'. sort_categories : bool, default False If true, resulting categories will be lexsorted, otherwise they will be ordered as they appear in the data. ignore_order : bool, default False If true, the ordered attribute of the Categoricals will be ignored. Results in an unordered categorical.\n##### Returns\n"},"func5": {"source file: ": "concat1.py","line number: ": "360","func name: ": "_concatenate_2d","func arg: ": "(to_concat, axis)","comments: ": ""},"func6": {"source file: ": "concat1.py","line number: ": "367","func name: ": "concat_datetime","func arg: ": "(to_concat, axis, typs)","comments: ": "provide concatenation of an datetimelike array of arrays each of which is a single M8[ns], datetimet64[ns, tz] or m8[ns] dtype\n\nParameters ---------- to_concat : array of arrays axis : axis to provide concatenation typs : set of to_concat dtypes\n##### Returns\n"},"func7": {"source file: ": "concat1.py","line number: ": "415","func name: ": "_convert_datetimelike_to_object","func arg: ": "(x)","comments: ": ""},"func8": {"source file: ": "concat1.py","line number: ": "435","func name: ": "_concat_datetimetz","func arg: ": "(to_concat, name)","comments: ": "concat DatetimeIndex with the same tz all inputs must be DatetimeIndex it is used in DatetimeIndex.append also\n\n\n"},"func9": {"source file: ": "concat1.py","line number: ": "452","func name: ": "_concat_sparse","func arg: ": "(to_concat, axis, typs)","comments: ": "provide concatenation of an sparse/dense array of arrays each of which is a single dtype\n\nParameters ---------- to_concat : array of arrays axis : axis to provide concatenation typs : set of to_concat dtypes\n##### Returns\n"}}{"func1": {"source file: ": "concat2.py","line number: ": "32","func name: ": "concat","func arg: ": "(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)","comments: ": ""},"func2": {"source file: ": "concat2.py","line number: ": "48","func name: ": "concat","func arg: ": "(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)","comments: ": ""},"func3": {"source file: ": "concat2.py","line number: ": "65","func name: ": "concat","func arg: ": "(objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy)","comments: ": "Concatenate pandas objects along a particular axis with optional set logic along the other axes.\n\nCan also add a layer of hierarchical indexing on the concatenation axis, which may be useful if the labels are the same (or overlapping) on the passed axis number.\n\nParameters ---------- objs : a sequence or mapping of Series or DataFrame objects If a dict is passed, the sorted keys will be used as the `keys` argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised. axis : {0/'index', 1/'columns'}, default 0 The axis to concatenate along. join : {'inner', 'outer'}, default 'outer' How to handle indexes on other axis (or axes). ignore_index : bool, default False If True, do not use the index values along the concatenation axis. The resulting axis will be labeled 0, ..., n\n\n- 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join. keys : sequence, default None If multiple levels passed, should contain tuples. Construct hierarchical index using the passed keys as the outermost level. levels : list of sequences, default None Specific levels (unique values) to use for constructing a MultiIndex. Otherwise they will be inferred from the keys. names : list, default None Names for the levels in the resulting hierarchical index. verify_integrity : bool, default False Check whether the new concatenated axis contains duplicates. This can be very expensive relative to the actual data concatenation. sort : bool, default False Sort non-concatenation axis if it is not already aligned when `join` is 'outer'. This has no effect when ``join='inner'``, which already preserves the order of the non-concatenation axis.\n\n.. versionadded:: 0.23.0 .. versionchanged:: 1.0.0\n\nChanged to not sort by default.\n\ncopy : bool, default True If False, do not copy data unnecessarily.\n##### Returns\n* **Series.append **: Concatenate Series.\n\n* **DataFrame.append **: Concatenate DataFrames.\n\n* **DataFrame.join **: Join DataFrames using indexes.\n\n* **DataFrame.merge **: Merge DataFrames by indexes or columns.\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/merging.html>`__.\n\n* **dtype**: object\n\n* **Traceback (most recent call last)**: ...\n\n* **ValueError**: Indexes have overlapping values\n\n"},"func4": {"source file: ": "concat2.py","line number: ": "586","func name: ": "_concat_indexes","func arg: ": "(indexes)","comments: ": ""},"func5": {"source file: ": "concat2.py","line number: ": "590","func name: ": "_make_concat_multiindex","func arg: ": "(indexes, keys, levels, names)","comments: ": ""}}{"func1": {"source file: ": "concat3.py","line number: ": "28","func name: ": "get_mgr_concatenation_plan","func arg: ": "(mgr, indexers)","comments: ": "Construct concatenation plan for given block manager and indexers.\n\nParameters ---------- mgr : BlockManager indexers : dict of {axis: indexer}\n##### Returns\n* **plan **: list of (BlockPlacement, JoinUnit) tuples\n\n"},"func2": {"source file: ": "concat3.py","line number: ": "236","func name: ": "concatenate_join_units","func arg: ": "(join_units, concat_axis, copy)","comments: ": "Concatenate values from several join units along selected axis.\n\n\n"},"func3": {"source file: ": "concat3.py","line number: ": "268","func name: ": "_get_empty_dtype_and_na","func arg: ": "(join_units)","comments: ": "Return dtype and N/A values to use when concatenating specified units.\n\nReturned N/A value may be None which means there was no casting involved.\n##### Returns\n"},"func4": {"source file: ": "concat3.py","line number: ": "375","func name: ": "is_uniform_join_units","func arg: ": "(join_units)","comments: ": "Check if the join units consist of blocks of uniform type that can be concatenated using Block.concat_same_type instead of the generic concatenate_join_units (which uses `concat_compat`).\n\n\n"},"func5": {"source file: ": "concat3.py","line number: ": "398","func name: ": "_is_uniform_reindex","func arg: ": "(join_units)","comments: ": ""},"func6": {"source file: ": "concat3.py","line number: ": "406","func name: ": "_trim_join_unit","func arg: ": "(join_unit, length)","comments: ": "Reduce join_unit's shape along item axis to length.\n\nExtra items that didn't fit are returned as a separate block.\n"},"func7": {"source file: ": "concat3.py","line number: ": "434","func name: ": "combine_concat_plans","func arg: ": "(plans, concat_axis)","comments: ": "Combine multiple concatenation plans into one.\n\nexisting_plan is updated in-place.\n"}}{"func1": {"source file: ": "config_init1.py","line number: ": "35","func name: ": "use_bottleneck_cb","func arg: ": "(key)","comments: ": ""},"func2": {"source file: ": "config_init1.py","line number: ": "49","func name: ": "use_numexpr_cb","func arg: ": "(key)","comments: ": ""},"func3": {"source file: ": "config_init1.py","line number: ": "299","func name: ": "table_schema_cb","func arg: ": "(key)","comments: ": ""},"func4": {"source file: ": "config_init1.py","line number: ": "305","func name: ": "is_terminal","func arg: ": "()","comments: ": "Detect if Python is running in a terminal.\n\n\n"},"func5": {"source file: ": "config_init1.py","line number: ": "458","func name: ": "use_inf_as_na_cb","func arg: ": "(key)","comments: ": ""},"func6": {"source file: ": "config_init1.py","line number: ": "612","func name: ": "register_plotting_backend_cb","func arg: ": "(key)","comments: ": ""},"func7": {"source file: ": "config_init1.py","line number: ": "638","func name: ": "register_converter_cb","func arg: ": "(key)","comments: ": ""}}{"func1": {"source file: ": "config1.py","line number: ": "83","func name: ": "_get_single_key","func arg: ": "(pat, silent)","comments: ": ""},"func2": {"source file: ": "config1.py","line number: ": "101","func name: ": "_get_option","func arg: ": "(pat, silent)","comments: ": ""},"func3": {"source file: ": "config1.py","line number: ": "109","func name: ": "_set_option","func arg: ": "(**kwargs)","comments: ": ""},"func4": {"source file: ": "config1.py","line number: ": "141","func name: ": "_describe_option","func arg: ": "(pat, _print_desc)","comments: ": ""},"func5": {"source file: ": "config1.py","line number: ": "155","func name: ": "_reset_option","func arg: ": "(pat, silent)","comments: ": ""},"func6": {"source file: ": "config1.py","line number: ": "174","func name: ": "get_default_val","func arg: ": "(pat)","comments: ": ""},"func7": {"source file: ": "config1.py","line number: ": "413","func name: ": "register_option","func arg: ": "(key, defval, doc, validator, cb)","comments: ": "Register an option in the package-wide pandas config object\n\nParameters ---------- key\n\n\n\n\n\n\n\n- a fully-qualified key, e.g. \"x.y.option\n\n- z\". defval\n\n\n\n- the default value of the option doc\n\n\n\n\n\n\n\n- a string description of the option validator\n\n- a function of a single argument, should raise `ValueError` if called with a value which is not a legal value for the option. cb\n\n\n\n\n\n\n\n- a function of a single argument \"key\", which is called immediately after an option value is set/reset. key is the full name of the option.\n##### Returns\n"},"func8": {"source file: ": "config1.py","line number: ": "482","func name: ": "deprecate_option","func arg: ": "(key, msg, rkey, removal_ver)","comments: ": "Mark option `key` as deprecated, if code attempts to access this option, a warning will be produced, using `msg` if given, or a default message if not. if `rkey` is given, any access to the key will be re-routed to `rkey`.\n\nNeither the existence of `key` nor that if `rkey` is checked. If they do not exist, any subsequence access will fail as usual, after the deprecation warning is given.\n\nParameters ---------- key\n\n- the name of the option to be deprecated. must be a fully-qualified option name (e.g \"x.y.z.rkey\").\n\nmsg\n\n- (Optional) a warning message to output when the key is referenced. if no message is given a default message will be emitted.\n\nrkey\n\n- (Optional) the name of an option to reroute access to. If specified, any referenced `key` will be re-routed to `rkey` including set/get/reset. rkey must be a fully-qualified option name (e.g \"x.y.z.rkey\"). used by the default message if no `msg` is specified.\n\nremoval_ver\n\n- (Optional) specifies the version in which this option will be removed. used by the default message if no `msg` is specified.\n##### Returns\n"},"func9": {"source file: ": "config1.py","line number: ": "533","func name: ": "_select_options","func arg: ": "(pat)","comments: ": "returns a list of keys matching `pat`\n\nif pat==\"all\", returns all registered options\n"},"func10": {"source file: ": "config1.py","line number: ": "551","func name: ": "_get_root","func arg: ": "(key)","comments: ": ""},"func11": {"source file: ": "config1.py","line number: ": "559","func name: ": "_is_deprecated","func arg: ": "(key)","comments: ": "Returns True if the given option has been deprecated\n\n\n"},"func12": {"source file: ": "config1.py","line number: ": "566","func name: ": "_get_deprecated_option","func arg: ": "(key)","comments: ": "Retrieves the metadata for a deprecated option, if `key` is deprecated.\n\n\n##### Returns\n"},"func13": {"source file: ": "config1.py","line number: ": "583","func name: ": "_get_registered_option","func arg: ": "(key)","comments: ": "Retrieves the option metadata if `key` is a registered option.\n\n\n##### Returns\n"},"func14": {"source file: ": "config1.py","line number: ": "594","func name: ": "_translate_key","func arg: ": "(key)","comments: ": "if key id deprecated and a replacement key defined, will return the replacement key, otherwise returns `key` as - is\n\n\n"},"func15": {"source file: ": "config1.py","line number: ": "607","func name: ": "_warn_if_deprecated","func arg: ": "(key)","comments: ": "Checks if `key` is a deprecated option and if so, prints a warning.\n\n\n##### Returns\n"},"func16": {"source file: ": "config1.py","line number: ": "635","func name: ": "_build_option_description","func arg: ": "(k)","comments: ": "Builds a formatted description of a registered option and prints it\n\n\n"},"func17": {"source file: ": "config1.py","line number: ": "660","func name: ": "pp_options_list","func arg: ": "(keys, width, _print)","comments: ": "Builds a concise listing of available options, grouped by prefix\n\n\n"},"func18": {"source file: ": "config1.py","line number: ": "700","func name: ": "config_prefix","func arg: ": "(prefix)","comments: ": "contextmanager for multiple invocations of API with a common prefix\n\nsupported API functions: (register / get / set )__option\n\nWarning: This is not thread\n\n- safe, and won't work properly if you import the API functions into your module using the \"from x import y\" construct.\n\nExample:\n\nimport pandas._config.config as cf with cf.config_prefix(\"display.font\"): cf.register_option(\"color\", \"red\") cf.register_option(\"size\", \" 5 pt\") cf.set_option(size, \" 6 pt\") cf.get_option(size) ...\n\netc'\n\nwill register options \"display.font.color\", \"display.font.size\", set the value of \"display.font.size\"... and so on.\n"},"func19": {"source file: ": "config1.py","line number: ": "752","func name: ": "is_type_factory","func arg: ": "(_type)","comments: ": "Parameters ---------- `_type` - a type to be compared against (e.g. type(x) == `_type`)\n\n\n##### Returns\n"},"func20": {"source file: ": "config1.py","line number: ": "773","func name: ": "is_instance_factory","func arg: ": "(_type)","comments: ": "Parameters ---------- `_type` - the type to be checked against\n\n\n##### Returns\n"},"func21": {"source file: ": "config1.py","line number: ": "800","func name: ": "is_one_of_factory","func arg: ": "(legal_values)","comments: ": ""},"func22": {"source file: ": "config1.py","line number: ": "819","func name: ": "is_nonnegative_int","func arg: ": "(value)","comments: ": "Verify that value is None or a positive int.\n\nParameters ---------- value : None or int The `value` to be checked.\n"},"func23": {"source file: ": "config1.py","line number: ": "854","func name: ": "is_callable","func arg: ": "(obj)","comments: ": "Parameters ---------- `obj` - the object to be checked\n\n\n##### Returns\n"}}{"func1": {"source file: ": "conftest1.py","line number: ": "28","func name: ": "indices","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "conftest1.py","line number: ": "34","func name: ": "one","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "conftest1.py","line number: ": "49","func name: ": "zero","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "conftest2.py","line number: ": "9","func name: ": "multiindex_dataframe_random_data","func arg: ": "()","comments: ": "DataFrame with 2 level MultiIndex with random data\n\n\n"},"func2": {"source file: ": "conftest2.py","line number: ": "22","func name: ": "multiindex_year_month_day_dataframe_random_data","func arg: ": "()","comments: ": "DataFrame with 3 level MultiIndex (year, month, day) covering first 100 business days from 2000-01-01 with random data\n\n\n"}}{"func1": {"source file: ": "conftest3.py","line number: ": "9","func name: ": "multiindex_dataframe_random_data","func arg: ": "()","comments: ": "DataFrame with 2 level MultiIndex with random data\n\n\n"},"func2": {"source file: ": "conftest3.py","line number: ": "22","func name: ": "multiindex_year_month_day_dataframe_random_data","func arg: ": "()","comments: ": "DataFrame with 3 level MultiIndex (year, month, day) covering first 100 business days from 2000-01-01 with random data\n\n\n"}}{"func1": {"source file: ": "conftest4.py","line number: ": "32","func name: ": "downsample_method","func arg: ": "(request)","comments: ": "Fixture for parametrization of Grouper downsample methods.\n\n\n"},"func2": {"source file: ": "conftest4.py","line number: ": "38","func name: ": "upsample_method","func arg: ": "(request)","comments: ": "Fixture for parametrization of Grouper upsample methods.\n\n\n"},"func3": {"source file: ": "conftest4.py","line number: ": "44","func name: ": "resample_method","func arg: ": "(request)","comments: ": "Fixture for parametrization of Grouper resample methods.\n\n\n"},"func4": {"source file: ": "conftest4.py","line number: ": "50","func name: ": "simple_date_range_series","func arg: ": "()","comments: ": "Series with date range index and random data for test purposes.\n\n\n"},"func5": {"source file: ": "conftest4.py","line number: ": "63","func name: ": "simple_period_range_series","func arg: ": "()","comments: ": "Series with period range index and random data for test purposes.\n\n\n"},"func6": {"source file: ": "conftest4.py","line number: ": "76","func name: ": "_index_start","func arg: ": "()","comments: ": "Fixture for parametrization of index, series and frame.\n\n\n"},"func7": {"source file: ": "conftest4.py","line number: ": "82","func name: ": "_index_end","func arg: ": "()","comments: ": "Fixture for parametrization of index, series and frame.\n\n\n"},"func8": {"source file: ": "conftest4.py","line number: ": "88","func name: ": "_index_freq","func arg: ": "()","comments: ": "Fixture for parametrization of index, series and frame.\n\n\n"},"func9": {"source file: ": "conftest4.py","line number: ": "94","func name: ": "_index_name","func arg: ": "()","comments: ": "Fixture for parametrization of index, series and frame.\n\n\n"},"func10": {"source file: ": "conftest4.py","line number: ": "100","func name: ": "index","func arg: ": "(_index_factory, _index_start, _index_end, _index_freq, _index_name)","comments: ": "Fixture for parametrization of date_range, period_range and timedelta_range indexes\n\n\n"},"func11": {"source file: ": "conftest4.py","line number: ": "107","func name: ": "_static_values","func arg: ": "(index)","comments: ": "Fixture for parametrization of values used in parametrization of Series and DataFrames with date_range, period_range and timedelta_range indexes\n\n\n"},"func12": {"source file: ": "conftest4.py","line number: ": "115","func name: ": "_series_name","func arg: ": "()","comments: ": "Fixture for parametrization of Series name for Series used with date_range, period_range and timedelta_range indexes\n\n\n"},"func13": {"source file: ": "conftest4.py","line number: ": "122","func name: ": "series","func arg: ": "(index, _series_name, _static_values)","comments: ": "Fixture for parametrization of Series with date_range, period_range and timedelta_range indexes\n\n\n"},"func14": {"source file: ": "conftest4.py","line number: ": "129","func name: ": "empty_series","func arg: ": "(series)","comments: ": "Fixture for parametrization of empty Series with date_range, period_range and timedelta_range indexes\n\n\n"},"func15": {"source file: ": "conftest4.py","line number: ": "136","func name: ": "frame","func arg: ": "(index, _series_name, _static_values)","comments: ": "Fixture for parametrization of DataFrame with date_range, period_range and timedelta_range indexes\n\n\n"},"func16": {"source file: ": "conftest4.py","line number: ": "144","func name: ": "empty_frame","func arg: ": "(series)","comments: ": "Fixture for parametrization of empty DataFrame with date_range, period_range and timedelta_range indexes\n\n\n"},"func17": {"source file: ": "conftest4.py","line number: ": "152","func name: ": "series_and_frame","func arg: ": "(request, series, frame)","comments: ": "Fixture for parametrization of Series and DataFrame with date_range, period_range and timedelta_range indexes\n\n\n"}}{"func1": {"source file: ": "conftest5.py","line number: ": "9","func name: ": "binary_ew_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "conftest5.py","line number: ": "19","func name: ": "min_periods","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "conftest6.py","line number: ": "9","func name: ": "float_frame_with_na","func arg: ": "()","comments: ": "Fixture for DataFrame of floats with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D']; some entries are missing\n\nA\n\n\n\n\n\n\n\n B\n\n\n\n\n\n\n\n C\n\n\n\n\n\n\n\n D ABwBzA0ljw -1.128865 -0.897161\n\n0.046603\n\n0.274997 DJiRzmbyQF\n\n0.728869\n\n0.233502\n\n0.722431 -0.890872 neMgPD5UBF\n\n0.486072 -1.027393 -0.031553\n\n1.449522 0yWA4n8VeX -1.937191 -1.142531\n\n0.805215 -0.462018 3slYUbbqU1\n\n0.153260\n\n1.164691\n\n1.489795 -0.545826 soujjZ0A08\n\n\n\n\n\n NaN\n\n\n\n\n\n NaN\n\n\n\n\n\n NaN\n\n\n\n\n\n NaN 7W6NLGsjB9\n\n\n\n\n\n NaN\n\n\n\n\n\n NaN\n\n\n\n\n\n NaN\n\n\n\n\n\n NaN ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n ...\n\n\n\n\n\n ...\n\n\n\n\n\n ... uhfeaNkCR1 -0.231210 -0.340472\n\n0.244717 -0.901590 n6p7GYuBIV -0.419052\n\n1.922721 -0.125361 -0.727717 ZhzAeY6p1y\n\n1.234374 -1.425359 -0.827038 -0.633189 uWdPsORyUh\n\n0.046738 -0.980445 -1.102965\n\n0.605503 3DJA6aN590 -0.091018 -1.684734 -1.100900\n\n0.215947 2GBPAzdbMk -2.883405 -1.021071\n\n1.209877\n\n1.633083 sHadBoyVHw -2.223032 -0.326384\n\n0.258931\n\n0.245517\n\n[30 rows x 4 columns]\n"},"func2": {"source file: ": "conftest6.py","line number: ": "42","func name: ": "bool_frame_with_na","func arg: ": "()","comments: ": "Fixture for DataFrame of booleans with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D']; some entries are missing\n\nA\n\n\n\n\n\nB\n\n\n\n\n\nC\n\n\n\n\n\nD zBZxY2IDGd\n\nFalse\n\nFalse\n\nFalse\n\nFalse IhBWBMWllt\n\nFalse\n\n True\n\n True\n\n True ctjdvZSR6R\n\n True\n\nFalse\n\n True\n\n True AVTujptmxb\n\nFalse\n\n True\n\nFalse\n\n True G9lrImrSWq\n\nFalse\n\nFalse\n\nFalse\n\n True sFFwdIUfz2\n\n\n\nNaN\n\n\n\nNaN\n\n\n\nNaN\n\n\n\nNaN s15ptEJnRb\n\n\n\nNaN\n\n\n\nNaN\n\n\n\nNaN\n\n\n\nNaN ...\n\n\n\n\n\n\n\n\n\n ...\n\n\n\n...\n\n\n\n...\n\n\n\n... UW41KkDyZ4\n\n True\n\n True\n\nFalse\n\nFalse l9l6XkOdqV\n\n True\n\nFalse\n\nFalse\n\nFalse X2MeZfzDYA\n\nFalse\n\n True\n\nFalse\n\nFalse xWkIKU7vfX\n\nFalse\n\n True\n\nFalse\n\n True QOhL6VmpGU\n\nFalse\n\nFalse\n\nFalse\n\n True 22PwkRJdat\n\nFalse\n\n True\n\nFalse\n\nFalse kfboQ3VeIK\n\n True\n\nFalse\n\n True\n\nFalse\n\n[30 rows x 4 columns]\n"},"func3": {"source file: ": "conftest6.py","line number: ": "76","func name: ": "int_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of ints with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D']\n\nA\n\nB\n\nC\n\nD vpBeWjM651\n\n1\n\n0\n\n1\n\n0 5JyxmrP1En -1\n\n0\n\n0\n\n0 qEDaoD49U2 -1\n\n1\n\n0\n\n0 m66TkTfsFe\n\n0\n\n0\n\n0\n\n0 EHPaNzEUFm -1\n\n0 -1\n\n0 fpRJCevQhi\n\n2\n\n0\n\n0\n\n0 OlQvnmfi3Q\n\n0\n\n0 -2\n\n0 ...\n\n\n\n\n\n\n\n.. .. .. .. uB1FPlz4uP\n\n0\n\n0\n\n0\n\n1 EcSe6yNzCU\n\n0\n\n0 -1\n\n0 L50VudaiI8 -1\n\n1 -2\n\n0 y3bpw4nwIp\n\n0 -1\n\n0\n\n0 H0RdLLwrCT\n\n1\n\n1\n\n0\n\n0 rY82K0vMwm\n\n0\n\n0\n\n0\n\n0 1OPIUjnkjk\n\n2\n\n0\n\n0\n\n0\n\n[30 rows x 4 columns]\n"},"func4": {"source file: ": "conftest6.py","line number: ": "107","func name: ": "datetime_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of floats with DatetimeIndex\n\nColumns are ['A', 'B', 'C', 'D']\n\nA\n\n\n\n\n\n\n\n B\n\n\n\n\n\n\n\n C\n\n\n\n\n\n\n\n D 2000-01-03 -1.122153\n\n0.468535\n\n0.122226\n\n1.693711 2000-01-04\n\n0.189378\n\n0.486100\n\n0.007864 -1.216052 2000-01-05\n\n0.041401 -0.835752 -0.035279 -0.414357 2000-01-06\n\n0.430050\n\n0.894352\n\n0.090719\n\n0.036939 2000-01-07 -0.620982 -0.668211 -0.706153\n\n1.466335 2000-01-10 -0.752633\n\n0.328434 -0.815325\n\n0.699674 2000-01-11 -2.236969\n\n0.615737 -0.829076 -1.196106 ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n ...\n\n\n\n\n\n ...\n\n\n\n\n\n ... 2000-02-03\n\n1.642618 -0.579288\n\n0.046005\n\n1.385249 2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351 2000-02-07 -2.656149 -0.601387\n\n1.410148\n\n0.444150 2000-02-08 -1.201881 -1.289040\n\n0.772992 -1.445300 2000-02-09\n\n1.377373\n\n0.398619\n\n1.008453 -0.928207 2000-02-10\n\n0.473194 -0.636677\n\n0.984058\n\n0.511519 2000-02-11 -0.965556\n\n0.408313 -1.312844 -0.381948\n\n[30 rows x 4 columns]\n"},"func5": {"source file: ": "conftest6.py","line number: ": "136","func name: ": "float_string_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of floats and strings with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D', 'foo'].\n\nA\n\n\n\n\n\n\n\n B\n\n\n\n\n\n\n\n C\n\n\n\n\n\n\n\n D\n\nfoo w3orJvq07g -1.594062 -1.084273 -1.252457\n\n0.356460\n\nbar PeukuVdmz2\n\n0.109855 -0.955086 -0.809485\n\n0.409747\n\nbar ahp2KvwiM8 -1.533729 -0.142519 -0.154666\n\n1.302623\n\nbar 3WSJ7BUCGd\n\n2.484964\n\n0.213829\n\n0.034778 -2.327831\n\nbar khdAmufk0U -0.193480 -0.743518 -0.077987\n\n0.153646\n\nbar LE2DZiFlrE -0.193566 -1.343194 -0.107321\n\n0.959978\n\nbar HJXSJhVn7b\n\n0.142590\n\n1.257603 -0.659409 -0.223844\n\nbar ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n ...\n\n\n\n\n\n ...\n\n\n\n\n\n ...\n\n... 9a1Vypttgw -1.316394\n\n1.601354\n\n0.173596\n\n1.213196\n\nbar h5d1gVFbEy\n\n0.609475\n\n1.106738 -0.155271\n\n0.294630\n\nbar mK9LsTQG92\n\n1.303613\n\n0.857040 -1.019153\n\n0.369468\n\nbar oOLksd9gKH\n\n0.558219 -0.134491 -0.289869 -0.951033\n\nbar 9jgoOjKyHg\n\n0.058270 -0.496110 -0.413212 -0.852659\n\nbar jZLDHclHAO\n\n0.096298\n\n1.267510\n\n0.549206 -0.005235\n\nbar lR0nxDp1C2 -2.119350 -0.794384\n\n0.544118\n\n0.145849\n\nbar\n\n[30 rows x 5 columns]\n"},"func6": {"source file: ": "conftest6.py","line number: ": "167","func name: ": "mixed_float_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of different float types with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D'].\n\nA\n\n\n\n\n\n\n\n B\n\n\n\n\n\n\n\n C\n\n\n\n\n\n\n\n D GI7bbDaEZe -0.237908 -0.246225 -0.468506\n\n0.752993 KGp9mFepzA -1.140809 -0.644046 -1.225586\n\n0.801588 VeVYLAb1l2 -1.154013 -1.677615\n\n0.690430 -0.003731 kmPME4WKhO\n\n0.979578\n\n0.998274 -0.776367\n\n0.897607 CPyopdXTiz\n\n0.048119 -0.257174\n\n0.836426\n\n0.111266 0kJZQndAj0\n\n0.274357 -0.281135 -0.344238\n\n0.834541 tqdwQsaHG8 -0.979716 -0.519897\n\n0.582031\n\n0.144710 ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n ...\n\n\n\n\n\n ...\n\n\n\n\n\n ... 7FhZTWILQj -2.906357\n\n1.261039 -0.780273 -0.537237 4pUDPM4eGq -2.042512 -0.464382 -0.382080\n\n1.132612 B8dUgUzwTi -1.506637 -0.364435\n\n1.087891\n\n0.297653 hErlVYjVv9\n\n1.477453 -0.495515 -0.713867\n\n1.438427 1BKN3o7YLs\n\n0.127535 -0.349812 -0.881836\n\n0.489827 9S4Ekn7zga\n\n1.445518 -2.095149\n\n0.031982\n\n0.373204 xN1dNn6OV6\n\n1.425017 -0.983995 -0.363281 -0.224502\n\n[30 rows x 4 columns]\n"},"func7": {"source file: ": "conftest6.py","line number: ": "201","func name: ": "mixed_int_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of different int types with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D'].\n\nA\n\nB\n\n\n\nC\n\n\n\nD mUrCZ67juP\n\n0\n\n1\n\n\n\n2\n\n\n\n2 rw99ACYaKS\n\n0\n\n1\n\n\n\n0\n\n\n\n0 7QsEcpaaVU\n\n0\n\n1\n\n\n\n1\n\n\n\n1 xkrimI2pcE\n\n0\n\n1\n\n\n\n0\n\n\n\n0 dz01SuzoS8\n\n0\n\n1\n\n255\n\n255 ccQkqOHX75 -1\n\n1\n\n\n\n0\n\n\n\n0 DN0iXaoDLd\n\n0\n\n1\n\n\n\n0\n\n\n\n0 ...\n\n\n\n\n\n\n\n.. ..\n\n...\n\n... Dfb141wAaQ\n\n1\n\n1\n\n254\n\n254 IPD8eQOVu5\n\n0\n\n1\n\n\n\n0\n\n\n\n0 CcaKulsCmv\n\n0\n\n1\n\n\n\n0\n\n\n\n0 rIBa8gu7E5\n\n0\n\n1\n\n\n\n0\n\n\n\n0 RP6peZmh5o\n\n0\n\n1\n\n\n\n1\n\n\n\n1 NMb9pipQWQ\n\n0\n\n1\n\n\n\n0\n\n\n\n0 PqgbJEzjib\n\n0\n\n1\n\n\n\n3\n\n\n\n3\n\n[30 rows x 4 columns]\n"},"func8": {"source file: ": "conftest6.py","line number: ": "235","func name: ": "mixed_type_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of float/int/string columns with RangeIndex Columns are ['a', 'b', 'c', 'float32', 'int32'].\n\n\n"},"func9": {"source file: ": "conftest6.py","line number: ": "253","func name: ": "timezone_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of date_range Series with different time zones\n\nColumns are ['A', 'B', 'C']; some entries are missing\n\nA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n B\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n C 0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00 1 2013-01-02\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n NaT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n NaT 2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n"},"func10": {"source file: ": "conftest6.py","line number: ": "277","func name: ": "uint64_frame","func arg: ": "()","comments: ": "Fixture for DataFrame with uint64 values\n\nColumns are ['A', 'B']\n"},"func11": {"source file: ": "conftest6.py","line number: ": "289","func name: ": "simple_frame","func arg: ": "()","comments: ": "Fixture for simple 3x3 DataFrame\n\nColumns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\none\n\ntwo\n\nthree a\n\n1.0\n\n2.0\n\n\n\n3.0 b\n\n4.0\n\n5.0\n\n\n\n6.0 c\n\n7.0\n\n8.0\n\n\n\n9.0\n"},"func12": {"source file: ": "conftest6.py","line number: ": "306","func name: ": "frame_of_index_cols","func arg: ": "()","comments: ": "Fixture for DataFrame of columns that can be used for indexing\n\nColumns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')]; 'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\nA\n\n\n\n\n\nB\n\nC\n\n\n\n\n\n\n\n D\n\n\n\n\n\n\n\n E\n\n(tuple, as, label) 0\n\nfoo\n\n\n\none\n\na\n\n0.608477 -0.012500\n\n\n\n\n\n\n\n\n\n -1.664297 1\n\nfoo\n\n\n\ntwo\n\nb -0.633460\n\n0.249614\n\n\n\n\n\n\n\n\n\n -0.364411 2\n\nfoo\n\nthree\n\nc\n\n0.615256\n\n2.154968\n\n\n\n\n\n\n\n\n\n -0.834666 3\n\nbar\n\n\n\none\n\nd\n\n0.234246\n\n1.085675\n\n\n\n\n\n\n\n\n\n\n\n0.718445 4\n\nbar\n\n\n\ntwo\n\ne\n\n0.533841 -0.005702\n\n\n\n\n\n\n\n\n\n -3.533912\n"}}{"func1": {"source file: ": "conftest7.py","line number: ": "5","func name: ": "orient","func arg: ": "(request)","comments: ": "Fixture for orients excluding the table format.\n\n\n"}}{"func1": {"source file: ": "conftest8.py","line number: ": "7","func name: ": "offset_types","func arg: ": "(request)","comments: ": "Fixture for all the datetime offsets available for a time series.\n\n\n"},"func2": {"source file: ": "conftest8.py","line number: ": "21","func name: ": "month_classes","func arg: ": "(request)","comments: ": "Fixture for month based datetime offsets available for a time series.\n\n\n"}}{"func1": {"source file: ": "conftest9.py","line number: ": "11","func name: ": "frame","func arg: ": "(float_frame)","comments: ": "Returns the first ten items in fixture \"float_frame\".\n\n\n"},"func2": {"source file: ": "conftest9.py","line number: ": "19","func name: ": "tsframe","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "conftest9.py","line number: ": "24","func name: ": "merge_cells","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "conftest9.py","line number: ": "29","func name: ": "df_ref","func arg: ": "(datapath)","comments: ": "Obtain the reference data from read_csv with the Python engine.\n\n\n"},"func5": {"source file: ": "conftest9.py","line number: ": "39","func name: ": "read_ext","func arg: ": "(request)","comments: ": "Valid extensions for reading Excel files.\n\n\n"},"func6": {"source file: ": "conftest9.py","line number: ": "47","func name: ": "check_for_file_leaks","func arg: ": "()","comments: ": "Fixture to run around every test to ensure that we are not leaking files.\n\nSee also -------- _test_decorators.check_file_leaks\n"}}{"func1": {"source file: ": "conftest10.py","line number: ": "34","func name: ": "pytest_addoption","func arg: ": "(parser)","comments: ": ""},"func2": {"source file: ": "conftest10.py","line number: ": "49","func name: ": "pytest_runtest_setup","func arg: ": "(item)","comments: ": ""},"func3": {"source file: ": "conftest10.py","line number: ": "72","func name: ": "configure_tests","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "conftest10.py","line number: ": "80","func name: ": "add_imports","func arg: ": "(doctest_namespace)","comments: ": ""},"func5": {"source file: ": "conftest10.py","line number: ": "86","func name: ": "spmatrix","func arg: ": "(request)","comments: ": ""},"func6": {"source file: ": "conftest10.py","line number: ": "93","func name: ": "axis","func arg: ": "(request)","comments: ": "Fixture for returning the axis numbers of a DataFrame.\n\n\n"},"func7": {"source file: ": "conftest10.py","line number: ": "104","func name: ": "axis_series","func arg: ": "(request)","comments: ": "Fixture for returning the axis numbers of a Series.\n\n\n"},"func8": {"source file: ": "conftest10.py","line number: ": "112","func name: ": "ip","func arg: ": "()","comments: ": "Get an instance of IPython.InteractiveShell.\n\nWill raise a skip if IPython is not installed.\n"},"func9": {"source file: ": "conftest10.py","line number: ": "126","func name: ": "observed","func arg: ": "(request)","comments: ": "Pass in the observed keyword to groupby for [True, False] This indicates whether categoricals should return values for values which are not in the grouper [False / None], or only values which appear in the grouper [True]. [None] is supported for future compatibility if we decide to change the default (and would need to warn if this parameter is not passed).\n\n\n"},"func10": {"source file: ": "conftest10.py","line number: ": "139","func name: ": "ordered_fixture","func arg: ": "(request)","comments: ": "Boolean 'ordered' parameter for Categorical.\n\n\n"},"func11": {"source file: ": "conftest10.py","line number: ": "165","func name: ": "all_arithmetic_operators","func arg: ": "(request)","comments: ": "Fixture for dunder names for common arithmetic operations.\n\n\n"},"func12": {"source file: ": "conftest10.py","line number: ": "190","func name: ": "all_arithmetic_functions","func arg: ": "(request)","comments: ": "Fixture for operator and roperator arithmetic functions.\n\nNotes ----- This includes divmod and rdivmod, whereas all_arithmetic_operators does not.\n"},"func13": {"source file: ": "conftest10.py","line number: ": "217","func name: ": "all_numeric_reductions","func arg: ": "(request)","comments: ": "Fixture for numeric reduction names.\n\n\n"},"func14": {"source file: ": "conftest10.py","line number: ": "228","func name: ": "all_boolean_reductions","func arg: ": "(request)","comments: ": "Fixture for boolean reduction names.\n\n\n"},"func15": {"source file: ": "conftest10.py","line number: ": "239","func name: ": "cython_table_items","func arg: ": "(request)","comments: ": ""},"func16": {"source file: ": "conftest10.py","line number: ": "243","func name: ": "_get_cython_table_params","func arg: ": "(ndframe, func_names_and_expected)","comments: ": "Combine frame, functions from SelectionMixin._cython_table keys and expected result.\n\nParameters ---------- ndframe : DataFrame or Series func_names_and_expected : Sequence of two items The first item is a name of a NDFrame method ('sum', 'prod') etc. The second item is the expected return value.\n##### Returns\n"},"func17": {"source file: ": "conftest10.py","line number: ": "272","func name: ": "all_compare_operators","func arg: ": "(request)","comments: ": "Fixture for dunder names for common compare operations\n\n* >= * > * == * != * < * <=\n"},"func18": {"source file: ": "conftest10.py","line number: ": "287","func name: ": "compare_operators_no_eq_ne","func arg: ": "(request)","comments: ": "Fixture for dunder names for compare operations except == and !=\n\n* >= * > * < * <=\n"},"func19": {"source file: ": "conftest10.py","line number: ": "302","func name: ": "all_logical_operators","func arg: ": "(request)","comments: ": "Fixture for dunder names for common logical operations\n\n* | * & * ^\n"},"func20": {"source file: ": "conftest10.py","line number: ": "314","func name: ": "compression","func arg: ": "(request)","comments: ": "Fixture for trying common compression types in compression tests.\n\n\n"},"func21": {"source file: ": "conftest10.py","line number: ": "322","func name: ": "compression_only","func arg: ": "(request)","comments: ": "Fixture for trying common compression types in compression tests excluding uncompressed case.\n\n\n"},"func22": {"source file: ": "conftest10.py","line number: ": "331","func name: ": "writable","func arg: ": "(request)","comments: ": "Fixture that an array is writable.\n\n\n"},"func23": {"source file: ": "conftest10.py","line number: ": "339","func name: ": "datetime_tz_utc","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "conftest10.py","line number: ": "344","func name: ": "utc_fixture","func arg: ": "(request)","comments: ": "Fixture to provide variants of UTC timezone strings and tzinfo objects.\n\n\n"},"func25": {"source file: ": "conftest10.py","line number: ": "352","func name: ": "join_type","func arg: ": "(request)","comments: ": "Fixture for trying all types of join operations.\n\n\n"},"func26": {"source file: ": "conftest10.py","line number: ": "360","func name: ": "strict_data_files","func arg: ": "(pytestconfig)","comments: ": ""},"func27": {"source file: ": "conftest10.py","line number: ": "365","func name: ": "datapath","func arg: ": "(strict_data_files)","comments: ": "Get the path to a data file.\n\nParameters ---------- path : str Path to the file, relative to ``pandas/tests/``\n##### Returns\n"},"func28": {"source file: ": "conftest10.py","line number: ": "400","func name: ": "iris","func arg: ": "(datapath)","comments: ": "The iris dataset as a DataFrame.\n\n\n"},"func29": {"source file: ": "conftest10.py","line number: ": "408","func name: ": "nselect_method","func arg: ": "(request)","comments: ": "Fixture for trying all nselect methods.\n\n\n"},"func30": {"source file: ": "conftest10.py","line number: ": "416","func name: ": "closed","func arg: ": "(request)","comments: ": "Fixture for trying all interval closed parameters.\n\n\n"},"func31": {"source file: ": "conftest10.py","line number: ": "424","func name: ": "other_closed","func arg: ": "(request)","comments: ": "Secondary closed fixture to allow parametrizing over all pairs of closed.\n\n\n"},"func32": {"source file: ": "conftest10.py","line number: ": "432","func name: ": "nulls_fixture","func arg: ": "(request)","comments: ": "Fixture for each null type in pandas.\n\n\n"},"func33": {"source file: ": "conftest10.py","line number: ": "443","func name: ": "unique_nulls_fixture","func arg: ": "(request)","comments: ": "Fixture for each null type in pandas, each null type exactly once.\n\n\n"},"func34": {"source file: ": "conftest10.py","line number: ": "475","func name: ": "tz_naive_fixture","func arg: ": "(request)","comments: ": "Fixture for trying timezones including default (None): {0}\n\n\n"},"func35": {"source file: ": "conftest10.py","line number: ": "484","func name: ": "tz_aware_fixture","func arg: ": "(request)","comments: ": "Fixture for trying explicit timezones: {0}\n\n\n"},"func36": {"source file: ": "conftest10.py","line number: ": "531","func name: ": "string_dtype","func arg: ": "(request)","comments: ": "Parametrized fixture for string dtypes.\n\n* str * 'str' * 'U'\n"},"func37": {"source file: ": "conftest10.py","line number: ": "543","func name: ": "bytes_dtype","func arg: ": "(request)","comments: ": "Parametrized fixture for bytes dtypes.\n\n* bytes * 'bytes'\n"},"func38": {"source file: ": "conftest10.py","line number: ": "554","func name: ": "object_dtype","func arg: ": "(request)","comments: ": "Parametrized fixture for object dtypes.\n\n* object * 'object'\n"},"func39": {"source file: ": "conftest10.py","line number: ": "565","func name: ": "datetime64_dtype","func arg: ": "(request)","comments: ": "Parametrized fixture for datetime64 dtypes.\n\n* 'datetime64[ns]' * 'M8[ns]'\n"},"func40": {"source file: ": "conftest10.py","line number: ": "576","func name: ": "timedelta64_dtype","func arg: ": "(request)","comments: ": "Parametrized fixture for timedelta64 dtypes.\n\n* 'timedelta64[ns]' * 'm8[ns]'\n"},"func41": {"source file: ": "conftest10.py","line number: ": "587","func name: ": "float_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for float dtypes.\n\n* float * 'float32' * 'float64'\n"},"func42": {"source file: ": "conftest10.py","line number: ": "599","func name: ": "complex_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for complex dtypes.\n\n* complex * 'complex64' * 'complex128'\n"},"func43": {"source file: ": "conftest10.py","line number: ": "611","func name: ": "sint_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for signed integer dtypes.\n\n* int * 'int8' * 'int16' * 'int32' * 'int64'\n"},"func44": {"source file: ": "conftest10.py","line number: ": "625","func name: ": "uint_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for unsigned integer dtypes.\n\n* 'uint8' * 'uint16' * 'uint32' * 'uint64'\n"},"func45": {"source file: ": "conftest10.py","line number: ": "638","func name: ": "any_int_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for any integer dtype.\n\n* int * 'int8' * 'uint8' * 'int16' * 'uint16' * 'int32' * 'uint32' * 'int64' * 'uint64'\n"},"func46": {"source file: ": "conftest10.py","line number: ": "656","func name: ": "any_nullable_int_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for any nullable integer dtype.\n\n* 'UInt8' * 'Int8' * 'UInt16' * 'Int16' * 'UInt32' * 'Int32' * 'UInt64' * 'Int64'\n"},"func47": {"source file: ": "conftest10.py","line number: ": "674","func name: ": "any_real_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for any (purely) real numeric dtype.\n\n* int * 'int8' * 'uint8' * 'int16' * 'uint16' * 'int32' * 'uint32' * 'int64' * 'uint64' * float * 'float32' * 'float64'\n"},"func48": {"source file: ": "conftest10.py","line number: ": "695","func name: ": "any_numpy_dtype","func arg: ": "(request)","comments: ": "Parameterized fixture for all numpy dtypes.\n\n* bool * 'bool' * int * 'int8' * 'uint8' * 'int16' * 'uint16' * 'int32' * 'uint32' * 'int64' * 'uint64' * float * 'float32' * 'float64' * complex * 'complex64' * 'complex128' * str * 'str' * 'U' * bytes * 'bytes' * 'datetime64[ns]' * 'M8[ns]' * 'timedelta64[ns]' * 'm8[ns]' * object * 'object'\n"},"func49": {"source file: ": "conftest10.py","line number: ": "762","func name: ": "any_skipna_inferred_dtype","func arg: ": "(request)","comments: ": "Fixture for all inferred dtypes from _libs.lib.infer_dtype\n\nThe covered (inferred) types are: * 'string' * 'empty' * 'bytes' * 'mixed' * 'mixed-integer' * 'mixed-integer-float' * 'floating' * 'integer' * 'decimal' * 'boolean' * 'datetime64' * 'datetime' * 'date' * 'timedelta' * 'time' * 'period' * 'interval'\n##### Returns\n* **inferred_dtype **: str\nThe string for the inferred dtype from _libs.lib.infer_dtype\n\n* **values **: np.ndarray\nAn array of object dtype that will be inferred to have\n`inferred_dtype`\n\n* **>>> def test_something(any_skipna_inferred_dtype)**: \n\n"},"func50": {"source file: ": "conftest10.py","line number: ": "816","func name: ": "tick_classes","func arg: ": "(request)","comments: ": "Fixture for Tick based datetime offsets available for a time series.\n\n\n"},"func51": {"source file: ": "conftest10.py","line number: ": "861","func name: ": "float_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of floats with index of unique strings\n\nColumns are ['A', 'B', 'C', 'D'].\n\nA\n\n\n\n\n\n\n\n B\n\n\n\n\n\n\n\n C\n\n\n\n\n\n\n\n D P7GACiRnxd -0.465578 -0.361863\n\n0.886172 -0.053465 qZKh6afn8n -0.466693 -0.373773\n\n0.266873\n\n1.673901 tkp0r6Qble\n\n0.148691 -0.059051\n\n0.174817\n\n1.598433 wP70WOCtv8\n\n0.133045 -0.581994 -0.992240\n\n0.261651 M2AeYQMnCz -1.207959 -0.185775\n\n0.588206\n\n0.563938 QEPzyGDYDo -0.381843 -0.758281\n\n0.502575 -0.565053 r78Jwns6dn -0.653707\n\n0.883127\n\n0.682199\n\n0.206159 ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n ...\n\n\n\n\n\n ...\n\n\n\n\n\n ... IHEGx9NO0T -0.277360\n\n0.113021 -1.018314\n\n0.196316 lPMj8K27FA -1.313667 -0.604776 -1.305618 -0.863999 qa66YMWQa5\n\n1.110525\n\n0.475310 -0.747865\n\n0.032121 yOa0ATsmcE -0.431457\n\n0.067094\n\n0.096567 -0.264962 65znX3uRNG\n\n1.528446\n\n0.160416 -0.109635 -0.032987 eCOBvKqf3e\n\n0.235281\n\n1.622222\n\n0.781255\n\n0.392871 xSucinXxuV -1.263557\n\n0.252799 -0.552247\n\n0.400426\n\n[30 rows x 4 columns]\n"},"func52": {"source file: ": "conftest10.py","line number: ": "890","func name: ": "index_or_series","func arg: ": "(request)","comments: ": "Fixture to parametrize over Index and Series, made necessary by a mypy bug, giving an error\n\nList item 0 has incompatible type \"Type[Series]\"; expected \"Type[PandasObject]\"\n\nSee GH#29725\n"},"func53": {"source file: ": "conftest10.py","line number: ": "903","func name: ": "dict_subclass","func arg: ": "()","comments: ": "Fixture for a dictionary subclass.\n\n\n"},"func54": {"source file: ": "conftest10.py","line number: ": "916","func name: ": "non_mapping_dict_subclass","func arg: ": "()","comments: ": "Fixture for a non-mapping dictionary subclass.\n\n\n"}}{"func1": {"source file: ": "conftest11.py","line number: ": "9","func name: ": "dtype","func arg: ": "()","comments: ": "A fixture providing the ExtensionDtype to validate.\n\n\n"},"func2": {"source file: ": "conftest11.py","line number: ": "15","func name: ": "data","func arg: ": "()","comments: ": "Length-100 array for this type.\n\n* data[0] and data[1] should both be non missing * data[0] and data[1] should not be equal\n"},"func3": {"source file: ": "conftest11.py","line number: ": "25","func name: ": "data_for_twos","func arg: ": "()","comments: ": "Length-100 array in which all the elements are two.\n\n\n"},"func4": {"source file: ": "conftest11.py","line number: ": "31","func name: ": "data_missing","func arg: ": "()","comments: ": "Length-2 array with [NA, Valid]\n\n\n"},"func5": {"source file: ": "conftest11.py","line number: ": "37","func name: ": "all_data","func arg: ": "(request, data, data_missing)","comments: ": "Parametrized fixture giving 'data' and 'data_missing'\n\n\n"},"func6": {"source file: ": "conftest11.py","line number: ": "46","func name: ": "data_repeated","func arg: ": "(data)","comments: ": "Generate many datasets.\n\nParameters ---------- data : fixture implementing `data`\n##### Returns\n* **Callable[[int], Generator]**: A callable that takes a `count` argument and\nreturns a generator yielding `count` datasets.\n\n"},"func7": {"source file: ": "conftest11.py","line number: ": "69","func name: ": "data_for_sorting","func arg: ": "()","comments: ": "Length-3 array with a known sort order.\n\nThis should be three items [B, C, A] with A < B < C\n"},"func8": {"source file: ": "conftest11.py","line number: ": "79","func name: ": "data_missing_for_sorting","func arg: ": "()","comments: ": "Length-3 array with a known sort order.\n\nThis should be three items [B, NA, A] with A < B and NA missing.\n"},"func9": {"source file: ": "conftest11.py","line number: ": "89","func name: ": "na_cmp","func arg: ": "()","comments: ": "Binary operator for comparing NA values.\n\nShould return a function of two arguments that returns True if both arguments are (scalar) NA for your type.\n\nBy default, uses ``operator.is_``\n"},"func10": {"source file: ": "conftest11.py","line number: ": "101","func name: ": "na_value","func arg: ": "()","comments: ": "The scalar missing value for this type. Default 'None'\n\n\n"},"func11": {"source file: ": "conftest11.py","line number: ": "107","func name: ": "data_for_grouping","func arg: ": "()","comments: ": "Data for factorization, grouping, and unique tests.\n\nExpected to be like [B, B, NA, NA, A, A, B, C]\n\nWhere A < B < C and NA is missing\n"},"func12": {"source file: ": "conftest11.py","line number: ": "118","func name: ": "box_in_series","func arg: ": "(request)","comments: ": "Whether to box the data in a Series\n\n\n"},"func13": {"source file: ": "conftest11.py","line number: ": "132","func name: ": "groupby_apply_op","func arg: ": "(request)","comments: ": "Functions to test groupby.apply().\n\n\n"},"func14": {"source file: ": "conftest11.py","line number: ": "140","func name: ": "as_frame","func arg: ": "(request)","comments: ": "Boolean fixture to support Series and Series.to_frame() comparison testing.\n\n\n"},"func15": {"source file: ": "conftest11.py","line number: ": "148","func name: ": "as_series","func arg: ": "(request)","comments: ": "Boolean fixture to support arr and Series(arr) comparison testing.\n\n\n"},"func16": {"source file: ": "conftest11.py","line number: ": "156","func name: ": "use_numpy","func arg: ": "(request)","comments: ": "Boolean fixture to support comparison testing of ExtensionDtype array and numpy array.\n\n\n"},"func17": {"source file: ": "conftest11.py","line number: ": "165","func name: ": "fillna_method","func arg: ": "(request)","comments: ": "Parametrized fixture giving method parameters 'ffill' and 'bfill' for Series.fillna(method=<method>) testing.\n\n\n"},"func18": {"source file: ": "conftest11.py","line number: ": "174","func name: ": "as_array","func arg: ": "(request)","comments: ": "Boolean fixture to support ExtensionDtype _from_sequence method testing.\n\n\n"}}{"func1": {"source file: ": "conftest12.py","line number: ": "22","func name: ": "numeric_indexing_engine_type_and_dtype","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "conftest13.py","line number: ": "11","func name: ": "tips_file","func arg: ": "(datapath)","comments: ": "Path to the tips dataset\n\n\n"},"func2": {"source file: ": "conftest13.py","line number: ": "17","func name: ": "jsonl_file","func arg: ": "(datapath)","comments: ": "Path a JSONL dataset\n\n\n"},"func3": {"source file: ": "conftest13.py","line number: ": "23","func name: ": "salaries_table","func arg: ": "(datapath)","comments: ": "DataFrame with the salaries dataset\n\n\n"},"func4": {"source file: ": "conftest13.py","line number: ": "29","func name: ": "s3_resource","func arg: ": "(tips_file, jsonl_file)","comments: ": "Fixture for mocking S3 interaction.\n\nThe primary bucket name is \"pandas-test\". The following datasets are loaded.\n\n- tips.csv\n\n- tips.csv.gz\n\n- tips.csv.bz2\n\n- items.jsonl\n\nA private bucket \"cant_get_it\" is also created. The boto3 s3 resource is yielded by the fixture.\n"}}{"func1": {"source file: ": "conftest14.py","line number: ": "5","func name: ": "check_dtype","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "conftest14.py","line number: ": "10","func name: ": "check_exact","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "conftest14.py","line number: ": "15","func name: ": "check_index_type","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "conftest14.py","line number: ": "20","func name: ": "check_less_precise","func arg: ": "(request)","comments: ": ""},"func5": {"source file: ": "conftest14.py","line number: ": "25","func name: ": "check_categorical","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "conftest15.py","line number: ": "7","func name: ": "setup_path","func arg: ": "()","comments: ": "Fixture for setup path\n\n\n"},"func2": {"source file: ": "conftest15.py","line number: ": "13","func name: ": "setup_mode","func arg: ": "()","comments: ": "Reset testing mode fixture\n\n\n"}}{"func1": {"source file: ": "conftest16.py","line number: ": "5","func name: ": "allow_fill","func arg: ": "(request)","comments: ": "Boolean 'allow_fill' parameter for Categorical.take\n\n\n"}}{"func1": {"source file: ": "conftest17.py","line number: ": "9","func name: ": "idx","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "conftest17.py","line number: ": "28","func name: ": "idx_dup","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "conftest17.py","line number: ": "46","func name: ": "index_names","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "conftest17.py","line number: ": "53","func name: ": "holder","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "conftest17.py","line number: ": "59","func name: ": "compat_props","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "conftest17.py","line number: ": "65","func name: ": "narrow_multi_index","func arg: ": "()","comments: ": "Return a MultiIndex that is narrower than the display (<80 characters).\n\n\n"},"func7": {"source file: ": "conftest17.py","line number: ": "76","func name: ": "wide_multi_index","func arg: ": "()","comments: ": "Return a MultiIndex that is wider than the display (>80 characters).\n\n\n"}}{"func1": {"source file: ": "conftest18.py","line number: ": "7","func name: ": "raw","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "conftest18.py","line number: ": "23","func name: ": "win_types","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "conftest18.py","line number: ": "28","func name: ": "win_types_special","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "conftest18.py","line number: ": "35","func name: ": "arithmetic_win_operators","func arg: ": "(request)","comments: ": ""},"func5": {"source file: ": "conftest18.py","line number: ": "40","func name: ": "closed","func arg: ": "(request)","comments: ": ""},"func6": {"source file: ": "conftest18.py","line number: ": "45","func name: ": "center","func arg: ": "(request)","comments: ": ""},"func7": {"source file: ": "conftest18.py","line number: ": "50","func name: ": "min_periods","func arg: ": "(request)","comments: ": ""},"func8": {"source file: ": "conftest18.py","line number: ": "55","func name: ": "parallel","func arg: ": "(request)","comments: ": "parallel keyword argument for numba.jit\n\n\n"},"func9": {"source file: ": "conftest18.py","line number: ": "61","func name: ": "nogil","func arg: ": "(request)","comments: ": "nogil keyword argument for numba.jit\n\n\n"},"func10": {"source file: ": "conftest18.py","line number: ": "67","func name: ": "nopython","func arg: ": "(request)","comments: ": "nopython keyword argument for numba.jit\n\n\n"},"func11": {"source file: ": "conftest18.py","line number: ": "75","func name: ": "engine","func arg: ": "(request)","comments: ": "engine keyword argument for rolling.apply\n\n\n"},"func12": {"source file: ": "conftest18.py","line number: ": "87","func name: ": "engine_and_raw","func arg: ": "(request)","comments: ": "engine and raw keyword arguments for rolling.apply\n\n\n"}}{"func1": {"source file: ": "conftest19.py","line number: ": "11","func name: ": "id_func","func arg: ": "(x)","comments: ": ""},"func2": {"source file: ": "conftest19.py","line number: ": "23","func name: ": "one","func arg: ": "(request)","comments: ": "Several variants of integer value 1. The zero-dim integer array behaves like an integer.\n\nThis fixture can be used to check that datetimelike indexes handle addition and subtraction of integers and zero-dimensional arrays of integers.\n\nExamples -------- >>> dti = pd.date_range('2016-01-01', periods=2, freq='H') >>> dti DatetimeIndex(['2016-01-01 00:00:00', '2016-01-01 01:00:00'], dtype='datetime64[ns]', freq='H') >>> dti + one DatetimeIndex(['2016-01-01 01:00:00', '2016-01-01 02:00:00'], dtype='datetime64[ns]', freq='H')\n"},"func3": {"source file: ": "conftest19.py","line number: ": "59","func name: ": "zero","func arg: ": "(request)","comments: ": "Several types of scalar zeros and length 5 vectors of zeros.\n\nThis fixture can be used to check that numeric-dtype indexes handle division by any zero numeric-dtype.\n\nUses vector of length 5 for broadcasting with `numeric_idx` fixture, which creates numeric-dtype vectors also of length 5.\n\nExamples -------- >>> arr = pd.RangeIndex(5) >>> arr / zeros Float64Index([nan, inf, inf, inf, inf], dtype='float64')\n"},"func4": {"source file: ": "conftest19.py","line number: ": "91","func name: ": "numeric_idx","func arg: ": "(request)","comments: ": "Several types of numeric-dtypes Index objects\n\n\n"},"func5": {"source file: ": "conftest19.py","line number: ": "110","func name: ": "scalar_td","func arg: ": "(request)","comments: ": "Several variants of Timedelta scalars representing 5 minutes and 4 seconds\n\n\n"},"func6": {"source file: ": "conftest19.py","line number: ": "128","func name: ": "three_days","func arg: ": "(request)","comments: ": "Several timedelta-like and DateOffset objects that each represent a 3-day timedelta\n\n\n"},"func7": {"source file: ": "conftest19.py","line number: ": "147","func name: ": "two_hours","func arg: ": "(request)","comments: ": "Several timedelta-like and DateOffset objects that each represent a 2-hour timedelta\n\n\n"},"func8": {"source file: ": "conftest19.py","line number: ": "170","func name: ": "not_hourly","func arg: ": "(request)","comments: ": "Several timedelta-like and DateOffset instances that are _not_ compatible with Hourly frequencies.\n\n\n"},"func9": {"source file: ": "conftest19.py","line number: ": "186","func name: ": "not_daily","func arg: ": "(request)","comments: ": "Several timedelta-like and DateOffset instances that are _not_ compatible with Daily frequencies.\n\n\n"},"func10": {"source file: ": "conftest19.py","line number: ": "202","func name: ": "mismatched_freq","func arg: ": "(request)","comments: ": "Several timedelta-like and DateOffset instances that are _not_ compatible with Monthly or Annual frequencies.\n\n\n"},"func11": {"source file: ": "conftest19.py","line number: ": "214","func name: ": "box","func arg: ": "(request)","comments: ": "Several array-like containers that should have effectively identical behavior with respect to arithmetic operations.\n\n\n"},"func12": {"source file: ": "conftest19.py","line number: ": "231","func name: ": "box_df_fail","func arg: ": "(request)","comments: ": "Fixture equivalent to `box` fixture but xfailing the DataFrame case.\n\n\n"},"func13": {"source file: ": "conftest19.py","line number: ": "239","func name: ": "box_with_array","func arg: ": "(request)","comments: ": "Fixture to test behavior for Index, Series, DataFrame, and pandas Array classes\n\n\n"}}{"func1": {"source file: ": "conftest20.py","line number: ": "48","func name: ": "csv_dir_path","func arg: ": "(datapath)","comments: ": "The directory path to the data files needed for parser tests.\n\n\n"},"func2": {"source file: ": "conftest20.py","line number: ": "56","func name: ": "csv1","func arg: ": "(csv_dir_path)","comments: ": "The path to the data file \"test1.csv\" needed for parser tests.\n\n\n"},"func3": {"source file: ": "conftest20.py","line number: ": "77","func name: ": "all_parsers","func arg: ": "(request)","comments: ": "Fixture all of the CSV parsers.\n\n\n"},"func4": {"source file: ": "conftest20.py","line number: ": "85","func name: ": "c_parser_only","func arg: ": "(request)","comments: ": "Fixture all of the CSV parsers using the C engine.\n\n\n"},"func5": {"source file: ": "conftest20.py","line number: ": "93","func name: ": "python_parser_only","func arg: ": "(request)","comments: ": "Fixture all of the CSV parsers using the Python engine.\n\n\n"},"func6": {"source file: ": "conftest20.py","line number: ": "111","func name: ": "utf_value","func arg: ": "(request)","comments: ": "Fixture for all possible integer values for a UTF encoding.\n\n\n"},"func7": {"source file: ": "conftest20.py","line number: ": "119","func name: ": "encoding_fmt","func arg: ": "(request)","comments: ": "Fixture for all possible string formats of a UTF encoding.\n\n\n"}}{"func1": {"source file: ": "conftest21.py","line number: ": "7","func name: ": "datetime_series","func arg: ": "()","comments: ": "Fixture for Series of floats with DatetimeIndex\n\n\n"},"func2": {"source file: ": "conftest21.py","line number: ": "17","func name: ": "string_series","func arg: ": "()","comments: ": "Fixture for Series of floats with Index of unique strings\n\n\n"},"func3": {"source file: ": "conftest21.py","line number: ": "27","func name: ": "object_series","func arg: ": "()","comments: ": "Fixture for Series of dtype object with Index of unique strings\n\n\n"}}{"func1": {"source file: ": "conftest22.py","line number: ": "10","func name: ": "mframe","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "conftest22.py","line number: ": "20","func name: ": "df","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "conftest22.py","line number: ": "32","func name: ": "ts","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "conftest22.py","line number: ": "37","func name: ": "tsd","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "conftest22.py","line number: ": "42","func name: ": "tsframe","func arg: ": "(tsd)","comments: ": ""},"func6": {"source file: ": "conftest22.py","line number: ": "47","func name: ": "df_mixed_floats","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "conftest22.py","line number: ": "59","func name: ": "three_group","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "conftest22.py","line number: ": "109","func name: ": "reduction_func","func arg: ": "(request)","comments: ": "yields the string names of all groupby reduction functions, one at a time.\n\n\n"},"func9": {"source file: ": "conftest22.py","line number: ": "116","func name: ": "transformation_func","func arg: ": "(request)","comments: ": "yields the string names of all groupby transformation functions.\n\n\n"},"func10": {"source file: ": "conftest22.py","line number: ": "122","func name: ": "groupby_func","func arg: ": "(request)","comments: ": "yields both aggregation and transformation functions.\n\n\n"}}{"func1": {"source file: ": "console1.py","line number: ": "8","func name: ": "get_console_size","func arg: ": "()","comments: ": "Return console size as tuple = (width, height).\n\n\n"},"func2": {"source file: ": "console1.py","line number: ": "53","func name: ": "in_interactive_session","func arg: ": "()","comments: ": "Check if we're running in an interactive shell.\n\n\n##### Returns\n"},"func3": {"source file: ": "console1.py","line number: ": "77","func name: ": "in_ipython_frontend","func arg: ": "()","comments: ": "Check if we're inside an an IPython zmq frontend.\n\n\n##### Returns\n"}}{"func1": {"source file: ": "construction1.py","line number: ": "56","func name: ": "arrays_to_mgr","func arg: ": "(arrays, arr_names, index, columns, dtype)","comments: ": "Segregate Series based on type and coerce into matrices.\n\nNeeds to handle a lot of exceptional cases.\n"},"func2": {"source file: ": "construction1.py","line number: ": "77","func name: ": "masked_rec_array_to_mgr","func arg: ": "(data, index, columns, dtype, copy)","comments: ": "Extract from a masked rec array and create the manager.\n\n\n"},"func3": {"source file: ": "construction1.py","line number: ": "123","func name: ": "init_ndarray","func arg: ": "(values, index, columns, dtype, copy)","comments: ": ""},"func4": {"source file: ": "construction1.py","line number: ": "213","func name: ": "init_dict","func arg: ": "(data, index, columns, dtype)","comments: ": "Segregate Series based on type and coerce into matrices. Needs to handle a lot of exceptional cases.\n\n\n"},"func5": {"source file: ": "construction1.py","line number: ": "260","func name: ": "prep_ndarray","func arg: ": "(values, copy)","comments: ": ""},"func6": {"source file: ": "construction1.py","line number: ": "300","func name: ": "_homogenize","func arg: ": "(data, index, dtype)","comments: ": ""},"func7": {"source file: ": "construction1.py","line number: ": "331","func name: ": "extract_index","func arg: ": "(data)","comments: ": ""},"func8": {"source file: ": "construction1.py","line number: ": "385","func name: ": "reorder_arrays","func arg: ": "(arrays, arr_columns, columns)","comments: ": ""},"func9": {"source file: ": "construction1.py","line number: ": "399","func name: ": "get_names_from_index","func arg: ": "(data)","comments: ": ""},"func10": {"source file: ": "construction1.py","line number: ": "417","func name: ": "_get_axes","func arg: ": "(N, K, index, columns)","comments: ": ""},"func11": {"source file: ": "construction1.py","line number: ": "437","func name: ": "to_arrays","func arg: ": "(data, columns, coerce_float, dtype)","comments: ": "Return list of arrays, columns.\n\n\n"},"func12": {"source file: ": "construction1.py","line number: ": "488","func name: ": "_list_to_arrays","func arg: ": "(data, columns, coerce_float, dtype)","comments: ": ""},"func13": {"source file: ": "construction1.py","line number: ": "504","func name: ": "_list_of_series_to_arrays","func arg: ": "(data, columns, coerce_float, dtype)","comments: ": ""},"func14": {"source file: ": "construction1.py","line number: ": "537","func name: ": "_list_of_dict_to_arrays","func arg: ": "(data, columns, coerce_float, dtype)","comments: ": "Convert list of dicts to numpy arrays\n\nif `columns` is not passed, column names are inferred from the records\n\n- for OrderedDict and dicts, the column names match the key insertion-order from the first record to the last.\n\n- For other kinds of dict-likes, the keys are lexically sorted.\n\nParameters ---------- data : iterable collection of records (OrderedDict, dict) columns: iterables or None coerce_float : bool dtype : np.dtype\n##### Returns\n"},"func15": {"source file: ": "construction1.py","line number: ": "574","func name: ": "_convert_object_array","func arg: ": "(content, columns, coerce_float, dtype)","comments: ": ""},"func16": {"source file: ": "construction1.py","line number: ": "601","func name: ": "sanitize_index","func arg: ": "(data, index, copy)","comments: ": "Sanitize an index type to return an ndarray of the underlying, pass through a non-Index.\n\n\n"}}{"func1": {"source file: ": "construction2.py","line number: ": "55","func name: ": "array","func arg: ": "(data, dtype, copy)","comments: ": "Create an array.\n\n.. versionadded:: 0.24.0\n\nParameters ---------- data : Sequence of objects The scalars inside `data` should be instances of the scalar type for `dtype`. It's expected that `data` represents a 1-dimensional array of data.\n\nWhen `data` is an Index or Series, the underlying array will be extracted from `data`.\n\ndtype : str, np.dtype, or ExtensionDtype, optional The dtype to use for the array. This may be a NumPy dtype or an extension type registered with pandas using :meth:`pandas.api.extensions.register_extension_dtype`.\n\nIf not specified, there are two possibilities:\n\n1. When `data` is a :class:`Series`, :class:`Index`, or :class:`ExtensionArray`, the `dtype` will be taken from the data. 2. Otherwise, pandas will attempt to infer the `dtype` from the data.\n\nNote that when `data` is a NumPy array, ``data.dtype`` is *not* used for inferring the array type. This is because NumPy cannot represent all the types of data that can be held in extension arrays.\n\nCurrently, pandas will infer an extension dtype for sequences of\n\n============================== ===================================== Scalar Type\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArray Type ============================== ===================================== :class:`pandas.Interval`\n\n\n\n\n\n :class:`pandas.arrays.IntervalArray` :class:`pandas.Period`\n\n\n\n\n\n\n\n :class:`pandas.arrays.PeriodArray` :class:`datetime.datetime`\n\n\n\n :class:`pandas.arrays.DatetimeArray` :class:`datetime.timedelta`\n\n\n\n:class:`pandas.arrays.TimedeltaArray` :class:`int`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n :class:`pandas.arrays.IntegerArray` :class:`str`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n :class:`pandas.arrays.StringArray` :class:`bool`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:class:`pandas.arrays.BooleanArray` ============================== =====================================\n\nFor all other cases, NumPy's usual inference rules will be used.\n\n.. versionchanged:: 1.0.0\n\nPandas infers nullable-integer dtype for integer data, string dtype for string data, and nullable-boolean dtype for boolean data.\n\ncopy : bool, default True Whether to copy the data, even if not necessary. Depending on the type of `data`, creating the new array may require copying data, even if ``copy=False``.\n##### Returns\n"},"func2": {"source file: ": "construction2.py","line number: ": "337","func name: ": "extract_array","func arg: ": "(obj, extract_numpy)","comments: ": "Extract the ndarray or ExtensionArray from a Series or Index.\n\nFor all other types, `obj` is just returned as is.\n\nParameters ---------- obj : object For Series / Index, the underlying ExtensionArray is unboxed. For Numpy-backed ExtensionArrays, the ndarray is extracted.\n\nextract_numpy : bool, default False Whether to extract the ndarray from a PandasArray\n##### Returns\n* **arr **: object\n\n* **Categories (3, object)**: [a, b, c]\n\n* **Length**: 3, dtype\n\n"},"func3": {"source file: ": "construction2.py","line number: ": "388","func name: ": "sanitize_array","func arg: ": "(data, index, dtype, copy, raise_cast_failure)","comments: ": "Sanitize input data to an ndarray, copy if specified, coerce to the dtype if specified.\n\n\n"},"func4": {"source file: ": "construction2.py","line number: ": "506","func name: ": "_try_cast","func arg: ": "(arr, dtype, copy, raise_cast_failure)","comments: ": "Convert input to numpy ndarray and optionally cast to a given dtype.\n\nParameters ---------- arr : ndarray, list, tuple, iterator (catchall) Excludes: ExtensionArray, Series, Index. dtype : np.dtype, ExtensionDtype or None copy : bool If False, don't copy the data if not needed. raise_cast_failure : bool If True, and if a dtype is specified, raise errors during casting. Otherwise an object array is returned.\n"},"func5": {"source file: ": "construction2.py","line number: ": "570","func name: ": "is_empty_data","func arg: ": "(data)","comments: ": "Utility to check if a Series is instantiated with empty data, which does not contain dtype information.\n\nParameters ---------- data : array-like, Iterable, dict, or scalar value Contains data stored in Series.\n##### Returns\n"},"func6": {"source file: ": "construction2.py","line number: ": "590","func name: ": "create_series_with_explicit_dtype","func arg: ": "(data, index, dtype, name, copy, fastpath, dtype_if_empty)","comments: ": "Helper to pass an explicit dtype when instantiating an empty Series.\n\nThis silences a DeprecationWarning described in GitHub-17261.\n\nParameters ---------- data : Mirrored from Series.__init__ index : Mirrored from Series.__init__ dtype : Mirrored from Series.__init__ name : Mirrored from Series.__init__ copy : Mirrored from Series.__init__ fastpath : Mirrored from Series.__init__ dtype_if_empty : str, numpy.dtype, or ExtensionDtype This dtype will be passed explicitly if an empty Series will be instantiated.\n##### Returns\n"}}{}{"func1": {"source file: ": "converter1.py","line number: ": "46","func name: ": "get_pairs","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "converter1.py","line number: ": "58","func name: ": "register_pandas_matplotlib_converters","func arg: ": "(func)","comments: ": "Decorator applying pandas_converters.\n\n\n"},"func3": {"source file: ": "converter1.py","line number: ": "72","func name: ": "pandas_converters","func arg: ": "()","comments: ": "Context manager registering pandas' converters for a plot.\n\nSee Also -------- register_pandas_matplotlib_converters : Decorator that applies this.\n"},"func4": {"source file: ": "converter1.py","line number: ": "93","func name: ": "register","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "converter1.py","line number: ": "104","func name: ": "deregister","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "converter1.py","line number: ": "118","func name: ": "_to_ordinalf","func arg: ": "(tm)","comments: ": ""},"func7": {"source file: ": "converter1.py","line number: ": "123","func name: ": "time2num","func arg: ": "(d)","comments: ": ""},"func8": {"source file: ": "converter1.py","line number: ": "233","func name: ": "get_datevalue","func arg: ": "(date, freq)","comments: ": ""},"func9": {"source file: ": "converter1.py","line number: ": "249","func name: ": "_dt_to_float_ordinal","func arg: ": "(dt)","comments: ": "Convert :mod:`datetime` to the Gregorian date as UTC float days, preserving hours, minutes, seconds and microseconds.  Return value is a :func:`float`.\n\n\n"},"func10": {"source file: ": "converter1.py","line number: ": "482","func name: ": "_from_ordinal","func arg: ": "(x, tz)","comments: ": ""},"func11": {"source file: ": "converter1.py","line number: ": "511","func name: ": "_get_default_annual_spacing","func arg: ": "(nyears)","comments: ": "Returns a default spacing between consecutive ticks for annual data.\n\n\n"},"func12": {"source file: ": "converter1.py","line number: ": "533","func name: ": "period_break","func arg: ": "(dates, period)","comments: ": "Returns the indices where the given period changes.\n\nParameters ---------- dates : PeriodIndex Array of intervals to monitor. period : string Name of the period to monitor.\n"},"func13": {"source file: ": "converter1.py","line number: ": "549","func name: ": "has_level_label","func arg: ": "(label_flags, vmin)","comments: ": "Returns true if the ``label_flags`` indicate there is at least one label for this level.\n\nif the minimum view limit is not an exact integer, then the first tick label won't be shown, so we must adjust for that.\n"},"func14": {"source file: ": "converter1.py","line number: ": "565","func name: ": "_daily_finder","func arg: ": "(vmin, vmax, freq)","comments: ": ""},"func15": {"source file: ": "converter1.py","line number: ": "791","func name: ": "_monthly_finder","func arg: ": "(vmin, vmax, freq)","comments: ": ""},"func16": {"source file: ": "converter1.py","line number: ": "861","func name: ": "_quarterly_finder","func arg: ": "(vmin, vmax, freq)","comments: ": ""},"func17": {"source file: ": "converter1.py","line number: ": "907","func name: ": "_annual_finder","func arg: ": "(vmin, vmax, freq)","comments: ": ""},"func18": {"source file: ": "converter1.py","line number: ": "927","func name: ": "get_finder","func arg: ": "(freq)","comments: ": ""}}{}{"func1": {"source file: ": "css1.py","line number: ": "17","func name: ": "_side_expander","func arg: ": "(prop_fmt)","comments: ": ""}}{}{"func1": {"source file: ": "date_converters1.py","line number: ": "7","func name: ": "parse_date_time","func arg: ": "(date_col, time_col)","comments: ": ""},"func2": {"source file: ": "date_converters1.py","line number: ": "13","func name: ": "parse_date_fields","func arg: ": "(year_col, month_col, day_col)","comments: ": ""},"func3": {"source file: ": "date_converters1.py","line number: ": "20","func name: ": "parse_all_fields","func arg: ": "(year_col, month_col, day_col, hour_col, minute_col, second_col)","comments: ": ""},"func4": {"source file: ": "date_converters1.py","line number: ": "32","func name: ": "generic_parser","func arg: ": "(parse_func)","comments: ": ""},"func5": {"source file: ": "date_converters1.py","line number: ": "43","func name: ": "_maybe_cast","func arg: ": "(arr)","comments: ": ""},"func6": {"source file: ": "date_converters1.py","line number: ": "49","func name: ": "_check_columns","func arg: ": "(cols)","comments: ": ""}}{}{"func1": {"source file: ": "datetimelike2.py","line number: ": "53","func name: ": "_datetimelike_array_cmp","func arg: ": "(cls, op)","comments: ": "Wrap comparison operations to convert Timestamp/Timedelta/Period-like to boxed scalars/arrays.\n\n\n"},"func2": {"source file: ": "datetimelike2.py","line number: ": "1596","func name: ": "validate_periods","func arg: ": "(periods)","comments: ": "If a `periods` argument is passed to the Datetime/Timedelta Array/Index constructor, cast it to an integer.\n\nParameters ---------- periods : None, float, int\n##### Returns\n* **periods **: None or int\n\n"},"func3": {"source file: ": "datetimelike2.py","line number: ": "1622","func name: ": "validate_endpoints","func arg: ": "(closed)","comments: ": "Check that the `closed` argument is among [None, \"left\", \"right\"]\n\nParameters ---------- closed : {None, \"left\", \"right\"}\n##### Returns\n* **left_closed **: bool\n\n* **right_closed **: bool\n\n"},"func4": {"source file: ": "datetimelike2.py","line number: ": "1655","func name: ": "validate_inferred_freq","func arg: ": "(freq, inferred_freq, freq_infer)","comments: ": "If the user passes a freq and another freq is inferred from passed data, require that they match.\n\nParameters ---------- freq : DateOffset or None inferred_freq : DateOffset or None freq_infer : bool\n##### Returns\n* **freq **: DateOffset or None\n\n* **freq_infer **: bool\n\n"},"func5": {"source file: ": "datetimelike2.py","line number: ": "1690","func name: ": "maybe_infer_freq","func arg: ": "(freq)","comments: ": "Comparing a DateOffset to the string \"infer\" raises, so we need to be careful about comparisons.  Make a dummy variable `freq_infer` to signify the case where the given freq is \"infer\" and set freq to None to avoid comparison trouble later on.\n\nParameters ---------- freq : {DateOffset, None, str}\n##### Returns\n* **freq **: {DateOffset, None}\n\n* **freq_infer **: bool\n\n"}}{"func1": {"source file: ": "datetimelike3.py","line number: ": "52","func name: ": "_join_i8_wrapper","func arg: ": "(joinf, with_indexers)","comments: ": "Create the join wrapper methods.\n\n\n"}}{"func1": {"source file: ": "datetimes1.py","line number: ": "59","func name: ": "_guess_datetime_format_for_array","func arg: ": "(arr, **kwargs)","comments: ": ""},"func2": {"source file: ": "datetimes1.py","line number: ": "66","func name: ": "should_cache","func arg: ": "(arg, unique_share, check_count)","comments: ": "Decides whether to do caching.\n\nIf the percent of unique elements among `check_count` elements less than `unique_share * 100` then we can do caching.\n\nParameters ---------- arg: listlike, tuple, 1-d array, Series unique_share: float, default=0.7, optional 0 < unique_share < 1 check_count: int, optional 0 <= check_count <= len(arg)\n##### Returns\n* **do_caching**: bool\n\n"},"func3": {"source file: ": "datetimes1.py","line number: ": "122","func name: ": "_maybe_cache","func arg: ": "(arg, format, cache, convert_listlike)","comments: ": "Create a cache of unique dates from an array of dates\n\nParameters ---------- arg : listlike, tuple, 1-d array, Series format : string Strftime format to parse time cache : boolean True attempts to create a cache of converted values convert_listlike : function Conversion function to apply on dates\n##### Returns\n* **cache_array **: Series\nCache of converted, unique dates. Can be empty\n\n"},"func4": {"source file: ": "datetimes1.py","line number: ": "157","func name: ": "_box_as_indexlike","func arg: ": "(dt_array, utc, name)","comments: ": "Properly boxes the ndarray of datetimes to DatetimeIndex if it is possible or to generic Index instead\n\nParameters ---------- dt_array: 1-d array Array of datetimes to be wrapped in an Index. tz : object None or 'utc' name : string, default None Name for a resulting index\n##### Returns\n* **result **: datetime of converted dates\n- DatetimeIndex if convertible to sole datetime64 type\n- general Index otherwise\n\n"},"func5": {"source file: ": "datetimes1.py","line number: ": "187","func name: ": "_convert_and_box_cache","func arg: ": "(arg, cache_array, name)","comments: ": "Convert array of dates with a cache and wrap the result in an Index.\n\nParameters ---------- arg : integer, float, string, datetime, list, tuple, 1-d array, Series cache_array : Series Cache of converted, unique dates name : string, default None Name for a DatetimeIndex\n##### Returns\n* **result **: Index-like of converted dates\n\n"},"func6": {"source file: ": "datetimes1.py","line number: ": "213","func name: ": "_return_parsed_timezone_results","func arg: ": "(result, timezones, tz, name)","comments: ": "Return results from array_strptime if a %z or %Z directive was passed.\n\nParameters ---------- result : ndarray int64 date representations of the dates timezones : ndarray pytz timezone objects tz : object None or pytz timezone object name : string, default None Name for a DatetimeIndex\n##### Returns\n* **tz_result **: Index-like of parsed dates with timezone\n\n"},"func7": {"source file: ": "datetimes1.py","line number: ": "246","func name: ": "_convert_listlike_datetimes","func arg: ": "(arg, format, name, tz, unit, errors, infer_datetime_format, dayfirst, yearfirst, exact)","comments: ": "Helper function for to_datetime. Performs the conversions of 1D listlike of dates\n\nParameters ---------- arg : list, tuple, ndarray, Series, Index date to be parced name : object None or string for the Index name tz : object None or 'utc' unit : string None or string of the frequency of the passed data errors : string error handing behaviors from to_datetime, 'raise', 'coerce', 'ignore' infer_datetime_format : boolean inferring format behavior from to_datetime dayfirst : boolean dayfirst parsing behavior from to_datetime yearfirst : boolean yearfirst parsing behavior from to_datetime exact : boolean exact format matching behavior from to_datetime\n##### Returns\n"},"func8": {"source file: ": "datetimes1.py","line number: ": "459","func name: ": "_adjust_to_origin","func arg: ": "(arg, origin, unit)","comments: ": "Helper function for to_datetime. Adjust input argument to the specified origin\n\nParameters ---------- arg : list, tuple, ndarray, Series, Index date to be adjusted origin : 'julian' or Timestamp origin offset for the arg unit : string passed unit from to_datetime, must be 'D'\n##### Returns\n"},"func9": {"source file: ": "datetimes1.py","line number: ": "530","func name: ": "to_datetime","func arg: ": "(arg, errors, dayfirst, yearfirst, utc, format, exact, unit, infer_datetime_format, origin, cache)","comments: ": "Convert argument to datetime.\n\nParameters ---------- arg : int, float, str, datetime, list, tuple, 1-d array, Series DataFrame/dict-like The object to convert to a datetime. errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n- If 'raise', then invalid parsing will raise an exception.\n\n- If 'coerce', then invalid parsing will be set as NaT.\n\n- If 'ignore', then invalid parsing will return the input. dayfirst : bool, default False Specify a date parse order if `arg` is str or its list-likes. If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10. Warning: dayfirst=True is not strict, but will prefer to parse with day first (this is a known bug, based on dateutil behavior). yearfirst : bool, default False Specify a date parse order if `arg` is str or its list-likes.\n\n- If True parses dates with the year first, eg 10/11/12 is parsed as 2010-11-12.\n\n- If both dayfirst and yearfirst are True, yearfirst is preceded (same as dateutil).\n\nWarning: yearfirst=True is not strict, but will prefer to parse with year first (this is a known bug, based on dateutil behavior). utc : bool, default None Return UTC DatetimeIndex if True (converting any tz-aware datetime.datetime objects as well). format : str, default None The strftime to parse time, eg \"%d/%m/%Y\", note that \"%f\" will parse all the way up to nanoseconds. See strftime documentation for more information on choices: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior. exact : bool, True by default Behaves as:\n\n- If True, require an exact format match.\n\n- If False, allow the format to match anywhere in the target string.\n\nunit : str, default 'ns' The unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number. This will be based off the origin. Example, with unit='ms' and origin='unix' (the default), this would calculate the number of milliseconds to the unix epoch start. infer_datetime_format : bool, default False If True and no `format` is given, attempt to infer the format of the datetime strings, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by ~5-10x. origin : scalar, default 'unix' Define the reference date. The numeric values would be parsed as number of units (defined by `unit`) since this reference date.\n\n- If 'unix' (or POSIX) time; origin is set to 1970-01-01.\n\n- If 'julian', unit must be 'D', and origin is set to beginning of Julian Calendar. Julian day number 0 is assigned to the day starting at noon on January 1, 4713 BC.\n\n- If Timestamp convertible, origin is set to Timestamp identified by origin. cache : bool, default True If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. The cache is only used when there are at least 50 values. The presence of out-of-bounds values will render the cache unusable and may slow down parsing.\n\n.. versionadded:: 0.23.0\n\n.. versionchanged:: 0.25.0\n\n- changed default value from False to True.\n##### Returns\n* **datetime\nIf parsing succeeded.\nReturn type depends on input**: - list-like\n\n* **DataFrame.astype **: Cast argument to a specified dtype.\n\n* **to_timedelta **: Convert argument to timedelta.\n\n* **convert_dtypes **: Convert dtypes.\n\n* **>>> df = pd.DataFrame({'year'**: [2015, 2016],\n\n* **...'month'**: [2, 3],\n\n* **...'day'**: [4, 5]})\n\n* **dtype**: object\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html\n\n* **>>> %timeit pd.to_datetime(s, infer_datetime_format=True)  # doctest**: +SKIP\n\n* **100 loops, best of 3**: 10.4 ms per loop\n\n* **>>> %timeit pd.to_datetime(s, infer_datetime_format=False)  # doctest**: +SKIP\n\n* **1 loop, best of 3**: 471 ms per loop\n\n* **Timestamp('2017-03-22 15**: 16\n\n* **.. warning**: \n\n"},"func10": {"source file: ": "datetimes1.py","line number: ": "787","func name: ": "_assemble_from_unit_mappings","func arg: ": "(arg, errors, tz)","comments: ": "assemble the unit specified fields from the arg (DataFrame) Return a Series for actual parsing\n\nParameters ---------- arg : DataFrame errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n- If 'raise', then invalid parsing will raise an exception\n\n- If 'coerce', then invalid parsing will be set as NaT\n\n- If 'ignore', then invalid parsing will return the input tz : None or 'utc'\n##### Returns\n"},"func11": {"source file: ": "datetimes1.py","line number: ": "874","func name: ": "_attempt_YYYYMMDD","func arg: ": "(arg, errors)","comments: ": "try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like, arg is a passed in as an object dtype, but could really be ints/strings with nan-like/or floats (e.g. with nan)\n\nParameters ---------- arg : passed value errors : 'raise','ignore','coerce'\n"},"func12": {"source file: ": "datetimes1.py","line number: ": "939","func name: ": "_guess_time_format_for_array","func arg: ": "(arr)","comments: ": ""},"func13": {"source file: ": "datetimes1.py","line number: ": "954","func name: ": "to_time","func arg: ": "(arg, format, infer_time_format, errors)","comments: ": "Parse time strings to time objects using fixed strptime formats (\"%H:%M\", \"%H%M\", \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\", \"%I%M%S%p\")\n\nUse infer_time_format if all the strings are in the same format to speed up conversion.\n\nParameters ---------- arg : string in time format, datetime.time, list, tuple, 1-d array,\n\nSeries format : str, default None Format used to convert arg into a time object.\n\nIf None, fixed formats are used. infer_time_format: bool, default False Infer the time format based on the first non-NaN element.\n\nIf all strings are in the same format, this will speed up conversion. errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n- If 'raise', then invalid parsing will raise an exception\n\n- If 'coerce', then invalid parsing will be set as None\n\n- If 'ignore', then invalid parsing will return the input\n##### Returns\n"}}{"func1": {"source file: ": "datetimes2.py","line number: ": "37","func name: ": "_new_DatetimeIndex","func arg: ": "(cls, d)","comments: ": "This is called upon unpickling, rather than the default which doesn't have arguments and breaks __new__\n\n\n"},"func2": {"source file: ": "datetimes2.py","line number: ": "1021","func name: ": "date_range","func arg: ": "(start, end, periods, freq, tz, normalize, name, closed, **kwargs)","comments: ": "Return a fixed frequency DatetimeIndex.\n\nParameters ---------- start : str or datetime-like, optional Left bound for generating dates. end : str or datetime-like, optional Right bound for generating dates. periods : int, optional Number of periods to generate. freq : str or DateOffset, default 'D' Frequency strings can have multiples, e.g. '5H'. See :ref:`here <timeseries.offset_aliases>` for a list of frequency aliases. tz : str or tzinfo, optional Time zone name for returning localized DatetimeIndex, for example 'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is timezone-naive. normalize : bool, default False Normalize start/end dates to midnight before generating date range. name : str, default None Name of the resulting DatetimeIndex. closed : {None, 'left', 'right'}, optional Make the interval closed with respect to the given frequency to the 'left', 'right', or both sides (None, the default). **kwargs For compatibility. Has no effect on the result.\n##### Returns\n* **rng **: DatetimeIndex\n\n* **DatetimeIndex **: An immutable container for datetimes.\n\n* **timedelta_range **: Return a fixed frequency TimedeltaIndex.\n\n* **period_range **: Return a fixed frequency PeriodIndex.\n\n* **interval_range **: Return a fixed frequency IntervalIndex.\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n* **DatetimeIndex(['2018-04-24 00**: 00\n\n* **DatetimeIndex(['2018-01-01 00**: 00\n\n"},"func3": {"source file: ": "datetimes2.py","line number: ": "1185","func name: ": "bdate_range","func arg: ": "(start, end, periods, freq, tz, normalize, name, weekmask, holidays, closed, **kwargs)","comments: ": "Return a fixed frequency DatetimeIndex, with business day as the default frequency.\n\nParameters ---------- start : str or datetime-like, default None Left bound for generating dates. end : str or datetime-like, default None Right bound for generating dates. periods : int, default None Number of periods to generate. freq : str or DateOffset, default 'B' (business daily) Frequency strings can have multiples, e.g. '5H'. tz : str or None Time zone name for returning localized DatetimeIndex, for example Asia/Beijing. normalize : bool, default False Normalize start/end dates to midnight before generating date range. name : str, default None Name of the resulting DatetimeIndex. weekmask : str or None, default None Weekmask of valid business days, passed to ``numpy.busdaycalendar``, only used when custom frequency strings are passed.\n\nThe default value None is equivalent to 'Mon Tue Wed Thu Fri'.\n\n.. versionadded:: 0.21.0\n\nholidays : list-like or None, default None Dates to exclude from the set of valid business days, passed to ``numpy.busdaycalendar``, only used when custom frequency strings are passed.\n\n.. versionadded:: 0.21.0\n\nclosed : str, default None Make the interval closed with respect to the given frequency to the 'left', 'right', or both sides (None). **kwargs For compatibility. Has no effect on the result.\n##### Returns\n* **Of the four parameters**: ``start``, ``end``, ``periods``, and ``freq``,\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n"},"func4": {"source file: ": "datetimes2.py","line number: ": "1293","func name: ": "_time_to_micros","func arg: ": "(time)","comments: ": ""}}{"func1": {"source file: ": "datetimes3.py","line number: ": "55","func name: ": "tz_to_dtype","func arg: ": "(tz)","comments: ": "Return a datetime64[ns] dtype appropriate for the given timezone.\n\nParameters ---------- tz : tzinfo or None\n##### Returns\n"},"func2": {"source file: ": "datetimes3.py","line number: ": "73","func name: ": "_field_accessor","func arg: ": "(name, field, docstring)","comments: ": ""},"func3": {"source file: ": "datetimes3.py","line number: ": "1678","func name: ": "sequence_to_dt64ns","func arg: ": "(data, dtype, copy, tz, dayfirst, yearfirst, ambiguous)","comments: ": "Parameters ---------- data : list-like dtype : dtype, str, or None, default None copy : bool, default False tz : tzinfo, str, or None, default None dayfirst : bool, default False yearfirst : bool, default False ambiguous : str, bool, or arraylike, default 'raise' See pandas._libs.tslibs.conversion.tz_localize_to_utc.\n\n\n##### Returns\n* **result **: numpy.ndarray\nThe sequence converted to a numpy array with dtype ``datetime64[ns]``.\n\n* **tz **: tzinfo or None\nEither the user-provided tzinfo or one inferred from the data.\n\n* **inferred_freq **: Tick or None\nThe inferred frequency of the sequence.\n\n"},"func4": {"source file: ": "datetimes3.py","line number: ": "1806","func name: ": "objects_to_datetime64ns","func arg: ": "(data, dayfirst, yearfirst, utc, errors, require_iso8601, allow_object)","comments: ": "Convert data to array of timestamps.\n\nParameters ---------- data : np.ndarray[object] dayfirst : bool yearfirst : bool utc : bool, default False Whether to convert timezone-aware timestamps to UTC. errors : {'raise', 'ignore', 'coerce'} allow_object : bool Whether to return an object-dtype ndarray instead of raising if the data contains more than one timezone.\n##### Returns\n* **result **: ndarray\nnp.int64 dtype if returned values represent UTC timestamps\nnp.datetime64[ns] if returned values represent wall times\nobject if mixed timezones\n\n* **inferred_tz **: tzinfo or None\n\n"},"func5": {"source file: ": "datetimes3.py","line number: ": "1889","func name: ": "maybe_convert_dtype","func arg: ": "(data, copy)","comments: ": "Convert data based on dtype conventions, issuing deprecation warnings or errors where appropriate.\n\nParameters ---------- data : np.ndarray or pd.Index copy : bool\n##### Returns\n* **data **: np.ndarray or pd.Index\n\n* **copy **: bool\n\n"},"func6": {"source file: ": "datetimes3.py","line number: ": "1946","func name: ": "maybe_infer_tz","func arg: ": "(tz, inferred_tz)","comments: ": "If a timezone is inferred from data, check that it is compatible with the user-provided timezone, if any.\n\nParameters ---------- tz : tzinfo or None inferred_tz : tzinfo or None\n##### Returns\n* **tz **: tzinfo or None\n\n"},"func7": {"source file: ": "datetimes3.py","line number: ": "1976","func name: ": "_validate_dt64_dtype","func arg: ": "(dtype)","comments: ": "Check that a dtype, if passed, represents either a numpy datetime64[ns] dtype or a pandas DatetimeTZDtype.\n\nParameters ---------- dtype : object\n##### Returns\n* **dtype **: None, numpy.dtype, or DatetimeTZDtype\n\n"},"func8": {"source file: ": "datetimes3.py","line number: ": "2018","func name: ": "validate_tz_from_dtype","func arg: ": "(dtype, tz)","comments: ": "If the given dtype is a DatetimeTZDtype, extract the implied tzinfo object from it and check that it does not conflict with the given tz.\n\nParameters ---------- dtype : dtype, str tz : None, tzinfo\n##### Returns\n* **tz **: consensus tzinfo\n\n"},"func9": {"source file: ": "datetimes3.py","line number: ": "2065","func name: ": "_infer_tz_from_endpoints","func arg: ": "(start, end, tz)","comments: ": "If a timezone is not explicitly given via `tz`, see if one can be inferred from the `start` and `end` endpoints.  If more than one of these inputs provides a timezone, require that they all agree.\n\nParameters ---------- start : Timestamp end : Timestamp tz : tzinfo or None\n##### Returns\n* **tz **: tzinfo or None\n\n"},"func10": {"source file: ": "datetimes3.py","line number: ": "2106","func name: ": "_maybe_normalize_endpoints","func arg: ": "(start, end, normalize)","comments: ": ""},"func11": {"source file: ": "datetimes3.py","line number: ": "2126","func name: ": "_maybe_localize_point","func arg: ": "(ts, is_none, is_not_none, freq, tz, ambiguous, nonexistent)","comments: ": "Localize a start or end Timestamp to the timezone of the corresponding start or end Timestamp\n\nParameters ---------- ts : start or end Timestamp to potentially localize is_none : argument that should be None is_not_none : argument that should not be None freq : Tick, DateOffset, or None tz : str, timezone object or None ambiguous: str, localization behavior for ambiguous times nonexistent: str, localization behavior for nonexistent times\n##### Returns\n* **ts **: Timestamp\n\n"}}{"func1": {"source file: ": "dispatch1.py","line number: ": "21","func name: ": "should_extension_dispatch","func arg: ": "(left, right)","comments: ": "Identify cases where Series operation should use dispatch_to_extension_op.\n\nParameters ---------- left : Series right : object\n##### Returns\n"},"func2": {"source file: ": "dispatch1.py","line number: ": "48","func name: ": "should_series_dispatch","func arg: ": "(left, right, op)","comments: ": "Identify cases where a DataFrame operation should dispatch to its Series counterpart.\n\nParameters ---------- left : DataFrame right : DataFrame or Series op : binary operator\n##### Returns\n* **override **: bool\n\n"},"func3": {"source file: ": "dispatch1.py","line number: ": "96","func name: ": "dispatch_to_extension_op","func arg: ": "(op, left, right)","comments: ": "Assume that left or right is a Series backed by an ExtensionArray, apply the operator defined by op.\n\nParameters ---------- op : binary operator left : ExtensionArray or np.ndarray right : object\n##### Returns\n"}}{"func1": {"source file: ": "display1.py","line number: ": "14","func name: ": "detect_console_encoding","func arg: ": "()","comments: ": "Try to find the most capable encoding supported by the console. slightly modified from the way IPython handles the same issue.\n\n\n"}}{"func1": {"source file: ": "docstrings1.py","line number: ": "7","func name: ": "_make_flex_doc","func arg: ": "(op_name, typ)","comments: ": "Make the appropriate substitutions for the given operation and class-typ into either _flex_doc_SERIES or _flex_doc_FRAME to return the docstring to attach to a generated method.\n\nParameters ---------- op_name : str {'__add__', '__sub__', ... '__eq__', '__ne__', ...} typ : str {series, 'dataframe']}\n##### Returns\n* **doc **: str\n\n"}}{}{}{"func1": {"source file: ": "dtypes1.py","line number: ": "19","func name: ": "register_extension_dtype","func arg: ": "(cls)","comments: ": "Register an ExtensionType with pandas as class decorator.\n\n.. versionadded:: 0.24.0\n\nThis enables operations like ``.astype(name)`` for the name of the ExtensionDtype.\n##### Returns\n* **... class MyExtensionDtype(ExtensionDtype)**: \n\n"}}{"func1": {"source file: ": "engines1.py","line number: ": "20","func name: ": "_check_ne_builtin_clash","func arg: ": "(expr)","comments: ": "Attempt to prevent foot-shooting in a helpful way.\n\nParameters ---------- terms : Term Terms can contain\n"}}{"func1": {"source file: ": "eval1.py","line number: ": "22","func name: ": "_check_engine","func arg: ": "(engine)","comments: ": "Make sure a valid engine is passed.\n\nParameters ---------- engine : str\n##### Returns\n"},"func2": {"source file: ": "eval1.py","line number: ": "70","func name: ": "_check_parser","func arg: ": "(parser)","comments: ": "Make sure a valid parser is passed.\n\nParameters ---------- parser : str\n"},"func3": {"source file: ": "eval1.py","line number: ": "91","func name: ": "_check_resolvers","func arg: ": "(resolvers)","comments: ": ""},"func4": {"source file: ": "eval1.py","line number: ": "102","func name: ": "_check_expression","func arg: ": "(expr)","comments: ": "Make sure an expression is not an empty string\n\nParameters ---------- expr : object An object that can be converted to a string\n"},"func5": {"source file: ": "eval1.py","line number: ": "120","func name: ": "_convert_expression","func arg: ": "(expr)","comments: ": "Convert an object to an expression.\n\nThis function converts an object to an expression (a unicode string) and checks to make sure it isn't empty after conversion. This is used to convert operators to their string representation for recursive calls to :func:`~pandas.eval`.\n\nParameters ---------- expr : object The object to be converted to a string.\n##### Returns\n"},"func6": {"source file: ": "eval1.py","line number: ": "149","func name: ": "_check_for_locals","func arg: ": "(expr, stack_level, parser)","comments: ": ""},"func7": {"source file: ": "eval1.py","line number: ": "170","func name: ": "eval","func arg: ": "(expr, parser, engine, truediv, local_dict, global_dict, resolvers, level, target, inplace)","comments: ": "Evaluate a Python expression as a string using various backends.\n\nThe following arithmetic operations are supported: ``+``, ``-``, ``*``, ``/``, ``**``, ``%``, ``//`` (python engine only) along with the following boolean operations: ``|`` (or), ``&`` (and), and ``~`` (not). Additionally, the ``'pandas'`` parser allows the use of :keyword:`and`, :keyword:`or`, and :keyword:`not` with the same semantics as the corresponding bitwise operators.\n\n:class:`~pandas.Series` and :class:`~pandas.DataFrame` objects are supported and behave as they would with plain ol' Python evaluation.\n\nParameters ---------- expr : str The expression to evaluate. This string cannot contain any Python `statements <https://docs.python.org/3/reference/simple_stmts.html#simple-statements>`__, only Python `expressions <https://docs.python.org/3/reference/simple_stmts.html#expression-statements>`__. parser : {'pandas', 'python'}, default 'pandas' The parser to use to construct the syntax tree from the expression. The default of ``'pandas'`` parses code slightly different than standard Python. Alternatively, you can parse an expression using the ``'python'`` parser to retain strict Python semantics.\n\nSee the :ref:`enhancing performance <enhancingperf.eval>` documentation for more details. engine : {'python', 'numexpr'}, default 'numexpr'\n\nThe engine used to evaluate the expression. Supported engines are\n\n- None\n\n\n\n\n\n\n\n : tries to use ``numexpr``, falls back to ``python``\n\n- ``'numexpr'``: This default engine evaluates pandas objects using numexpr for large speed ups in complex expressions with large frames.\n\n- ``'python'``: Performs operations as if you had ``eval``'d in top level python. This engine is generally not that useful.\n\nMore backends may be available in the future.\n\ntruediv : bool, optional Whether to use true division, like in Python >= 3. deprecated:: 1.0.0\n\nlocal_dict : dict or None, optional A dictionary of local variables, taken from locals() by default. global_dict : dict or None, optional A dictionary of global variables, taken from globals() by default. resolvers : list of dict-like or None, optional A list of objects implementing the ``__getitem__`` special method that you can use to inject an additional collection of namespaces to use for variable lookup. For example, this is used in the :meth:`~DataFrame.query` method to inject the ``DataFrame.index`` and ``DataFrame.columns`` variables that refer to their respective :class:`~pandas.DataFrame` instance attributes. level : int, optional The number of prior stack frames to traverse and add to the current scope. Most users will **not** need to change this parameter. target : object, optional, default None This is the target object for assignment. It is used when there is variable assignment in the expression. If so, then `target` must support item assignment with string keys, and if a copy is being returned, it must also support `.copy()`. inplace : bool, default False If `target` is provided, and the expression mutates `target`, whether to modify `target` inplace. Otherwise, return a copy of `target` with the mutation.\n##### Returns\n"}}{}{}{}{"func1": {"source file: ": "expr1.py","line number: ": "37","func name: ": "_rewrite_assign","func arg: ": "(tok)","comments: ": "Rewrite the assignment operator for PyTables expressions that use ``=`` as a substitute for ``==``.\n\nParameters ---------- tok : tuple of int, str ints correspond to the all caps constants in the tokenize module\n##### Returns\n* **t **: tuple of int, str\nEither the input or token or the replacement values\n\n"},"func2": {"source file: ": "expr1.py","line number: ": "55","func name: ": "_replace_booleans","func arg: ": "(tok)","comments: ": "Replace ``&`` with ``and`` and ``|`` with ``or`` so that bitwise precedence is changed to boolean precedence.\n\nParameters ---------- tok : tuple of int, str ints correspond to the all caps constants in the tokenize module\n##### Returns\n* **t **: tuple of int, str\nEither the input or token or the replacement values\n\n"},"func3": {"source file: ": "expr1.py","line number: ": "79","func name: ": "_replace_locals","func arg: ": "(tok)","comments: ": "Replace local variables with a syntactically valid name.\n\nParameters ---------- tok : tuple of int, str ints correspond to the all caps constants in the tokenize module\n##### Returns\n* **t **: tuple of int, str\nEither the input or token or the replacement values\n\n"},"func4": {"source file: ": "expr1.py","line number: ": "104","func name: ": "_compose2","func arg: ": "(f, g)","comments: ": "Compose 2 callables\n\n\n"},"func5": {"source file: ": "expr1.py","line number: ": "109","func name: ": "_compose","func arg: ": "()","comments: ": "Compose 2 or more callables\n\n\n"},"func6": {"source file: ": "expr1.py","line number: ": "115","func name: ": "_preparse","func arg: ": "(source, f)","comments: ": "Compose a collection of tokenization functions\n\nParameters ---------- source : str A Python source code string f : callable This takes a tuple of (toknum, tokval) as its argument and returns a tuple with the same structure but possibly different elements. Defaults to the composition of ``_rewrite_assign``, ``_replace_booleans``, and ``_replace_locals``.\n##### Returns\n* **s **: str\nValid Python source code\n\n"},"func7": {"source file: ": "expr1.py","line number: ": "148","func name: ": "_is_type","func arg: ": "(t)","comments: ": "Factory for a type checking function of type ``t`` or tuple of types.\n\n\n"},"func8": {"source file: ": "expr1.py","line number: ": "166","func name: ": "_filter_nodes","func arg: ": "(superclass, all_nodes)","comments: ": "Filter out AST nodes that are subclasses of ``superclass``.\n\n\n"},"func9": {"source file: ": "expr1.py","line number: ": "230","func name: ": "_node_not_implemented","func arg: ": "(node_name, cls)","comments: ": "Return a function that raises a NotImplementedError with a passed node name.\n\n\n"},"func10": {"source file: ": "expr1.py","line number: ": "241","func name: ": "disallow","func arg: ": "(nodes)","comments: ": "Decorator to disallow certain nodes from parsing. Raises a NotImplementedError instead.\n\n\n##### Returns\n* **disallowed **: callable\n\n"},"func11": {"source file: ": "expr1.py","line number: ": "262","func name: ": "_op_maker","func arg: ": "(op_class, op_symbol)","comments: ": "Return a function to create an op class with its symbol already passed.\n\n\n##### Returns\n* **f **: callable\n\n"},"func12": {"source file: ": "expr1.py","line number: ": "286","func name: ": "add_ops","func arg: ": "(op_classes)","comments: ": "Decorator to add default implementation of ops.\n\n\n"}}{"func1": {"source file: ": "expressions1.py","line number: ": "40","func name: ": "set_use_numexpr","func arg: ": "(v)","comments: ": ""},"func2": {"source file: ": "expressions1.py","line number: ": "56","func name: ": "set_numexpr_threads","func arg: ": "(n)","comments: ": ""},"func3": {"source file: ": "expressions1.py","line number: ": "65","func name: ": "_evaluate_standard","func arg: ": "(op, op_str, a, b)","comments: ": "standard evaluation\n\n\n"},"func4": {"source file: ": "expressions1.py","line number: ": "73","func name: ": "_can_use_numexpr","func arg: ": "(op, op_str, a, b, dtype_check)","comments: ": "return a boolean if we WILL be using numexpr\n\n\n"},"func5": {"source file: ": "expressions1.py","line number: ": "99","func name: ": "_evaluate_numexpr","func arg: ": "(op, op_str, a, b)","comments: ": ""},"func6": {"source file: ": "expressions1.py","line number: ": "126","func name: ": "_where_standard","func arg: ": "(cond, a, b)","comments: ": ""},"func7": {"source file: ": "expressions1.py","line number: ": "132","func name: ": "_where_numexpr","func arg: ": "(cond, a, b)","comments: ": ""},"func8": {"source file: ": "expressions1.py","line number: ": "160","func name: ": "_has_bool_dtype","func arg: ": "(x)","comments: ": ""},"func9": {"source file: ": "expressions1.py","line number: ": "169","func name: ": "_bool_arith_check","func arg: ": "(op_str, a, b, not_allowed, unsupported)","comments: ": ""},"func10": {"source file: ": "expressions1.py","line number: ": "191","func name: ": "evaluate","func arg: ": "(op, op_str, a, b, use_numexpr)","comments: ": "Evaluate and return the expression of the op on a and b.\n\nParameters ---------- op : the actual operand op_str : str The string version of the op. a : left operand b : right operand use_numexpr : bool, default True Whether to try to use numexpr.\n"},"func11": {"source file: ": "expressions1.py","line number: ": "212","func name: ": "where","func arg: ": "(cond, a, b, use_numexpr)","comments: ": "Evaluate the where condition cond on a and b.\n\nParameters ---------- cond : np.ndarray[bool] a : return if cond is True b : return if cond is False use_numexpr : bool, default True Whether to try to use numexpr.\n"},"func12": {"source file: ": "expressions1.py","line number: ": "230","func name: ": "set_test_mode","func arg: ": "(v)","comments: ": "Keeps track of whether numexpr was used.  Stores an additional ``True`` for every successful use of evaluate with numexpr since the last ``get_test_result``\n\n\n"},"func13": {"source file: ": "expressions1.py","line number: ": "241","func name: ": "_store_test_result","func arg: ": "(used_numexpr)","comments: ": ""},"func14": {"source file: ": "expressions1.py","line number: ": "247","func name: ": "get_test_result","func arg: ": "()","comments: ": "get test result and reset test_results\n\n\n"}}{"func1": {"source file: ": "extension1.py","line number: ": "24","func name: ": "inherit_from_data","func arg: ": "(name, delegate, cache, wrap)","comments: ": "Make an alias for a method of the underlying ExtensionArray.\n\nParameters ---------- name : str Name of an attribute the class should inherit from its EA parent. delegate : class cache : bool, default False Whether to convert wrapped properties into cache_readonly wrap : bool, default False Whether to wrap the inherited result in an Index.\n##### Returns\n"},"func2": {"source file: ": "extension1.py","line number: ": "92","func name: ": "inherit_names","func arg: ": "(names, delegate, cache, wrap)","comments: ": "Class decorator to pin attributes from an ExtensionArray to a Index subclass.\n\nParameters ---------- names : List[str] delegate : class cache : bool, default False wrap : bool, default False Whether to wrap the inherited result in an Index.\n"},"func3": {"source file: ": "extension1.py","line number: ": "115","func name: ": "_make_wrapped_comparison_op","func arg: ": "(opname)","comments: ": "Create a comparison method that dispatches to ``._data``.\n\n\n"},"func4": {"source file: ": "extension1.py","line number: ": "135","func name: ": "make_wrapped_arith_op","func arg: ": "(opname)","comments: ": ""},"func5": {"source file: ": "extension1.py","line number: ": "154","func name: ": "_wrap_arithmetic_op","func arg: ": "(other, result)","comments: ": ""},"func6": {"source file: ": "extension1.py","line number: ": "175","func name: ": "_maybe_unwrap_index","func arg: ": "(obj)","comments: ": "If operating against another Index object, we need to unwrap the underlying data before deferring to the DatetimeArray/TimedeltaArray/PeriodArray implementation, otherwise we will incorrectly return NotImplemented.\n\nParameters ---------- obj : object\n##### Returns\n"}}{"func1": {"source file: ": "feather_format1.py","line number: ": "10","func name: ": "to_feather","func arg: ": "(df, path)","comments: ": "Write a DataFrame to the feather-format\n\nParameters ---------- df : DataFrame path : string file path, or file-like object\n"},"func2": {"source file: ": "feather_format1.py","line number: ": "67","func name: ": "read_feather","func arg: ": "(path, columns, use_threads)","comments: ": "Load a feather-format object from the file path.\n\nParameters ---------- path : str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.feather``.\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``. columns : sequence, default None If not provided, all columns are read.\n\n.. versionadded:: 0.24.0 use_threads : bool, default True Whether to parallelize reading using multiple threads.\n\n.. versionadded:: 0.24.0\n##### Returns\n"}}{"func1": {"source file: ": "format1.py","line number: ": "443","func name: ": "_get_adjustment","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "format1.py","line number: ": "1097","func name: ": "format_array","func arg: ": "(values, formatter, float_format, na_rep, digits, space, justify, decimal, leading_space)","comments: ": "Format an array for printing.\n\nParameters ---------- values formatter float_format na_rep digits space justify decimal leading_space : bool, optional Whether the array should be formatted with a leading space. When an array as a column of a Series or DataFrame, we do want the leading space to pad between columns.\n\nWhen formatting an Index subclass (e.g. IntervalIndex._format_native_types), we don't want the leading space since it should be left-aligned.\n##### Returns\n"},"func3": {"source file: ": "format1.py","line number: ": "1504","func name: ": "format_percentiles","func arg: ": "(percentiles)","comments: ": "Outputs rounded and formatted percentiles.\n\nParameters ---------- percentiles : list-like, containing floats from interval [0,1]\n##### Returns\n* **formatted **: list of strings\n\n* **Rounding precision is chosen so that**: (1) if any two elements of\n\n* **Keeps all entries different after rounding**: \n\n* **Duplicates are allowed**: \n\n"},"func4": {"source file: ": "format1.py","line number: ": "1574","func name: ": "_is_dates_only","func arg: ": "(values)","comments: ": ""},"func5": {"source file: ": "format1.py","line number: ": "1595","func name: ": "_format_datetime64","func arg: ": "(x, tz, nat_rep)","comments: ": ""},"func6": {"source file: ": "format1.py","line number: ": "1610","func name: ": "_format_datetime64_dateonly","func arg: ": "(x, nat_rep, date_format)","comments: ": ""},"func7": {"source file: ": "format1.py","line number: ": "1625","func name: ": "_get_format_datetime64","func arg: ": "(is_dates_only, nat_rep, date_format)","comments: ": ""},"func8": {"source file: ": "format1.py","line number: ": "1637","func name: ": "_get_format_datetime64_from_values","func arg: ": "(values, date_format)","comments: ": "given values and a date_format, return a string format\n\n\n"},"func9": {"source file: ": "format1.py","line number: ": "1686","func name: ": "_get_format_timedelta64","func arg: ": "(values, nat_rep, box)","comments: ": "Return a formatter function for a range of timedeltas. These will all have the same format argument\n\nIf box, then show the return in quotes\n"},"func10": {"source file: ": "format1.py","line number: ": "1731","func name: ": "_make_fixed_width","func arg: ": "(strings, justify, minimum, adj)","comments: ": ""},"func11": {"source file: ": "format1.py","line number: ": "1764","func name: ": "_trim_zeros_complex","func arg: ": "(str_complexes, na_rep)","comments: ": "Separates the real and imaginary parts from the complex number, and executes the _trim_zeros_float method on each of those.\n\n\n"},"func12": {"source file: ": "format1.py","line number: ": "1775","func name: ": "_trim_zeros_float","func arg: ": "(str_floats, na_rep)","comments: ": "Trims zeros, leaving just one before the decimal points if need be.\n\n\n"},"func13": {"source file: ": "format1.py","line number: ": "1801","func name: ": "_has_names","func arg: ": "(index)","comments: ": ""},"func14": {"source file: ": "format1.py","line number: ": "1904","func name: ": "set_eng_float_format","func arg: ": "(accuracy, use_eng_prefix)","comments: ": "Alter default behavior on how float is formatted in DataFrame. Format float in engineering format. By accuracy, we mean the number of decimal digits after the floating point.\n\nSee also EngFormatter.\n"},"func15": {"source file: ": "format1.py","line number: ": "1917","func name: ": "_binify","func arg: ": "(cols, line_width)","comments: ": ""},"func16": {"source file: ": "format1.py","line number: ": "1937","func name: ": "get_level_lengths","func arg: ": "(levels, sentinel)","comments: ": "For each index in each level the function returns lengths of indexes.\n\nParameters ---------- levels : list of lists List of values on for level. sentinel : string, optional Value which states that no new index starts on there.\n##### Returns\n"},"func17": {"source file: ": "format1.py","line number: ": "1979","func name: ": "buffer_put_lines","func arg: ": "(buf, lines)","comments: ": "Appends lines to a buffer.\n\nParameters ---------- buf The buffer to write to lines The lines to append.\n"}}{"func1": {"source file: ": "frame1.py","line number: ": "8469","func name: ": "_from_nested_dict","func arg: ": "(data)","comments: ": ""},"func2": {"source file: ": "frame1.py","line number: ": "8479","func name: ": "_put_str","func arg: ": "(s, space)","comments: ": ""}}{"func1": {"source file: ": "frequencies1.py","line number: ": "56","func name: ": "get_period_alias","func arg: ": "(offset_str)","comments: ": "Alias to closest period strings BQ->Q etc.\n\n\n"},"func2": {"source file: ": "frequencies1.py","line number: ": "74","func name: ": "to_offset","func arg: ": "(freq)","comments: ": "Return DateOffset object from string or tuple representation or datetime.timedelta object.\n\nParameters ---------- freq : str, tuple, datetime.timedelta, DateOffset or None\n##### Returns\n"},"func3": {"source file: ": "frequencies1.py","line number: ": "185","func name: ": "get_offset","func arg: ": "(name)","comments: ": "Return DateOffset object associated with rule name.\n\n.. deprecated:: 1.0.0\n\nExamples -------- get_offset('EOM') --> BMonthEnd(1)\n"},"func4": {"source file: ": "frequencies1.py","line number: ": "204","func name: ": "_get_offset","func arg: ": "(name)","comments: ": "Return DateOffset object associated with rule name.\n\nExamples -------- _get_offset('EOM') --> BMonthEnd(1)\n"},"func5": {"source file: ": "frequencies1.py","line number: ": "239","func name: ": "infer_freq","func arg: ": "(index, warn)","comments: ": "Infer the most likely frequency given the input index. If the frequency is uncertain, a warning will be printed.\n\nParameters ---------- index : DatetimeIndex or TimedeltaIndex If passed a Series will use the values of the series (NOT THE INDEX). warn : bool, default True\n##### Returns\n"},"func6": {"source file: ": "frequencies1.py","line number: ": "528","func name: ": "_is_multiple","func arg: ": "(us, mult)","comments: ": ""},"func7": {"source file: ": "frequencies1.py","line number: ": "532","func name: ": "_maybe_add_count","func arg: ": "(base, count)","comments: ": ""}}{}{"func1": {"source file: ": "function1.py","line number: ": "73","func name: ": "process_skipna","func arg: ": "(skipna, args)","comments: ": ""},"func2": {"source file: ": "function1.py","line number: ": "81","func name: ": "validate_argmin_with_skipna","func arg: ": "(skipna, args, kwargs)","comments: ": "If 'Series.argmin' is called via the 'numpy' library, the third parameter in its signature is 'out', which takes either an ndarray or 'None', so check if the 'skipna' parameter is either an instance of ndarray or is None, since 'skipna' itself should be a boolean\n\n\n"},"func3": {"source file: ": "function1.py","line number: ": "95","func name: ": "validate_argmax_with_skipna","func arg: ": "(skipna, args, kwargs)","comments: ": "If 'Series.argmax' is called via the 'numpy' library, the third parameter in its signature is 'out', which takes either an ndarray or 'None', so check if the 'skipna' parameter is either an instance of ndarray or is None, since 'skipna' itself should be a boolean\n\n\n"},"func4": {"source file: ": "function1.py","line number: ": "133","func name: ": "validate_argsort_with_ascending","func arg: ": "(ascending, args, kwargs)","comments: ": "If 'Categorical.argsort' is called via the 'numpy' library, the first parameter in its signature is 'axis', which takes either an integer or 'None', so check if the 'ascending' parameter has either integer type or is None, since 'ascending' itself should be a boolean\n\n\n"},"func5": {"source file: ": "function1.py","line number: ": "156","func name: ": "validate_clip_with_axis","func arg: ": "(axis, args, kwargs)","comments: ": "If 'NDFrame.clip' is called via the numpy library, the third parameter in its signature is 'out', which can takes an ndarray, so check if the 'axis' parameter is an instance of ndarray, since 'axis' itself should either be an integer or None\n\n\n"},"func6": {"source file: ": "function1.py","line number: ": "183","func name: ": "validate_cum_func_with_skipna","func arg: ": "(skipna, args, kwargs, name)","comments: ": "If this function is called via the 'numpy' library, the third parameter in its signature is 'dtype', which takes either a 'numpy' dtype or 'None', so check if the 'skipna' parameter is a boolean or not\n\n\n"},"func7": {"source file: ": "function1.py","line number: ": "281","func name: ": "validate_take_with_convert","func arg: ": "(convert, args, kwargs)","comments: ": "If this function is called via the 'numpy' library, the third parameter in its signature is 'axis', which takes either an ndarray or 'None', so check if the 'convert' parameter is either an instance of ndarray or is None\n\n\n"},"func8": {"source file: ": "function1.py","line number: ": "303","func name: ": "validate_window_func","func arg: ": "(name, args, kwargs)","comments: ": ""},"func9": {"source file: ": "function1.py","line number: ": "318","func name: ": "validate_rolling_func","func arg: ": "(name, args, kwargs)","comments: ": ""},"func10": {"source file: ": "function1.py","line number: ": "333","func name: ": "validate_expanding_func","func arg: ": "(name, args, kwargs)","comments: ": ""},"func11": {"source file: ": "function1.py","line number: ": "348","func name: ": "validate_groupby_func","func arg: ": "(name, args, kwargs, allowed)","comments: ": "'args' and 'kwargs' should be empty, except for allowed kwargs because all of their necessary parameters are explicitly listed in the function signature\n\n\n"},"func12": {"source file: ": "function1.py","line number: ": "371","func name: ": "validate_resampler_func","func arg: ": "(method, args, kwargs)","comments: ": "'args' and 'kwargs' should be empty because all of their necessary parameters are explicitly listed in the function signature\n\n\n"},"func13": {"source file: ": "function1.py","line number: ": "388","func name: ": "validate_minmax_axis","func arg: ": "(axis)","comments: ": "Ensure that the axis argument passed to min, max, argmin, or argmax is zero or None, as otherwise it will be incorrectly ignored.\n\nParameters ---------- axis : int or None\n"}}{"func1": {"source file: ": "gbq1.py","line number: ": "10","func name: ": "_try_import","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "gbq1.py","line number: ": "21","func name: ": "read_gbq","func arg: ": "(query, project_id, index_col, col_order, reauth, auth_local_webserver, dialect, location, configuration, credentials, use_bqstorage_api, private_key, verbose, progress_bar_type)","comments: ": "Load data from Google BigQuery.\n\nThis function requires the `pandas-gbq package <https://pandas-gbq.readthedocs.io>`__.\n\nSee the `How to authenticate with Google BigQuery <https://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html>`__ guide for authentication instructions.\n\nParameters ---------- query : str SQL-Like Query to return data values. project_id : str, optional Google BigQuery Account project ID. Optional when available from the environment. index_col : str, optional Name of result column to use for index in results DataFrame. col_order : list(str), optional List of BigQuery column names in the desired order for results DataFrame. reauth : bool, default False Force Google BigQuery to re-authenticate the user. This is useful if multiple accounts are used. auth_local_webserver : bool, default False Use the `local webserver flow`_ instead of the `console flow`_ when getting user credentials.\n\n.. _local webserver flow: http://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_local_server .. _console flow: http://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_console\n\n*New in version 0.2.0 of pandas-gbq*. dialect : str, default 'legacy' Note: The default value is changing to 'standard' in a future version.\n\nSQL syntax dialect to use. Value can be one of:\n\n``'legacy'`` Use BigQuery's legacy SQL dialect. For more information see `BigQuery Legacy SQL Reference <https://cloud.google.com/bigquery/docs/reference/legacy-sql>`__. ``'standard'`` Use BigQuery's standard SQL, which is compliant with the SQL 2011 standard. For more information see `BigQuery Standard SQL Reference <https://cloud.google.com/bigquery/docs/reference/standard-sql/>`__.\n\n.. versionchanged:: 0.24.0 location : str, optional Location where the query job should run. See the `BigQuery locations documentation <https://cloud.google.com/bigquery/docs/dataset-locations>`__ for a list of available locations. The location must match that of any datasets used in the query.\n\n*New in version 0.5.0 of pandas-gbq*. configuration : dict, optional Query config parameters for job processing. For example:\n\nconfiguration = {'query': {'useQueryCache': False}}\n\nFor more information see `BigQuery REST API Reference <https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query>`__. credentials : google.auth.credentials.Credentials, optional Credentials for accessing Google APIs. Use this parameter to override default credentials, such as to use Compute Engine :class:`google.auth.compute_engine.Credentials` or Service Account :class:`google.oauth2.service_account.Credentials` directly.\n\n*New in version 0.8.0 of pandas-gbq*.\n\n.. versionadded:: 0.24.0 use_bqstorage_api : bool, default False Use the `BigQuery Storage API <https://cloud.google.com/bigquery/docs/reference/storage/>`__ to download query results quickly, but at an increased cost. To use this API, first `enable it in the Cloud Console <https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com>`__. You must also have the `bigquery.readsessions.create <https://cloud.google.com/bigquery/docs/access-control#roles>`__ permission on the project you are billing queries to.\n\nThis feature requires version 0.10.0 or later of the ``pandas-gbq`` package. It also requires the ``google-cloud-bigquery-storage`` and ``fastavro`` packages.\n\n.. versionadded:: 0.25.0 progress_bar_type : Optional, str If set, use the `tqdm <https://tqdm.github.io/>`__ library to display a progress bar while the data downloads. Install the ``tqdm`` package to use this feature.\n\nPossible values of ``progress_bar_type`` include:\n\n``None`` No progress bar. ``'tqdm'`` Use the :func:`tqdm.tqdm` function to print a progress bar to :data:`sys.stderr`. ``'tqdm_notebook'`` Use the :func:`tqdm.tqdm_notebook` function to display a progress bar as a Jupyter notebook widget. ``'tqdm_gui'`` Use the :func:`tqdm.tqdm_gui` function to display a progress bar as a graphical dialog box.\n\nNote that his feature requires version 0.12.0 or later of the ``pandas-gbq`` package. And it requires the ``tqdm`` package. Slightly different than ``pandas-gbq``, here the default is ``None``.\n\n.. versionadded:: 1.0.0\n##### Returns\n* **df**: DataFrame\nDataFrame representing results of query.\n\n* **pandas_gbq.read_gbq **: This function in the pandas-gbq library.\n\n* **DataFrame.to_gbq **: Write a DataFrame to Google BigQuery.\n\n"},"func3": {"source file: ": "gbq1.py","line number: ": "190","func name: ": "to_gbq","func arg: ": "(dataframe, destination_table, project_id, chunksize, reauth, if_exists, auth_local_webserver, table_schema, location, progress_bar, credentials, verbose, private_key)","comments: ": ""}}{"func1": {"source file: ": "gcs1.py","line number: ": "9","func name: ": "get_filepath_or_buffer","func arg: ": "(filepath_or_buffer, encoding, compression, mode)","comments: ": ""}}{"func1": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "96","func name: ": "_create_sp_series","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "109","func name: ": "_create_sp_tsseries","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "123","func name: ": "_create_sp_frame","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "137","func name: ": "create_data","func arg: ": "()","comments: ": "create the pickle data\n\n\n"},"func5": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "302","func name: ": "create_pickle_data","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "308","func name: ": "platform_name","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "319","func name: ": "write_legacy_pickles","func arg: ": "(output_dir)","comments: ": ""},"func8": {"source file: ": "generate_legacy_storage_files1.py","line number: ": "340","func name: ": "write_legacy_file","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "generic1.py","line number: ": "89","func name: ": "generate_property","func arg: ": "(name, klass)","comments: ": "Create a property for a GroupBy subclass to dispatch to DataFrame/Series.\n\nParameters ---------- name : str klass : {DataFrame, Series}\n##### Returns\n"},"func2": {"source file: ": "generic1.py","line number: ": "112","func name: ": "pin_whitelisted_properties","func arg: ": "(klass, whitelist)","comments: ": "Create GroupBy member defs for DataFrame/Series names in a whitelist.\n\nParameters ---------- klass : DataFrame or Series class class where members are defined. whitelist : frozenset[str] Set of names of klass methods to be constructed\n##### Returns\n"},"func3": {"source file: ": "generic1.py","line number: ": "1873","func name: ": "_is_multi_agg_with_relabel","func arg: ": "(**kwargs)","comments: ": "Check whether kwargs passed to .agg look like multi-agg with relabeling.\n\nParameters ---------- **kwargs : dict\n##### Returns\n"},"func4": {"source file: ": "generic1.py","line number: ": "1900","func name: ": "_normalize_keyword_aggregation","func arg: ": "(kwargs)","comments: ": "Normalize user-provided \"named aggregation\" kwargs.\n\nTransforms from the new ``Mapping[str, NamedAgg]`` style kwargs to the old Dict[str, List[scalar]]].\n\nParameters ---------- kwargs : dict\n##### Returns\n* **aggspec **: dict\nThe transformed kwargs.\n\n* **columns **: List[str]\nThe user-provided keys.\n\n* **col_idx_order **: List[int]\nList of columns indices.\n\n* **>>> _normalize_keyword_aggregation({'output'**: ('input', 'sum')})\n\n* **({'input'**: ['sum']}, ('output',), [('input', 'sum')])\n\n"},"func5": {"source file: ": "generic1.py","line number: ": "1956","func name: ": "_make_unique","func arg: ": "(seq)","comments: ": "Uniquify aggfunc name of the pairs in the order list\n\nExamples: -------- >>> _make_unique([('a', '<lambda>'), ('a', '<lambda>'), ('b', '<lambda>')]) [('a', '<lambda>_0'), ('a', '<lambda>_1'), ('b', '<lambda>')]\n"},"func6": {"source file: ": "generic1.py","line number: ": "1979","func name: ": "_managle_lambda_list","func arg: ": "(aggfuncs)","comments: ": "Possibly mangle a list of aggfuncs.\n\nParameters ---------- aggfuncs : Sequence\n##### Returns\n* **mangled**: list-like\nA new AggSpec sequence, where lambdas have been converted\nto have unique names.\n\n"},"func7": {"source file: ": "generic1.py","line number: ": "2012","func name: ": "_maybe_mangle_lambdas","func arg: ": "(agg_spec)","comments: ": "Make new lambdas with unique names.\n\nParameters ---------- agg_spec : Any An argument to GroupBy.agg. Non-dict-like `agg_spec` are pass through as is. For dict-like `agg_spec` a new spec is returned with name-mangled lambdas.\n##### Returns\n* **mangled **: Any\nSame type as the input.\n\n* **>>> _maybe_mangle_lambdas([lambda**: 1, lambda\n\n"},"func8": {"source file: ": "generic1.py","line number: ": "2057","func name: ": "_recast_datetimelike_result","func arg: ": "(result)","comments: ": "If we have date/time like in the original, then coerce dates as we are stacking can easily have object dtypes here.\n\nParameters ---------- result : DataFrame\n##### Returns\n"}}{"func1": {"source file: ": "generic2.py","line number: ": "6","func name: ": "create_pandas_abc_type","func arg: ": "(name, attr, comp)","comments: ": ""}}{"func1": {"source file: ": "generic3.py","line number: ": "118","func name: ": "_single_replace","func arg: ": "(to_replace, method, inplace, limit)","comments: ": "Replaces values in a Series using the fill method specified when no replacement value is given in the replace method\n\n\n"},"func2": {"source file: ": "generic3.py","line number: ": "10481","func name: ": "_doc_parms","func arg: ": "(cls)","comments: ": "Return a tuple of the doc parms.\n\n\n"},"func3": {"source file: ": "generic3.py","line number: ": "11140","func name: ": "_make_min_count_stat_function","func arg: ": "(cls, name, name1, name2, axis_descr, desc, f, see_also, examples)","comments: ": ""},"func4": {"source file: ": "generic3.py","line number: ": "11188","func name: ": "_make_stat_function","func arg: ": "(cls, name, name1, name2, axis_descr, desc, f, see_also, examples)","comments: ": ""},"func5": {"source file: ": "generic3.py","line number: ": "11221","func name: ": "_make_stat_function_ddof","func arg: ": "(cls, name, name1, name2, axis_descr, desc, f)","comments: ": ""},"func6": {"source file: ": "generic3.py","line number: ": "11243","func name: ": "_make_cum_function","func arg: ": "(cls, name, name1, name2, axis_descr, desc, accum_func, accum_func_name, mask_a, mask_b, examples)","comments: ": ""},"func7": {"source file: ": "generic3.py","line number: ": "11338","func name: ": "_make_logical_function","func arg: ": "(cls, name, name1, name2, axis_descr, desc, f, see_also, examples, empty_value)","comments: ": ""}}{}{}{"func1": {"source file: ": "groupby2.py","line number: ": "340","func name: ": "_group_selection_context","func arg: ": "(groupby)","comments: ": "Set / reset the _group_selection_context.\n\n\n"},"func2": {"source file: ": "groupby2.py","line number: ": "2529","func name: ": "get_groupby","func arg: ": "(obj, by, axis, level, grouper, exclusions, selection, as_index, sort, group_keys, squeeze, observed, mutated)","comments: ": ""}}{"func1": {"source file: ": "groupe1.py","line number: ": "426","func name: ": "get_grouper","func arg: ": "(obj, key, axis, level, sort, observed, mutated, validate)","comments: ": "Create and return a BaseGrouper, which is an internal mapping of how to create the grouper indexers. This may be composed of multiple Grouping objects, indicating multiple groupers\n\nGroupers are ultimately index mappings. They can originate as: index mappings, keys to columns, functions, or Groupers\n\nGroupers enable local references to axis,level,sort, while the passed in axis, level, and sort are 'global'.\n\nThis routine tries to figure out what the passing in references are and then creates a Grouping for each one, combined into a BaseGrouper.\n\nIf observed & we have a categorical grouper, only show the observed values.\n\nIf validate, then check for key/level overlaps.\n"},"func2": {"source file: ": "groupe1.py","line number: ": "643","func name: ": "_is_label_like","func arg: ": "(val)","comments: ": ""},"func3": {"source file: ": "groupe1.py","line number: ": "647","func name: ": "_convert_grouper","func arg: ": "(axis, grouper)","comments: ": ""}}{"func1": {"source file: ": "hashing1.py","line number: ": "30","func name: ": "_combine_hash_arrays","func arg: ": "(arrays, num_items)","comments: ": "Parameters ---------- arrays : generator num_items : int\n\nShould be the same as CPython's tupleobject.c\n"},"func2": {"source file: ": "hashing1.py","line number: ": "58","func name: ": "hash_pandas_object","func arg: ": "(obj, index, encoding, hash_key, categorize)","comments: ": "Return a data hash of the Index/Series/DataFrame.\n\nParameters ---------- index : bool, default True Include the index in the hash (if Series/DataFrame). encoding : str, default 'utf8' Encoding for data & key when strings. hash_key : str, default _default_hash_key Hash_key for string key to encode. categorize : bool, default True Whether to first categorize object arrays before hashing. This is more efficient when the array contains duplicate values.\n##### Returns\n"},"func3": {"source file: ": "hashing1.py","line number: ": "145","func name: ": "hash_tuples","func arg: ": "(vals, encoding, hash_key)","comments: ": "Hash an MultiIndex / list-of-tuples efficiently\n\nParameters ---------- vals : MultiIndex, list-of-tuples, or single tuple encoding : str, default 'utf8' hash_key : str, default _default_hash_key\n##### Returns\n"},"func4": {"source file: ": "hashing1.py","line number: ": "188","func name: ": "hash_tuple","func arg: ": "(val, encoding, hash_key)","comments: ": "Hash a single tuple efficiently\n\nParameters ---------- val : single tuple encoding : str, default 'utf8' hash_key : str, default _default_hash_key\n##### Returns\n"},"func5": {"source file: ": "hashing1.py","line number: ": "210","func name: ": "_hash_categorical","func arg: ": "(c, encoding, hash_key)","comments: ": "Hash a Categorical by hashing its categories, and then mapping the codes to the hashes\n\nParameters ---------- c : Categorical encoding : str hash_key : str\n##### Returns\n"},"func6": {"source file: ": "hashing1.py","line number: ": "248","func name: ": "hash_array","func arg: ": "(vals, encoding, hash_key, categorize)","comments: ": "Given a 1d array, return an array of deterministic integers.\n\nParameters ---------- vals : ndarray, Categorical encoding : str, default 'utf8' Encoding for data & key when strings. hash_key : str, default _default_hash_key Hash_key for string key to encode. categorize : bool, default True Whether to first categorize object arrays before hashing. This is more efficient when the array contains duplicate values.\n##### Returns\n"},"func7": {"source file: ": "hashing1.py","line number: ": "327","func name: ": "_hash_scalar","func arg: ": "(val, encoding, hash_key)","comments: ": "Hash scalar value.\n\nParameters ---------- val : scalar encoding : str, default \"utf8\" hash_key : str, default _default_hash_key\n##### Returns\n"}}{"func1": {"source file: ": "hist1.py","line number: ": "166","func name: ": "_grouped_plot","func arg: ": "(plotf, data, column, by, numeric_only, figsize, sharex, sharey, layout, rot, ax, **kwargs)","comments: ": ""},"func2": {"source file: ": "hist1.py","line number: ": "209","func name: ": "_grouped_hist","func arg: ": "(data, column, by, ax, bins, figsize, layout, sharex, sharey, rot, grid, xlabelsize, xrot, ylabelsize, yrot, **kwargs)","comments: ": "Grouped histogram\n\nParameters ---------- data : Series/DataFrame column : object, optional by : object, optional ax : axes, optional bins : int, default 50 figsize : tuple, optional layout : optional sharex : bool, default False sharey : bool, default False rot : int, default 90 grid : bool, default True kwargs : dict, keyword arguments passed to matplotlib.Axes.hist\n##### Returns\n"},"func3": {"source file: ": "hist1.py","line number: ": "279","func name: ": "hist_series","func arg: ": "(by, ax, grid, xlabelsize, xrot, ylabelsize, yrot, figsize, bins, **kwds)","comments: ": ""},"func4": {"source file: ": "hist1.py","line number: ": "344","func name: ": "hist_frame","func arg: ": "(data, column, by, grid, xlabelsize, xrot, ylabelsize, yrot, ax, sharex, sharey, figsize, layout, bins, **kwds)","comments: ": ""}}{"func1": {"source file: ": "holiday1.py","line number: ": "15","func name: ": "next_monday","func arg: ": "(dt)","comments: ": "If holiday falls on Saturday, use following Monday instead; if holiday falls on Sunday, use Monday instead\n\n\n"},"func2": {"source file: ": "holiday1.py","line number: ": "27","func name: ": "next_monday_or_tuesday","func arg: ": "(dt)","comments: ": "For second holiday of two adjacent ones! If holiday falls on Saturday, use following Monday instead; if holiday falls on Sunday or Monday, use following Tuesday instead (because Monday is already taken by adjacent holiday on the day before)\n\n\n"},"func3": {"source file: ": "holiday1.py","line number: ": "42","func name: ": "previous_friday","func arg: ": "(dt)","comments: ": "If holiday falls on Saturday or Sunday, use previous Friday instead.\n\n\n"},"func4": {"source file: ": "holiday1.py","line number: ": "53","func name: ": "sunday_to_monday","func arg: ": "(dt)","comments: ": "If holiday falls on Sunday, use day thereafter (Monday) instead.\n\n\n"},"func5": {"source file: ": "holiday1.py","line number: ": "62","func name: ": "weekend_to_monday","func arg: ": "(dt)","comments: ": "If holiday falls on Sunday or Saturday, use day thereafter (Monday) instead. Needed for holidays such as Christmas observation in Europe\n\n\n"},"func6": {"source file: ": "holiday1.py","line number: ": "75","func name: ": "nearest_workday","func arg: ": "(dt)","comments: ": "If holiday falls on Saturday, use day before (Friday) instead; if holiday falls on Sunday, use day thereafter (Monday) instead.\n\n\n"},"func7": {"source file: ": "holiday1.py","line number: ": "87","func name: ": "next_workday","func arg: ": "(dt)","comments: ": "returns next weekday used for observances\n\n\n"},"func8": {"source file: ": "holiday1.py","line number: ": "98","func name: ": "previous_workday","func arg: ": "(dt)","comments: ": "returns previous weekday used for observances\n\n\n"},"func9": {"source file: ": "holiday1.py","line number: ": "109","func name: ": "before_nearest_workday","func arg: ": "(dt)","comments: ": "returns previous workday after nearest workday\n\n\n"},"func10": {"source file: ": "holiday1.py","line number: ": "116","func name: ": "after_nearest_workday","func arg: ": "(dt)","comments: ": "returns next workday after nearest workday needed for Boxing day or multiple holidays in a series\n\n\n"},"func11": {"source file: ": "holiday1.py","line number: ": "315","func name: ": "register","func arg: ": "(cls)","comments: ": ""},"func12": {"source file: ": "holiday1.py","line number: ": "323","func name: ": "get_calendar","func arg: ": "(name)","comments: ": "Return an instance of a calendar based on its name.\n\nParameters ---------- name : str Calendar name to return an instance of\n"},"func13": {"source file: ": "holiday1.py","line number: ": "531","func name: ": "HolidayCalendarFactory","func arg: ": "(name, base, other, base_class)","comments: ": ""}}{}{"func1": {"source file: ": "html2.py","line number: ": "29","func name: ": "_importers","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "html2.py","line number: ": "60","func name: ": "_remove_whitespace","func arg: ": "(s, regex)","comments: ": "Replace extra whitespace inside of a string with a single space.\n\nParameters ---------- s : str or unicode The string from which to remove extra whitespace. regex : re.Pattern The regular expression to use to remove extra whitespace.\n##### Returns\n* **subd **: str or unicode\n`s` with all extra whitespace replaced with a single space.\n\n"},"func3": {"source file: ": "html2.py","line number: ": "79","func name: ": "_get_skiprows","func arg: ": "(skiprows)","comments: ": "Get an iterator given an integer, slice or container.\n\nParameters ---------- skiprows : int, slice, container The iterator to use to skip rows; can also be a slice.\n##### Returns\n* **it **: iterable\nA proper iterator to use to skip rows of a DataFrame.\n\n"},"func4": {"source file: ": "html2.py","line number: ": "108","func name: ": "_read","func arg: ": "(obj)","comments: ": "Try to read from a url, file or string.\n\nParameters ---------- obj : str, unicode, or file-like\n##### Returns\n* **raw_text **: str\n\n"},"func5": {"source file: ": "html2.py","line number: ": "604","func name: ": "_build_xpath_expr","func arg: ": "(attrs)","comments: ": "Build an xpath expression to simulate bs4's ability to pass in kwargs to search for attributes when using the lxml parser.\n\nParameters ---------- attrs : dict A dict of HTML attributes. These are NOT checked for validity.\n##### Returns\n* **expr **: unicode\nAn XPath expression that checks for the given HTML attributes.\n\n"},"func6": {"source file: ": "html2.py","line number: ": "767","func name: ": "_expand_elements","func arg: ": "(body)","comments: ": ""},"func7": {"source file: ": "html2.py","line number: ": "778","func name: ": "_data_to_frame","func arg: ": "(**kwargs)","comments: ": ""},"func8": {"source file: ": "html2.py","line number: ": "811","func name: ": "_parser_dispatch","func arg: ": "(flavor)","comments: ": "Choose the parser based on the input flavor.\n\nParameters ---------- flavor : str The type of parser to use. This must be a valid backend.\n##### Returns\n* **cls **: _HtmlFrameParser subclass\nThe parser class based on the requested input flavor.\n\n"},"func9": {"source file: ": "html2.py","line number: ": "852","func name: ": "_print_as_set","func arg: ": "(s)","comments: ": ""},"func10": {"source file: ": "html2.py","line number: ": "857","func name: ": "_validate_flavor","func arg: ": "(flavor)","comments: ": ""},"func11": {"source file: ": "html2.py","line number: ": "885","func name: ": "_parse","func arg: ": "(flavor, io, match, attrs, encoding, displayed_only, **kwargs)","comments: ": ""},"func12": {"source file: ": "html2.py","line number: ": "926","func name: ": "read_html","func arg: ": "(io, match, flavor, header, index_col, skiprows, attrs, parse_dates, thousands, encoding, decimal, converters, na_values, keep_default_na, displayed_only)","comments: ": "Read HTML tables into a ``list`` of ``DataFrame`` objects.\n\nParameters ---------- io : str, path object or file-like object A URL, a file-like object, or a raw string containing HTML. Note that lxml only accepts the http, ftp and file url protocols. If you have a URL that starts with ``'https'`` you might try removing the ``'s'``.\n\nmatch : str or compiled regular expression, optional The set of tables containing text matching this regex or string will be returned. Unless the HTML is extremely simple you will probably need to pass a non-empty string here. Defaults to '.+' (match any non-empty string). The default value will return all tables contained on a page. This value is converted to a regular expression so that there is consistent behavior between Beautiful Soup and lxml.\n\nflavor : str or None The parsing engine to use. 'bs4' and 'html5lib' are synonymous with each other, they are both there for backwards compatibility. The default of ``None`` tries to use ``lxml`` to parse and if that fails it falls back on ``bs4`` + ``html5lib``.\n\nheader : int or list-like or None, optional The row (or list of rows for a :class:`~pandas.MultiIndex`) to use to make the columns headers.\n\nindex_col : int or list-like or None, optional The column (or list of columns) to use to create the index.\n\nskiprows : int or list-like or slice or None, optional Number of rows to skip after parsing the column integer. 0-based. If a sequence of integers or a slice is given, will skip the rows indexed by that sequence.\n\nNote that a single element sequence means 'skip the nth row' whereas an integer means 'skip n rows'.\n\nattrs : dict or None, optional This is a dictionary of attributes that you can pass to use to identify the table in the HTML. These are not checked for validity before being passed to lxml or Beautiful Soup. However, these attributes must be valid HTML table attributes to work correctly. For example, ::\n\nattrs = {'id': 'table'}\n\nis a valid attribute dictionary because the 'id' HTML tag attribute is a valid HTML attribute for *any* HTML tag as per `this document <http://www.w3.org/TR/html-markup/global-attributes.html>`__. ::\n\nattrs = {'asdf': 'table'}\n\nis *not* a valid attribute dictionary because 'asdf' is not a valid HTML attribute even if it is a valid XML attribute.\n\nValid HTML 4.01 table attributes can be found `here <http://www.w3.org/TR/REC-html40/struct/tables.html#h-11.2>`__. A working draft of the HTML 5 spec can be found `here <http://www.w3.org/TR/html-markup/table.html>`__. It contains the latest information on table attributes for the modern web.\n\nparse_dates : bool, optional See :func:`~read_csv` for more details.\n\nthousands : str, optional Separator to use to parse thousands. Defaults to ``','``.\n\nencoding : str or None, optional The encoding used to decode the web page. Defaults to ``None``.``None`` preserves the previous encoding behavior, which depends on the underlying parser library (e.g., the parser library will try to use the encoding provided by the document).\n\ndecimal : str, default '.' Character to recognize as decimal point (e.g. use ',' for European data).\n\nconverters : dict, default None Dict of functions for converting values in certain columns. Keys can either be integers or column labels, values are functions that take one input argument, the cell (not column) content, and return the transformed content.\n\nna_values : iterable, default None Custom NA values.\n\nkeep_default_na : bool, default True If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they're appended to.\n\ndisplayed_only : bool, default True Whether elements with \"display: none\" should be parsed.\n##### Returns\n* **Before using this function you should read the **: ref\n\n* **the body (by putting rows with only ``<th>`` elements into the header).\n.. versionadded**: \n\n* **Similar to **: func\n\n* **This function will *always* return a list of **: class\n\n* **See the **: ref\n\n"}}{}{"func1": {"source file: ": "indexers2.py","line number: ": "23","func name: ": "is_list_like_indexer","func arg: ": "(key)","comments: ": "Check if we have a list-like indexer that is *not* a NamedTuple.\n\nParameters ---------- key : object\n##### Returns\n"},"func2": {"source file: ": "indexers2.py","line number: ": "39","func name: ": "is_scalar_indexer","func arg: ": "(indexer, arr_value)","comments: ": "Return True if we are all scalar indexers.\n\n\n##### Returns\n"},"func3": {"source file: ": "indexers2.py","line number: ": "54","func name: ": "is_empty_indexer","func arg: ": "(indexer, arr_value)","comments: ": "Check if we have an empty indexer.\n\nParameters ---------- indexer : object arr_value : np.ndarray\n##### Returns\n"},"func4": {"source file: ": "indexers2.py","line number: ": "80","func name: ": "check_setitem_lengths","func arg: ": "(indexer, value, values)","comments: ": "Validate that value and indexer are the same length.\n\nAn special-case is allowed for when the indexer is a boolean array and the number of true values equals the length of ``value``. In this case, no exception is raised.\n\nParameters ---------- indexer : sequence Key for the setitem. value : array-like Value for the setitem. values : array-like Values being set into.\n##### Returns\n"},"func5": {"source file: ": "indexers2.py","line number: ": "129","func name: ": "validate_indices","func arg: ": "(indices, n)","comments: ": "Perform bounds-checking for an indexer.\n\n-1 is allowed for indicating missing values.\n\nParameters ---------- indices : ndarray n : int Length of the array being indexed.\n"},"func6": {"source file: ": "indexers2.py","line number: ": "173","func name: ": "maybe_convert_indices","func arg: ": "(indices, n)","comments: ": "Attempt to convert indices into valid, positive indices.\n\nIf we have negative indices, translate to positive here. If we have indices that are out-of-bounds, raise an IndexError.\n\nParameters ---------- indices : array-like Array of indices that we are to convert. n : int Number of elements in the array that we are indexing.\n##### Returns\n"},"func7": {"source file: ": "indexers2.py","line number: ": "221","func name: ": "length_of_indexer","func arg: ": "(indexer, target)","comments: ": "Return the length of a single non-tuple indexer which could be a slice.\n\n\n##### Returns\n"},"func8": {"source file: ": "indexers2.py","line number: ": "255","func name: ": "deprecate_ndim_indexing","func arg: ": "(result)","comments: ": "Helper function to raise the deprecation warning for multi-dimensional indexing on 1D Series/Index.\n\nGH#27125 indexer like idx[:, None] expands dim, but we cannot do that and keep an index, so we currently return ndarray, which is deprecated (Deprecation GH#30588).\n"},"func9": {"source file: ": "indexers2.py","line number: ": "278","func name: ": "check_array_indexer","func arg: ": "(array, indexer)","comments: ": "Check if `indexer` is a valid array indexer for `array`.\n\nFor a boolean mask, `array` and `indexer` are checked to have the same length. The dtype is validated, and if it is an integer or boolean ExtensionArray, it is checked if there are missing values present, and it is converted to the appropriate numpy array. Other dtypes will raise an error.\n\nNon-array indexers (integer, slice, Ellipsis, tuples, ..) are passed through as is.\n\n.. versionadded:: 1.0.0\n\nParameters ---------- array : array-like The array that is being indexed (only used for the length). indexer : array-like or list-like The array-like that's used to index. List-like input that is not yet a numpy array or an ExtensionArray is converted to one. Other input types are passed through as is\n##### Returns\n"}}{"func1": {"source file: ": "indexing.py","line number: ": "2241","func name: ": "_tuplify","func arg: ": "(ndim, loc)","comments: ": "Given an indexer for the first dimension, create an equivalent tuple for indexing over all dimensions.\n\nParameters ---------- ndim : int loc : object\n##### Returns\n"},"func2": {"source file: ": "indexing.py","line number: ": "2261","func name: ": "convert_to_index_sliceable","func arg: ": "(obj, key)","comments: ": "If we are index sliceable, then return my slicer, otherwise return None.\n\n\n"},"func3": {"source file: ": "indexing.py","line number: ": "2286","func name: ": "check_bool_indexer","func arg: ": "(index, key)","comments: ": "Check if key is a valid boolean indexer for an object with such index and perform reindexing or conversion if needed.\n\nThis function assumes that is_bool_indexer(key) == True.\n\nParameters ---------- index : Index Index of the object on which the indexing is done. key : list-like Boolean indexer to check.\n##### Returns\n"},"func4": {"source file: ": "indexing.py","line number: ": "2333","func name: ": "convert_missing_indexer","func arg: ": "(indexer)","comments: ": "Reverse convert a missing indexer, which is a dict return the scalar indexer and a boolean indicating if we converted\n\n\n"},"func5": {"source file: ": "indexing.py","line number: ": "2350","func name: ": "convert_from_missing_indexer_tuple","func arg: ": "(indexer, axes)","comments: ": "Create a filtered indexer that doesn't have any missing indexers.\n\n\n"},"func6": {"source file: ": "indexing.py","line number: ": "2361","func name: ": "maybe_convert_ix","func arg: ": "()","comments: ": "We likely want to take the cross-product.\n\n\n"},"func7": {"source file: ": "indexing.py","line number: ": "2376","func name: ": "is_nested_tuple","func arg: ": "(tup, labels)","comments: ": "Returns ------- bool\n\n\n"},"func8": {"source file: ": "indexing.py","line number: ": "2394","func name: ": "is_label_like","func arg: ": "(key)","comments: ": "Returns ------- bool\n\n\n"},"func9": {"source file: ": "indexing.py","line number: ": "2404","func name: ": "need_slice","func arg: ": "(obj)","comments: ": "Returns ------- bool\n\n\n"},"func10": {"source file: ": "indexing.py","line number: ": "2417","func name: ": "_non_reducing_slice","func arg: ": "(slice_)","comments: ": "Ensurse that a slice doesn't reduce to a Series or Scalar.\n\nAny user-paseed `subset` should have this called on it to make sure we're always working with DataFrames.\n"},"func11": {"source file: ": "indexing.py","line number: ": "2456","func name: ": "_maybe_numeric_slice","func arg: ": "(df, slice_, include_bool)","comments: ": "Want nice defaults for background_gradient that don't break with non-numeric data. But if slice_ is passed go with that.\n\n\n"},"func12": {"source file: ": "indexing.py","line number: ": "2469","func name: ": "_can_do_equal_len","func arg: ": "(labels, value, plane_indexer, lplane_indexer, obj)","comments: ": "Returns ------- bool True if we have an equal len settable.\n\n\n"}}{"func1": {"source file: ": "inference1.py","line number: ": "29","func name: ": "is_number","func arg: ": "(obj)","comments: ": "Check if the object is a number.\n\n\n##### Returns\n* **is_number **: bool\nWhether `obj` is a number or not.\n\n* **api.types.is_integer**: Checks a subgroup of numbers.\n\n"},"func2": {"source file: ": "inference1.py","line number: ": "70","func name: ": "_iterable_not_string","func arg: ": "(obj)","comments: ": "Check if the object is an iterable but not a string.\n\nParameters ---------- obj : The object to check.\n##### Returns\n* **is_iter_not_string **: bool\nWhether `obj` is a non-string iterable.\n\n"},"func3": {"source file: ": "inference1.py","line number: ": "96","func name: ": "is_iterator","func arg: ": "(obj)","comments: ": "Check if the object is an iterator.\n\nFor example, lists are considered iterators but not strings or datetime objects.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_iter **: bool\nWhether `obj` is an iterator.\n\n"},"func4": {"source file: ": "inference1.py","line number: ": "130","func name: ": "is_file_like","func arg: ": "(obj)","comments: ": "Check if the object is a file-like object.\n\nFor objects to be considered file-like, they must be an iterator AND have either a `read` and/or `write` method as an attribute.\n\nNote: file-like objects must be iterable, but iterable objects need not be file-like.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_file_like **: bool\nWhether `obj` has file-like properties.\n\n"},"func5": {"source file: ": "inference1.py","line number: ": "168","func name: ": "is_re","func arg: ": "(obj)","comments: ": "Check if the object is a regex pattern instance.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_regex **: bool\nWhether `obj` is a regex pattern.\n\n"},"func6": {"source file: ": "inference1.py","line number: ": "191","func name: ": "is_re_compilable","func arg: ": "(obj)","comments: ": "Check if the object can be compiled into a regex pattern instance.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_regex_compilable **: bool\nWhether `obj` can be compiled as a regex pattern.\n\n"},"func7": {"source file: ": "inference1.py","line number: ": "220","func name: ": "is_array_like","func arg: ": "(obj)","comments: ": "Check if the object is array-like.\n\nFor an object to be considered array-like, it must be list-like and have a `dtype` attribute.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_array_like **: bool\nWhether `obj` has array-like properties.\n\n"},"func8": {"source file: ": "inference1.py","line number: ": "253","func name: ": "is_nested_list_like","func arg: ": "(obj)","comments: ": "Check if the object is list-like, and that all of its elements are also list-like.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_list_like **: bool\nWhether `obj` has list-like properties.\n\n"},"func9": {"source file: ": "inference1.py","line number: ": "299","func name: ": "is_dict_like","func arg: ": "(obj)","comments: ": "Check if the object is dict-like.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_dict_like **: bool\nWhether `obj` has dict-like properties.\n\n* **>>> is_dict_like({1**: 2})\n\n"},"func10": {"source file: ": "inference1.py","line number: ": "331","func name: ": "is_named_tuple","func arg: ": "(obj)","comments: ": "Check if the object is a named tuple.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_named_tuple **: bool\nWhether `obj` is a named tuple.\n\n"},"func11": {"source file: ": "inference1.py","line number: ": "358","func name: ": "is_hashable","func arg: ": "(obj)","comments: ": "Return True if hash(obj) will succeed, False otherwise.\n\nSome types will pass a test against collections.abc.Hashable but fail when they are actually hashed with hash().\n\nDistinguish between these and other types by trying the call to hash() and seeing if they raise TypeError.\n##### Returns\n"},"func12": {"source file: ": "inference1.py","line number: ": "395","func name: ": "is_sequence","func arg: ": "(obj)","comments: ": "Check if the object is a sequence of objects. String types are not included as sequences here.\n\nParameters ---------- obj : The object to check\n##### Returns\n* **is_sequence **: bool\nWhether `obj` is a sequence of objects.\n\n"}}{"func1": {"source file: ": "integer1.py","line number: ": "116","func name: ": "integer_array","func arg: ": "(values, dtype, copy)","comments: ": "Infer and return an integer array of the values.\n\nParameters ---------- values : 1D list-like dtype : dtype, optional dtype to coerce copy : bool, default False\n##### Returns\n"},"func2": {"source file: ": "integer1.py","line number: ": "139","func name: ": "safe_cast","func arg: ": "(values, dtype, copy)","comments: ": "Safely cast the values to the dtype if they are equivalent, meaning floats must be equivalent to the ints.\n\n\n"},"func3": {"source file: ": "integer1.py","line number: ": "160","func name: ": "coerce_to_array","func arg: ": "(values, dtype, mask, copy)","comments: ": "Coerce the input values array to numpy arrays with a mask\n\nParameters ---------- values : 1D list-like dtype : integer dtype mask : bool 1D array, optional copy : bool, default False if True, copy the input\n##### Returns\n"}}{}{"func1": {"source file: ": "interval1.py","line number: ": "79","func name: ": "_get_next_label","func arg: ": "(label)","comments: ": ""},"func2": {"source file: ": "interval1.py","line number: ": "93","func name: ": "_get_prev_label","func arg: ": "(label)","comments: ": ""},"func3": {"source file: ": "interval1.py","line number: ": "107","func name: ": "_new_IntervalIndex","func arg: ": "(cls, d)","comments: ": "This is called upon unpickling, rather than the default which doesn't have arguments and breaks __new__.\n\n\n"},"func4": {"source file: ": "interval1.py","line number: ": "1194","func name: ": "_is_valid_endpoint","func arg: ": "(endpoint)","comments: ": "Helper for interval_range to check if start/end are valid types.\n\n\n"},"func5": {"source file: ": "interval1.py","line number: ": "1208","func name: ": "_is_type_compatible","func arg: ": "(a, b)","comments: ": "Helper for interval_range to check type compat of start/end/freq.\n\n\n"},"func6": {"source file: ": "interval1.py","line number: ": "1222","func name: ": "interval_range","func arg: ": "(start, end, periods, freq, name, closed)","comments: ": "Return a fixed frequency IntervalIndex.\n\nParameters ---------- start : numeric or datetime-like, default None Left bound for generating intervals. end : numeric or datetime-like, default None Right bound for generating intervals. periods : int, default None Number of periods to generate. freq : numeric, str, or DateOffset, default None The length of each interval. Must be consistent with the type of start and end, e.g. 2 for numeric, or '5H' for datetime-like.\n\nDefault is 1 for numeric and 'D' for datetime-like. name : str, default None Name of the resulting IntervalIndex. closed : {'left', 'right', 'both', 'neither'}, default 'right' Whether the intervals are closed on the left-side, right-side, both or neither.\n##### Returns\n* **IntervalIndex **: An Index of intervals that are all closed on the same side.\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n"}}{"func1": {"source file: ": "interval2.py","line number: ": "1337","func name: ": "maybe_convert_platform_interval","func arg: ": "(values)","comments: ": "Try to do platform conversion, with special casing for IntervalArray. Wrapper around maybe_convert_platform that alters the default return dtype in certain cases to be compatible with IntervalArray.  For example, empty lists return with integer dtype instead of object dtype, which is prohibited for IntervalArray.\n\nParameters ---------- values : array-like\n##### Returns\n"}}{"func1": {"source file: ": "invalid1.py","line number: ": "9","func name: ": "invalid_comparison","func arg: ": "(left, right, op)","comments: ": "If a comparison has mismatched types and is not necessarily meaningful, follow python3 conventions by\n\n- returning all-False for equality\n\n- returning all-True for inequality\n\n- raising TypeError otherwise\n\nParameters ---------- left : array-like right : scalar, array-like op : operator.{eq, ne, lt, le, gt}\n"},"func2": {"source file: ": "invalid1.py","line number: ": "38","func name: ": "make_invalid_op","func arg: ": "(name)","comments: ": "Return a binary method that always raises a TypeError.\n\nParameters ---------- name : str\n##### Returns\n* **invalid_op **: function\n\n"}}{}{}{"func1": {"source file: ": "localization1.py","line number: ": "15","func name: ": "set_locale","func arg: ": "(new_locale, lc_var)","comments: ": "Context manager for temporarily setting a locale.\n\nParameters ---------- new_locale : str or tuple A string of the form <language_country>.<encoding>. For example to set the current locale to US English with a UTF8 encoding, you would pass \"en_US.UTF-8\". lc_var : int, default `locale.LC_ALL` The category of the locale being set.\n\nNotes ----- This is useful when you want to run a particular block of code under a particular locale, without globally setting the locale. This probably isn't thread-safe.\n"},"func2": {"source file: ": "localization1.py","line number: ": "47","func name: ": "can_set_locale","func arg: ": "(lc, lc_var)","comments: ": "Check to see if we can set a locale, and subsequently get the locale, without raising an Exception.\n\nParameters ---------- lc : str The locale to attempt to set. lc_var : int, default `locale.LC_ALL` The category of the locale being set.\n##### Returns\n* **is_valid **: bool\nWhether the passed locale can be set\n\n"},"func3": {"source file: ": "localization1.py","line number: ": "75","func name: ": "_valid_locales","func arg: ": "(locales, normalize)","comments: ": "Return a list of normalized locales that do not throw an ``Exception`` when set.\n\nParameters ---------- locales : str A string where each locale is separated by a newline. normalize : bool Whether to call ``locale.normalize`` on each locale.\n##### Returns\n* **valid_locales **: list\nA list of valid locales.\n\n"},"func4": {"source file: ": "localization1.py","line number: ": "100","func name: ": "_default_locale_getter","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "localization1.py","line number: ": "105","func name: ": "get_locales","func arg: ": "(prefix, normalize, locale_getter)","comments: ": "Get all the locales that are available on the system.\n\nParameters ---------- prefix : str If not ``None`` then return only those locales with the prefix provided. For example to get all English language locales (those that start with ``\"en\"``), pass ``prefix=\"en\"``. normalize : bool Call ``locale.normalize`` on the resulting list of available locales. If ``True``, only locales that can be set without throwing an ``Exception`` are returned. locale_getter : callable The function to use to retrieve the current locales. This should return a string with each locale separated by a newline character.\n##### Returns\n* **locales **: list of strings\nA list of locale strings that can be set with ``locale.setlocale()``.\nFor example\n\n"}}{"func1": {"source file: ": "managers1.py","line number: ": "1643","func name: ": "create_block_manager_from_blocks","func arg: ": "(blocks, axes)","comments: ": ""},"func2": {"source file: ": "managers1.py","line number: ": "1667","func name: ": "create_block_manager_from_arrays","func arg: ": "(arrays, names, axes)","comments: ": ""},"func3": {"source file: ": "managers1.py","line number: ": "1678","func name: ": "construction_error","func arg: ": "(tot_items, block_shape, axes, e)","comments: ": "raise a helpful message about our construction\n\n\n"},"func4": {"source file: ": "managers1.py","line number: ": "1700","func name: ": "form_blocks","func arg: ": "(arrays, names, axes)","comments: ": ""},"func5": {"source file: ": "managers1.py","line number: ": "1797","func name: ": "_simple_blockify","func arg: ": "(tuples, dtype)","comments: ": "return a single array of a block that has a single dtype; if dtype is not None, coerce to this dtype\n\n\n"},"func6": {"source file: ": "managers1.py","line number: ": "1811","func name: ": "_multi_blockify","func arg: ": "(tuples, dtype)","comments: ": "return an array of blocks that potentially have different dtypes\n\n\n"},"func7": {"source file: ": "managers1.py","line number: ": "1828","func name: ": "_stack_arrays","func arg: ": "(tuples, dtype)","comments: ": ""},"func8": {"source file: ": "managers1.py","line number: ": "1855","func name: ": "_interleaved_dtype","func arg: ": "(blocks)","comments: ": "Find the common dtype for `blocks`.\n\nParameters ---------- blocks : List[Block]\n##### Returns\n* **dtype **: Optional[Union[np.dtype, ExtensionDtype]]\nNone is returned when `blocks` is empty.\n\n"},"func9": {"source file: ": "managers1.py","line number: ": "1875","func name: ": "_consolidate","func arg: ": "(blocks)","comments: ": "Merge blocks having same dtype, exclude non-consolidating blocks\n\n\n"},"func10": {"source file: ": "managers1.py","line number: ": "1893","func name: ": "_compare_or_regex_search","func arg: ": "(a, b, regex)","comments: ": "Compare two array_like inputs of the same shape or two scalar values\n\nCalls operator.eq or re.search, depending on regex argument. If regex is True, perform an element-wise regex matching.\n\nParameters ---------- a : array_like or scalar b : array_like or scalar regex : bool, default False\n##### Returns\n* **mask **: array_like of bool\n\n"},"func11": {"source file: ": "managers1.py","line number: ": "1941","func name: ": "_transform_index","func arg: ": "(index, func, level)","comments: ": "Apply function to all values found in index.\n\nThis includes transforming multiindex entries separately. Only apply function to one level of the MultiIndex if level is specified.\n"},"func12": {"source file: ": "managers1.py","line number: ": "1963","func name: ": "_fast_count_smallints","func arg: ": "(arr)","comments: ": "Faster version of set(arr) for sequences of small numbers.\n\n\n"},"func13": {"source file: ": "managers1.py","line number: ": "1970","func name: ": "_preprocess_slice_or_indexer","func arg: ": "(slice_or_indexer, length, allow_fill)","comments: ": ""},"func14": {"source file: ": "managers1.py","line number: ": "1988","func name: ": "concatenate_block_managers","func arg: ": "(mgrs_indexers, axes, concat_axis, copy)","comments: ": "Concatenate block managers into one.\n\nParameters ---------- mgrs_indexers : list of (BlockManager, {axis: indexer,...}) tuples axes : list of Index concat_axis : int copy : bool\n"}}{"func1": {"source file: ": "mask_ops1.py","line number: ": "11","func name: ": "kleene_or","func arg: ": "(left, right, left_mask, right_mask)","comments: ": "Boolean ``or`` using Kleene logic.\n\nValues are NA where we have ``NA | NA`` or ``NA | False``. ``NA | True`` is considered True.\n\nParameters ---------- left, right : ndarray, NA, or bool The values of the array. left_mask, right_mask : ndarray, optional The masks. Only one of these may be None, which implies that the associated `left` or `right` value is a scalar.\n##### Returns\n* **result, mask**: ndarray[bool]\nThe result of the logical or, and the new mask.\n\n"},"func2": {"source file: ": "mask_ops1.py","line number: ": "72","func name: ": "kleene_xor","func arg: ": "(left, right, left_mask, right_mask)","comments: ": "Boolean ``xor`` using Kleene logic.\n\nThis is the same as ``or``, with the following adjustments\n\n* True, True -> False * True, NA\n\n -> NA\n\nParameters ---------- left, right : ndarray, NA, or bool The values of the array. left_mask, right_mask : ndarray, optional The masks. Only one of these may be None, which implies that the associated `left` or `right` value is a scalar.\n##### Returns\n* **result, mask**: ndarray[bool]\nThe result of the logical xor, and the new mask.\n\n"},"func3": {"source file: ": "mask_ops1.py","line number: ": "119","func name: ": "kleene_and","func arg: ": "(left, right, left_mask, right_mask)","comments: ": "Boolean ``and`` using Kleene logic.\n\nValues are ``NA`` for ``NA & NA`` or ``True & NA``.\n\nParameters ---------- left, right : ndarray, NA, or bool The values of the array. left_mask, right_mask : ndarray, optional The masks. Only one of these may be None, which implies that the associated `left` or `right` value is a scalar.\n##### Returns\n* **result, mask**: ndarray[bool]\nThe result of the logical xor, and the new mask.\n\n"},"func4": {"source file: ": "mask_ops1.py","line number: ": "176","func name: ": "raise_for_nan","func arg: ": "(value, method)","comments: ": ""}}{}{"func1": {"source file: ": "melt1.py","line number: ": "25","func name: ": "melt","func arg: ": "(frame, id_vars, value_vars, var_name, value_name, col_level)","comments: ": ""},"func2": {"source file: ": "melt1.py","line number: ": "126","func name: ": "lreshape","func arg: ": "(data, groups, dropna, label)","comments: ": "Reshape long-format data to wide. Generalized inverse of DataFrame.pivot\n\nParameters ---------- data : DataFrame groups : dict {new_name : list_of_columns} dropna : boolean, default True\n\nExamples -------- >>> data = pd.DataFrame({'hr1': [514, 573], 'hr2': [545, 526], ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'team': ['Red Sox', 'Yankees'], ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'year1': [2007, 2007], 'year2': [2008, 2008]}) >>> data hr1\n\nhr2\n\n\n\n team\n\nyear1\n\nyear2 0\n\n514\n\n545\n\nRed Sox\n\n 2007\n\n 2008 1\n\n573\n\n526\n\nYankees\n\n 2007\n\n 2008\n\n>>> pd.lreshape(data, {'year': ['year1', 'year2'], 'hr': ['hr1', 'hr2']}) team\n\nyear\n\n hr 0\n\nRed Sox\n\n2007\n\n514 1\n\nYankees\n\n2007\n\n573 2\n\nRed Sox\n\n2008\n\n545 3\n\nYankees\n\n2008\n\n526\n##### Returns\n* **reshaped **: DataFrame\n\n"},"func3": {"source file: ": "melt1.py","line number: ": "195","func name: ": "wide_to_long","func arg: ": "(df, stubnames, i, j, sep, suffix)","comments: ": "Wide panel to long format. Less flexible but more user-friendly than melt.\n\nWith stubnames ['A', 'B'], this function expects to find one or more group of columns with format A-suffix1, A-suffix2,..., B-suffix1, B-suffix2,... You specify what you want to call this suffix in the resulting long format with `j` (for example `j='year'`)\n\nEach row of these wide variables are assumed to be uniquely identified by `i` (can be a single column name or a list of column names)\n\nAll remaining variables in the data frame are left intact.\n\nParameters ---------- df : DataFrame The wide-format DataFrame. stubnames : str or list-like The stub name(s). The wide format variables are assumed to start with the stub names. i : str or list-like Column(s) to use as id variable(s). j : str The name of the sub-observation variable. What you wish to name your suffix in the long format. sep : str, default \"\" A character indicating the separation of the variable names in the wide format, to be stripped from the names in the long format. For example, if your column names are A-suffix1, A-suffix2, you can strip the hyphen by specifying `sep='-'`. suffix : str, default '\\\\d+' A regular expression capturing the wanted suffixes. '\\\\d+' captures numeric suffixes. Suffixes with no numbers could be specified with the negated character class '\\\\D+'. You can also further disambiguate suffixes, for example, if your wide variables are of the form A-one, B-two,.., and you have an unrelated column A-rating, you can ignore the last one by specifying `suffix='(!?one|two)'`.\n\n.. versionchanged:: 0.23.0 When all suffixes are numeric, they are cast to int64/float64.\n##### Returns\n* **>>> df = pd.DataFrame({\"A1970\" **: {0\n\n* **...\"A1980\" **: {0\n\n* **...\"B1970\" **: {0\n\n* **...\"B1980\" **: {0\n\n* **...\"X\" **: dict(zip(range(3), np.random.randn(3)))\n\n* **... # doctest**: +NORMALIZE_WHITESPACE\n  ht\n\n* **... 'famid'**: [1, 1, 1, 2, 2, 2, 3, 3, 3],\n\n* **... 'birth'**: [1, 2, 3, 1, 2, 3, 1, 2, 3],\n\n* **... 'ht1'**: [2.8, 2.9, 2.2, 2, 1.8, 1.9, 2.2, 2.3, 2.1],\n\n* **... 'ht2'**: [3.4, 3.8, 2.9, 3.2, 2.8, 2.4, 3.3, 3.4, 2.9]\n\n* **>>> df = pd.DataFrame({'A(weekly)-2010'**: np.random.rand(3),\n\n* **...'A(weekly)-2011'**: np.random.rand(3),\n\n* **...'B(weekly)-2010'**: np.random.rand(3),\n\n* **...'B(weekly)-2011'**: np.random.rand(3),\n\n* **...'X' **: np.random.randint(3, size=3)})\n\n* **>>> df # doctest**: +NORMALIZE_WHITESPACE, +ELLIPSIS\n   A(weekly)-2010  A(weekly)-2011  B(weekly)-2010  B(weekly)-2011  X  id\n\n* **... 'ht_one'**: [2.8, 2.9, 2.2, 2, 1.8, 1.9, 2.2, 2.3, 2.1],\n\n* **... 'ht_two'**: [3.4, 3.8, 2.9, 3.2, 2.8, 2.4, 3.3, 3.4, 2.9]\n\n"}}{"func1": {"source file: ": "merge1.py","line number: ": "58","func name: ": "merge","func arg: ": "(left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate)","comments: ": ""},"func2": {"source file: ": "merge1.py","line number: ": "95","func name: ": "_groupby_and_merge","func arg: ": "(by, on, left, right, _merge_pieces, check_duplicates)","comments: ": "groupby & merge; we are always performing a left-by type operation\n\nParameters ---------- by: field to group on: duplicates field left: left frame right: right frame _merge_pieces: function for merging check_duplicates: bool, default True should we check & clean duplicates\n"},"func3": {"source file: ": "merge1.py","line number: ": "177","func name: ": "merge_ordered","func arg: ": "(left, right, on, left_on, right_on, left_by, right_by, fill_method, suffixes, how)","comments: ": "Perform merge with optional filling/interpolation.\n\nDesigned for ordered data like time series data. Optionally perform group-wise merge (see examples).\n\nParameters ---------- left : DataFrame right : DataFrame on : label or list Field names to join on. Must be found in both DataFrames. left_on : label or list, or array-like Field names to join on in left DataFrame. Can be a vector or list of vectors of the length of the DataFrame to use a particular vector as the join key instead of columns. right_on : label or list, or array-like Field names to join on in right DataFrame or vector/list of vectors per left_on docs. left_by : column name or list of column names Group left DataFrame by group columns and merge piece by piece with right DataFrame. right_by : column name or list of column names Group right DataFrame by group columns and merge piece by piece with left DataFrame. fill_method : {'ffill', None}, default None Interpolation method for data. suffixes : Sequence, default is (\"_x\", \"_y\") A length-2 sequence where each element is optionally a string indicating the suffix to add to overlapping column names in `left` and `right` respectively. Pass a value of `None` instead of a string to indicate that the column name from `left` or `right` should be left as-is, with no suffix. At least one of the values must not be None.\n\n.. versionchanged:: 0.25.0 how : {'left', 'right', 'outer', 'inner'}, default 'outer' * left: use only keys from left frame (SQL: left outer join) * right: use only keys from right frame (SQL: right outer join) * outer: use union of keys from both frames (SQL: full outer join) * inner: use intersection of keys from both frames (SQL: inner join).\n##### Returns\n"},"func4": {"source file: ": "merge1.py","line number: ": "307","func name: ": "merge_asof","func arg: ": "(left, right, on, left_on, right_on, left_index, right_index, by, left_by, right_by, suffixes, tolerance, allow_exact_matches, direction)","comments: ": "Perform an asof merge. This is similar to a left-join except that we match on nearest key rather than equal keys.\n\nBoth DataFrames must be sorted by the key.\n\nFor each row in the left DataFrame:\n\n- A \"backward\" search selects the last row in the right DataFrame whose 'on' key is less than or equal to the left's key.\n\n- A \"forward\" search selects the first row in the right DataFrame whose 'on' key is greater than or equal to the left's key.\n\n- A \"nearest\" search selects the row in the right DataFrame whose 'on' key is closest in absolute distance to the left's key.\n\nThe default is \"backward\" and is compatible in versions below 0.20.0. The direction parameter was added in version 0.20.0 and introduces \"forward\" and \"nearest\".\n\nOptionally match on equivalent keys with 'by' before searching with 'on'.\n\nParameters ---------- left : DataFrame right : DataFrame on : label Field name to join on. Must be found in both DataFrames. The data MUST be ordered. Furthermore this must be a numeric column, such as datetimelike, integer, or float. On or left_on/right_on must be given. left_on : label Field name to join on in left DataFrame. right_on : label Field name to join on in right DataFrame. left_index : bool Use the index of the left DataFrame as the join key. right_index : bool Use the index of the right DataFrame as the join key. by : column name or list of column names Match on these columns before performing merge operation. left_by : column name Field names to match on in the left DataFrame. right_by : column name Field names to match on in the right DataFrame. suffixes : 2-length sequence (tuple, list, ...) Suffix to apply to overlapping column names in the left and right side, respectively. tolerance : int or Timedelta, optional, default None Select asof tolerance within this range; must be compatible with the merge index. allow_exact_matches : bool, default True\n\n- If True, allow matching with the same 'on' value (i.e. less-than-or-equal-to / greater-than-or-equal-to)\n\n- If False, don't match the same 'on' value (i.e., strictly less-than / strictly greater-than).\n\ndirection : 'backward' (default), 'forward', or 'nearest' Whether to search for prior, subsequent, or closest matches.\n##### Returns\n* **merged **: DataFrame\n\n* **>>> left = pd.DataFrame({'a'**: [1, 5, 10], 'left_val'\n\n* **>>> right = pd.DataFrame({'a'**: [1, 2, 3, 6, 7],\n\n* **...   'right_val'**: [1, 2, 3, 6, 7]})\n\n* **>>> left = pd.DataFrame({'left_val'**: ['a', 'b', 'c']}, index=[1, 5, 10])\n\n* **>>> right = pd.DataFrame({'right_val'**: [1, 2, 3, 6, 7]},\n\n* **0 2016-05-25 13**: 30\n\n* **1 2016-05-25 13**: 30\n\n* **2 2016-05-25 13**: 30\n\n* **3 2016-05-25 13**: 30\n\n* **4 2016-05-25 13**: 30\n\n* **5 2016-05-25 13**: 30\n\n* **6 2016-05-25 13**: 30\n\n* **7 2016-05-25 13**: 30\n\n"},"func5": {"source file: ": "merge1.py","line number: ": "1284","func name: ": "_get_join_indexers","func arg: ": "(left_keys, right_keys, sort, how, **kwargs)","comments: ": "Parameters ---------- left_keys: ndarray, Index, Series right_keys: ndarray, Index, Series sort: bool, default False how: string {'inner', 'outer', 'left', 'right'}, default 'inner'\n\n\n##### Returns\n"},"func6": {"source file: ": "merge1.py","line number: ": "1331","func name: ": "_restore_dropped_levels_multijoin","func arg: ": "(left, right, dropped_level_names, join_index, lindexer, rindexer)","comments: ": "*this is an internal non-public method*\n\n\n##### Returns\n* **levels **: list of Index\nlevels of combined multiindexes\n\n* **labels **: intp array\nlabels of combined multiindexes\n\n* **names **: str array\nnames of combined multiindexes\n\n"},"func7": {"source file: ": "merge1.py","line number: ": "1496","func name: ": "_asof_function","func arg: ": "(direction)","comments: ": ""},"func8": {"source file: ": "merge1.py","line number: ": "1501","func name: ": "_asof_by_function","func arg: ": "(direction)","comments: ": ""},"func9": {"source file: ": "merge1.py","line number: ": "1513","func name: ": "_get_cython_type_upcast","func arg: ": "(dtype)","comments: ": "Upcast a dtype to 'int64_t', 'double', or 'object'\n\n\n"},"func10": {"source file: ": "merge1.py","line number: ": "1782","func name: ": "_get_multiindex_indexer","func arg: ": "(join_keys, index, sort)","comments: ": ""},"func11": {"source file: ": "merge1.py","line number: ": "1818","func name: ": "_get_single_indexer","func arg: ": "(join_key, index, sort)","comments: ": ""},"func12": {"source file: ": "merge1.py","line number: ": "1828","func name: ": "_left_join_on_index","func arg: ": "(left_ax, right_ax, join_keys, sort)","comments: ": ""},"func13": {"source file: ": "merge1.py","line number: ": "1857","func name: ": "_right_outer_join","func arg: ": "(x, y, max_groups)","comments: ": ""},"func14": {"source file: ": "merge1.py","line number: ": "1870","func name: ": "_factorize_keys","func arg: ": "(lk, rk, sort)","comments: ": ""},"func15": {"source file: ": "merge1.py","line number: ": "1942","func name: ": "_sort_labels","func arg: ": "(uniques, left, right)","comments: ": ""},"func16": {"source file: ": "merge1.py","line number: ": "1957","func name: ": "_get_join_keys","func arg: ": "(llab, rlab, shape, sort)","comments: ": ""},"func17": {"source file: ": "merge1.py","line number: ": "1987","func name: ": "_should_fill","func arg: ": "(lname, rname)","comments: ": ""},"func18": {"source file: ": "merge1.py","line number: ": "1993","func name: ": "_any","func arg: ": "(x)","comments: ": ""},"func19": {"source file: ": "merge1.py","line number: ": "1997","func name: ": "_validate_operand","func arg: ": "(obj)","comments: ": ""},"func20": {"source file: ": "merge1.py","line number: ": "2012","func name: ": "_items_overlap_with_suffix","func arg: ": "(left, lsuffix, right, rsuffix)","comments: ": "If two indices overlap, add suffixes to overlapping entries.\n\nIf corresponding suffix is empty, the entry is simply converted to string.\n"}}{}{"func1": {"source file: ": "methods2.py","line number: ": "23","func name: ": "_get_method_wrappers","func arg: ": "(cls)","comments: ": "Find the appropriate operation-wrappers to use when defining flex/special arithmetic, boolean, and comparison operations with the given class.\n\nParameters ---------- cls : class\n##### Returns\n* **arith_flex **: function or None\n\n* **comp_flex **: function or None\n\n* **arith_special **: function\n\n* **comp_special **: function\n\n* **bool_special **: function\n\n"},"func2": {"source file: ": "methods2.py","line number: ": "72","func name: ": "add_special_arithmetic_methods","func arg: ": "(cls)","comments: ": "Adds the full suite of special arithmetic methods (``__add__``, ``__sub__``, etc.) to the class.\n\nParameters ---------- cls : class special methods will be defined and pinned to this class\n"},"func3": {"source file: ": "methods2.py","line number: ": "132","func name: ": "add_flex_arithmetic_methods","func arg: ": "(cls)","comments: ": "Adds the full suite of flex arithmetic methods (``pow``, ``mul``, ``add``) to the class.\n\nParameters ---------- cls : class flex methods will be defined and pinned to this class\n"},"func4": {"source file: ": "methods2.py","line number: ": "159","func name: ": "_create_methods","func arg: ": "(cls, arith_method, comp_method, bool_method, special)","comments: ": ""},"func5": {"source file: ": "methods2.py","line number: ": "225","func name: ": "_add_methods","func arg: ": "(cls, new_methods)","comments: ": ""}}{"func1": {"source file: ": "misc1.py","line number: ": "14","func name: ": "scatter_matrix","func arg: ": "(frame, alpha, figsize, ax, grid, diagonal, marker, density_kwds, hist_kwds, range_padding, **kwds)","comments: ": ""},"func2": {"source file: ": "misc1.py","line number: ": "111","func name: ": "_get_marker_compat","func arg: ": "(marker)","comments: ": ""},"func3": {"source file: ": "misc1.py","line number: ": "117","func name: ": "radviz","func arg: ": "(frame, class_column, ax, color, colormap, **kwds)","comments: ": ""},"func4": {"source file: ": "misc1.py","line number: ": "199","func name: ": "andrews_curves","func arg: ": "(frame, class_column, ax, samples, color, colormap, **kwds)","comments: ": ""},"func5": {"source file: ": "misc1.py","line number: ": "259","func name: ": "bootstrap_plot","func arg: ": "(series, fig, size, samples, **kwds)","comments: ": ""},"func6": {"source file: ": "misc1.py","line number: ": "306","func name: ": "parallel_coordinates","func arg: ": "(frame, class_column, cols, ax, color, use_columns, xticks, colormap, axvlines, axvlines_kwds, sort_labels, **kwds)","comments: ": ""},"func7": {"source file: ": "misc1.py","line number: ": "386","func name: ": "lag_plot","func arg: ": "(series, lag, ax, **kwds)","comments: ": ""},"func8": {"source file: ": "misc1.py","line number: ": "403","func name: ": "autocorrelation_plot","func arg: ": "(series, ax, **kwds)","comments: ": ""}}{}{"func1": {"source file: ": "missing2.py","line number: ": "49","func name: ": "isna","func arg: ": "(obj)","comments: ": "Detect missing values for an array-like object.\n\nThis function takes a scalar or array-like object and indicates whether values are missing (``NaN`` in numeric arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike).\n\nParameters ---------- obj : scalar or array-like Object to check for null or missing values.\n##### Returns\n* **notna **: Boolean inverse of pandas.isna.\n\n* **Series.isna **: Detect missing values in a Series.\n\n* **DataFrame.isna **: Detect missing values in a DataFrame.\n\n* **Index.isna **: Detect missing values in an Index.\n\n* **Name**: 1, dtype\n\n"},"func2": {"source file: ": "missing2.py","line number: ": "132","func name: ": "_isna_new","func arg: ": "(obj)","comments: ": ""},"func3": {"source file: ": "missing2.py","line number: ": "163","func name: ": "_isna_old","func arg: ": "(obj)","comments: ": "Detect missing values, treating None, NaN, INF, -INF as null.\n\nParameters ---------- arr: ndarray or object value\n##### Returns\n"},"func4": {"source file: ": "missing2.py","line number: ": "197","func name: ": "_use_inf_as_na","func arg: ": "(key)","comments: ": "Option change callback for na/inf behaviour.\n\nChoose which replacement for numpy.isnan / -numpy.isfinite is used.\n\nParameters ---------- flag: bool True means treat None, NaN, INF, -INF as null (old way), False means None and NaN are null, but INF, -INF are not null (new way).\n\nNotes ----- This approach to setting global module values is discussed and approved here:\n\n* https://stackoverflow.com/questions/4859217/ programmatically-creating-variables-in-python/4859312#4859312\n"},"func5": {"source file: ": "missing2.py","line number: ": "225","func name: ": "_isna_ndarraylike","func arg: ": "(obj)","comments: ": ""},"func6": {"source file: ": "missing2.py","line number: ": "271","func name: ": "_isna_ndarraylike_old","func arg: ": "(obj)","comments: ": ""},"func7": {"source file: ": "missing2.py","line number: ": "307","func name: ": "notna","func arg: ": "(obj)","comments: ": "Detect non-missing values for an array-like object.\n\nThis function takes a scalar or array-like object and indicates whether values are valid (not missing, which is ``NaN`` in numeric arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike).\n\nParameters ---------- obj : array-like or object value Object to check for *not* null or *non*-missing values.\n##### Returns\n* **isna **: Boolean inverse of pandas.notna.\n\n* **Series.notna **: Detect valid values in a Series.\n\n* **DataFrame.notna **: Detect valid values in a DataFrame.\n\n* **Index.notna **: Detect valid values in an Index.\n\n* **Name**: 1, dtype\n\n"},"func8": {"source file: ": "missing2.py","line number: ": "393","func name: ": "_isna_compat","func arg: ": "(arr, fill_value)","comments: ": "Parameters ---------- arr: a numpy array fill_value: fill value, default to np.nan\n\n\n##### Returns\n"},"func9": {"source file: ": "missing2.py","line number: ": "410","func name: ": "array_equivalent","func arg: ": "(left, right, strict_nan)","comments: ": "True if two arrays, left and right, have equal non-NaN elements, and NaNs in corresponding locations.  False otherwise. It is assumed that left and right are NumPy arrays of the same dtype. The behavior of this function (particularly with respect to NaNs) is not defined if the dtypes are different.\n\nParameters ---------- left, right : ndarrays strict_nan : bool, default False If True, consider NaN and None to be different.\n##### Returns\n"},"func10": {"source file: ": "missing2.py","line number: ": "508","func name: ": "_infer_fill_value","func arg: ": "(val)","comments: ": "infer the fill value for the nan/NaT from the provided scalar/ndarray/list-like if we are a NaT, return the correct dtyped element to provide proper block construction\n\n\n"},"func11": {"source file: ": "missing2.py","line number: ": "529","func name: ": "_maybe_fill","func arg: ": "(arr, fill_value)","comments: ": "if we have a compatible fill_value and arr dtype, then fill\n\n\n"},"func12": {"source file: ": "missing2.py","line number: ": "538","func name: ": "na_value_for_dtype","func arg: ": "(dtype, compat)","comments: ": "Return a dtype compat na value\n\nParameters ---------- dtype : string / dtype compat : bool, default True\n##### Returns\n"},"func13": {"source file: ": "missing2.py","line number: ": "586","func name: ": "remove_na_arraylike","func arg: ": "(arr)","comments: ": "Return array-like containing only true/non-NaN values, possibly empty.\n\n\n"},"func14": {"source file: ": "missing2.py","line number: ": "596","func name: ": "is_valid_nat_for_dtype","func arg: ": "(obj, dtype)","comments: ": "isna check that excludes incompatible dtypes\n\nParameters ---------- obj : object dtype : np.datetime64, np.timedelta64, DatetimeTZDtype, or PeriodDtype\n##### Returns\n"}}{"func1": {"source file: ": "missing3.py","line number: ": "33","func name: ": "fill_zeros","func arg: ": "(result, x, y)","comments: ": "If this is a reversed op, then flip x,y\n\nIf we have an integer value (or array in y) and we have 0's, fill them with np.nan, return the result.\n\nMask the nan's from x.\n"},"func2": {"source file: ": "missing3.py","line number: ": "73","func name: ": "mask_zero_div_zero","func arg: ": "(x, y, result)","comments: ": "Set results of 0 / 0 or 0 // 0 to np.nan, regardless of the dtypes of the numerator or the denominator.\n\nParameters ---------- x : ndarray y : ndarray result : ndarray\n##### Returns\n* **filled_result **: ndarray\n\n"},"func3": {"source file: ": "missing3.py","line number: ": "136","func name: ": "dispatch_fill_zeros","func arg: ": "(op, left, right, result)","comments: ": "Call fill_zeros with the appropriate fill value depending on the operation, with special logic for divmod and rdivmod.\n\nParameters ---------- op : function (operator.add, operator.div, ...) left : object (np.ndarray for non-reversed ops) right : object (np.ndarray for reversed ops) result : ndarray\n##### Returns\n* **result **: np.ndarray\n\n"}}{"func1": {"source file: ": "missing4.py","line number: ": "24","func name: ": "mask_missing","func arg: ": "(arr, values_to_mask)","comments: ": "Return a masking array of same size/shape as arr with entries equaling any member of values_to_mask set to True\n\n\n"},"func2": {"source file: ": "missing4.py","line number: ": "73","func name: ": "clean_fill_method","func arg: ": "(method, allow_nearest)","comments: ": ""},"func3": {"source file: ": "missing4.py","line number: ": "95","func name: ": "clean_interp_method","func arg: ": "(method, **kwargs)","comments: ": ""},"func4": {"source file: ": "missing4.py","line number: ": "124","func name: ": "find_valid_index","func arg: ": "(values, how)","comments: ": "Retrieves the index of the first valid value.\n\nParameters ---------- values : ndarray or ExtensionArray how : {'first', 'last'} Use this parameter to change between the first or last valid index.\n##### Returns\n"},"func5": {"source file: ": "missing4.py","line number: ": "161","func name: ": "interpolate_1d","func arg: ": "(xvalues, yvalues, method, limit, limit_direction, limit_area, fill_value, bounds_error, order, **kwargs)","comments: ": "Logic for the 1-d interpolation.  The result should be 1-d, inputs xvalues and yvalues will each be 1-d arrays of the same length.\n\nBounds_error is currently hardcoded to False since non-scipy ones don't take it as an argument.\n"},"func6": {"source file: ": "missing4.py","line number: ": "317","func name: ": "_interpolate_scipy_wrapper","func arg: ": "(x, y, new_x, method, fill_value, bounds_error, order, **kwargs)","comments: ": "Passed off to scipy.interpolate.interp1d. method is scipy's kind. Returns an array interpolated at new_x.  Add any new methods to the list in _clean_interp_method.\n\n\n"},"func7": {"source file: ": "missing4.py","line number: ": "390","func name: ": "_from_derivatives","func arg: ": "(xi, yi, x, order, der, extrapolate)","comments: ": "Convenience function for interpolate.BPoly.from_derivatives.\n\nConstruct a piecewise polynomial in the Bernstein basis, compatible with the specified values and derivatives at breakpoints.\n\nParameters ---------- xi : array_like sorted 1D array of x-coordinates yi : array_like or list of array-likes yi[i][j] is the j-th derivative known at xi[i] order: None or int or array_like of ints. Default: None. Specifies the degree of local polynomials. If not None, some derivatives are ignored. der : int or list How many derivatives to extract; None for all potentially nonzero derivatives (that is a number equal to the number of points), or a list of derivatives to extract. This numberincludes the function value as 0th derivative. extrapolate : bool, optional Whether to extrapolate to ouf-of-bounds points based on first and last intervals, or to return NaNs. Default: True.\n\nSee Also -------- scipy.interpolate.BPoly.from_derivatives\n##### Returns\n* **y **: scalar or array_like\nThe result, of length R or length M or M by R.\n\n"},"func8": {"source file: ": "missing4.py","line number: ": "433","func name: ": "_akima_interpolate","func arg: ": "(xi, yi, x, der, axis)","comments: ": "Convenience function for akima interpolation. xi and yi are arrays of values used to approximate some function f, with ``yi = f(xi)``.\n\nSee `Akima1DInterpolator` for details.\n\nParameters ---------- xi : array_like A sorted list of x-coordinates, of length N. yi : array_like A 1-D array of real values.\n\n`yi`'s length along the interpolation axis must be equal to the length of `xi`. If N-D array, use axis parameter to select correct axis. x : scalar or array_like Of length M. der : int or list, optional How many derivatives to extract; None for all potentially nonzero derivatives (that is a number equal to the number of points), or a list of derivatives to extract. This number includes the function value as 0th derivative. axis : int, optional Axis in the yi array corresponding to the x-coordinate values.\n\nSee Also -------- scipy.interpolate.Akima1DInterpolator\n##### Returns\n* **y **: scalar or array_like\nThe result, of length R or length M or M by R,\n\n"},"func9": {"source file: ": "missing4.py","line number: ": "481","func name: ": "interpolate_2d","func arg: ": "(values, method, axis, limit, fill_value, dtype)","comments: ": "Perform an actual interpolation of values, values will be make 2-d if needed fills inplace, returns the result.\n\n\n"},"func10": {"source file: ": "missing4.py","line number: ": "523","func name: ": "_cast_values_for_fillna","func arg: ": "(values, dtype)","comments: ": "Cast values to a dtype that algos.pad and algos.backfill can handle.\n\n\n"},"func11": {"source file: ": "missing4.py","line number: ": "544","func name: ": "_fillna_prep","func arg: ": "(values, mask, dtype)","comments: ": ""},"func12": {"source file: ": "missing4.py","line number: ": "559","func name: ": "pad_1d","func arg: ": "(values, limit, mask, dtype)","comments: ": ""},"func13": {"source file: ": "missing4.py","line number: ": "565","func name: ": "backfill_1d","func arg: ": "(values, limit, mask, dtype)","comments: ": ""},"func14": {"source file: ": "missing4.py","line number: ": "571","func name: ": "pad_2d","func arg: ": "(values, limit, mask, dtype)","comments: ": ""},"func15": {"source file: ": "missing4.py","line number: ": "582","func name: ": "backfill_2d","func arg: ": "(values, limit, mask, dtype)","comments: ": ""},"func16": {"source file: ": "missing4.py","line number: ": "596","func name: ": "get_fill_func","func arg: ": "(method)","comments: ": ""},"func17": {"source file: ": "missing4.py","line number: ": "601","func name: ": "clean_reindex_fill_method","func arg: ": "(method)","comments: ": ""},"func18": {"source file: ": "missing4.py","line number: ": "605","func name: ": "_interp_limit","func arg: ": "(invalid, fw_limit, bw_limit)","comments: ": "Get indexers of values that won't be filled because they exceed the limits.\n\nParameters ---------- invalid : boolean ndarray fw_limit : int or None forward limit to index bw_limit : int or None backward limit to index\n##### Returns\n* **.. code-block**: \n\n"},"func19": {"source file: ": "missing4.py","line number: ": "670","func name: ": "_rolling_window","func arg: ": "(a, window)","comments: ": "[True, True, False, True, False], 2 ->\n\n[ [True,\n\nTrue], [True, False], [False, True], [True, False], ]\n"}}{"func1": {"source file: ": "multi1.py","line number: ": "3436","func name: ": "_sparsify","func arg: ": "(label_list, start, sentinel)","comments: ": ""},"func2": {"source file: ": "multi1.py","line number: ": "3464","func name: ": "_get_na_rep","func arg: ": "(dtype)","comments: ": ""},"func3": {"source file: ": "multi1.py","line number: ": "3468","func name: ": "maybe_droplevels","func arg: ": "(index, key)","comments: ": "Attempt to drop level or levels from the given index.\n\nParameters ---------- index: Index key : scalar or tuple\n##### Returns\n"},"func4": {"source file: ": "multi1.py","line number: ": "3499","func name: ": "_coerce_indexer_frozen","func arg: ": "(array_like, categories, copy)","comments: ": "Coerce the array_like indexer to the smallest integer dtype that can encode all of the given categories.\n\nParameters ---------- array_like : array-like categories : array-like copy : bool\n##### Returns\n"}}{"func1": {"source file: ": "nanops1.py","line number: ": "40","func name: ": "set_use_bottleneck","func arg: ": "(v)","comments: ": ""},"func2": {"source file: ": "nanops1.py","line number: ": "132","func name: ": "_bn_ok_dtype","func arg: ": "(dt, name)","comments: ": ""},"func3": {"source file: ": "nanops1.py","line number: ": "153","func name: ": "_has_infs","func arg: ": "(result)","comments: ": ""},"func4": {"source file: ": "nanops1.py","line number: ": "166","func name: ": "_get_fill_value","func arg: ": "(dtype, fill_value, fill_value_typ)","comments: ": "return the correct fill value for the dtype of the values\n\n\n"},"func5": {"source file: ": "nanops1.py","line number: ": "189","func name: ": "_maybe_get_mask","func arg: ": "(values, skipna, mask)","comments: ": "Compute a mask if and only if necessary.\n\nThis function will compute a mask iff it is necessary. Otherwise, return the provided mask (potentially None) when a mask does not need to be computed.\n\nA mask is never necessary if the values array is of boolean or integer dtypes, as these are incapable of storing NaNs. If passing a NaN-capable dtype that is interpretable as either boolean or integer data (eg, timedelta64), a mask must be provided.\n\nIf the skipna parameter is False, a new mask will not be computed.\n\nThe mask is computed using isna() by default. Setting invert=True selects notna() as the masking function.\n\nParameters ---------- values : ndarray input array to potentially compute mask for skipna : bool boolean for whether NaNs should be skipped mask : Optional[ndarray] nan-mask if known\n##### Returns\n"},"func6": {"source file: ": "nanops1.py","line number: ": "234","func name: ": "_get_values","func arg: ": "(values, skipna, fill_value, fill_value_typ, mask)","comments: ": "Utility to get the values view, mask, dtype, dtype_max, and fill_value.\n\nIf both mask and fill_value/fill_value_typ are not None and skipna is True, the values array will be copied.\n\nFor input arrays of boolean or integer dtypes, copies will only occur if a precomputed mask, a fill_value/fill_value_typ, and skipna=True are provided.\n\nParameters ---------- values : ndarray input array to potentially compute mask for skipna : bool boolean for whether NaNs should be skipped fill_value : Any value to fill NaNs with fill_value_typ : str Set to '+inf' or '-inf' to handle dtype-specific infinities mask : Optional[np.ndarray] nan-mask if known\n##### Returns\n* **values **: ndarray\nPotential copy of input value array\n\n* **mask **: Optional[ndarray[bool]]\nMask for values, if deemed necessary to compute\n\n* **dtype **: dtype\ndtype for values\n\n* **dtype_max **: dtype\nplatform independent dtype\n\n* **fill_value **: Any\nfill value used\n\n"},"func7": {"source file: ": "nanops1.py","line number: ": "329","func name: ": "_na_ok_dtype","func arg: ": "(dtype)","comments: ": ""},"func8": {"source file: ": "nanops1.py","line number: ": "334","func name: ": "_wrap_results","func arg: ": "(result, dtype, fill_value)","comments: ": "wrap our results if needed\n\n\n"},"func9": {"source file: ": "nanops1.py","line number: ": "365","func name: ": "_na_for_min_count","func arg: ": "(values, axis)","comments: ": "Return the missing value for `values`.\n\nParameters ---------- values : ndarray axis : int or None axis for the reduction, required if values.ndim > 1.\n##### Returns\n* **result **: scalar or ndarray\nFor 1-D values, returns a scalar of the correct missing type.\nFor 2-D values, returns a 1-D array where each element is missing.\n\n"},"func10": {"source file: ": "nanops1.py","line number: ": "396","func name: ": "nanany","func arg: ": "(values, axis, skipna, mask)","comments: ": "Check if any elements along an axis evaluate to True.\n\nParameters ---------- values : ndarray axis : int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: bool\n\n"},"func11": {"source file: ": "nanops1.py","line number: ": "428","func name: ": "nanall","func arg: ": "(values, axis, skipna, mask)","comments: ": "Check if all elements along an axis evaluate to True.\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: bool\n\n"},"func12": {"source file: ": "nanops1.py","line number: ": "461","func name: ": "nansum","func arg: ": "(values, axis, skipna, min_count, mask)","comments: ": "Sum the elements along an axis ignoring NaNs\n\nParameters ---------- values : ndarray[dtype] axis: int, optional skipna : bool, default True min_count: int, default 0 mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: dtype\n\n"},"func13": {"source file: ": "nanops1.py","line number: ": "501","func name: ": "nanmean","func arg: ": "(values, axis, skipna, mask)","comments: ": "Compute the mean of the element along an axis ignoring NaNs\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: float\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func14": {"source file: ": "nanops1.py","line number: ": "559","func name: ": "nanmedian","func arg: ": "(values, axis, skipna, mask)","comments: ": "Parameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n\n\n##### Returns\n* **result **: float\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func15": {"source file: ": "nanops1.py","line number: ": "627","func name: ": "_get_counts_nanvar","func arg: ": "(value_counts, mask, axis, ddof, dtype)","comments: ": "Get the count of non-null values along an axis, accounting for degrees of freedom.\n\nParameters ---------- values_shape : Tuple[int] shape tuple from values ndarray, used if mask is None mask : Optional[ndarray[bool]] locations in values that should be considered missing axis : Optional[int] axis to count along ddof : int degrees of freedom dtype : type, optional type to use for count\n##### Returns\n* **count **: scalar or array\n\n* **d **: scalar or array\n\n"},"func16": {"source file: ": "nanops1.py","line number: ": "674","func name: ": "nanstd","func arg: ": "(values, axis, skipna, ddof, mask)","comments: ": "Compute the standard deviation along given axis while ignoring NaNs\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True ddof : int, default 1 Delta Degrees of Freedom. The divisor used in calculations is N\n\n- ddof, where N represents the number of elements. mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: float\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func17": {"source file: ": "nanops1.py","line number: ": "711","func name: ": "nanvar","func arg: ": "(values, axis, skipna, ddof, mask)","comments: ": "Compute the variance along given axis while ignoring NaNs\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True ddof : int, default 1 Delta Degrees of Freedom. The divisor used in calculations is N\n\n- ddof, where N represents the number of elements. mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: float\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func18": {"source file: ": "nanops1.py","line number: ": "779","func name: ": "nansem","func arg: ": "(values, axis, skipna, ddof, mask)","comments: ": "Compute the standard error in the mean along given axis while ignoring NaNs\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True ddof : int, default 1 Delta Degrees of Freedom. The divisor used in calculations is N\n\n- ddof, where N represents the number of elements. mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: float64\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func19": {"source file: ": "nanops1.py","line number: ": "822","func name: ": "_nanminmax","func arg: ": "(meth, fill_value_typ)","comments: ": ""},"func20": {"source file: ": "nanops1.py","line number: ": "850","func name: ": "nanargmax","func arg: ": "(values, axis, skipna, mask)","comments: ": "Parameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n\n\n##### Returns\n* **result **: int\nThe index of max value in specified axis or -1 in the NA case\n\n"},"func21": {"source file: ": "nanops1.py","line number: ": "881","func name: ": "nanargmin","func arg: ": "(values, axis, skipna, mask)","comments: ": "Parameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n\n\n##### Returns\n* **result **: int\nThe index of min value in specified axis or -1 in the NA case\n\n"},"func22": {"source file: ": "nanops1.py","line number: ": "912","func name: ": "nanskew","func arg: ": "(values, axis, skipna, mask)","comments: ": "Compute the sample skewness.\n\nThe statistic computed here is the adjusted Fisher-Pearson standardized moment coefficient G1. The algorithm computes this coefficient directly from the second and third central moment.\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: float64\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func23": {"source file: ": "nanops1.py","line number: ": "990","func name: ": "nankurt","func arg: ": "(values, axis, skipna, mask)","comments: ": "Compute the sample excess kurtosis\n\nThe statistic computed here is the adjusted Fisher-Pearson standardized moment coefficient G2, computed directly from the second and fourth central moment.\n\nParameters ---------- values : ndarray axis: int, optional skipna : bool, default True mask : ndarray[bool], optional nan-mask if known\n##### Returns\n* **result **: float64\nUnless input is a float array, in which case use the same\nprecision as the input array.\n\n"},"func24": {"source file: ": "nanops1.py","line number: ": "1078","func name: ": "nanprod","func arg: ": "(values, axis, skipna, min_count, mask)","comments: ": "Parameters ---------- values : ndarray[dtype] axis: int, optional skipna : bool, default True min_count: int, default 0 mask : ndarray[bool], optional nan-mask if known\n\n\n##### Returns\n"},"func25": {"source file: ": "nanops1.py","line number: ": "1113","func name: ": "_maybe_arg_null_out","func arg: ": "(result, axis, mask, skipna)","comments: ": ""},"func26": {"source file: ": "nanops1.py","line number: ": "1137","func name: ": "_get_counts","func arg: ": "(values_shape, mask, axis, dtype)","comments: ": "Get the count of non-null values along an axis\n\nParameters ---------- values_shape : Tuple[int] shape tuple from values ndarray, used if mask is None mask : Optional[ndarray[bool]] locations in values that should be considered missing axis : Optional[int] axis to count along dtype : type, optional type to use for count\n##### Returns\n* **count **: scalar or array\n\n"},"func27": {"source file: ": "nanops1.py","line number: ": "1181","func name: ": "_maybe_null_out","func arg: ": "(result, axis, mask, shape, min_count)","comments: ": ""},"func28": {"source file: ": "nanops1.py","line number: ": "1211","func name: ": "_zero_out_fperr","func arg: ": "(arg)","comments: ": ""},"func29": {"source file: ": "nanops1.py","line number: ": "1221","func name: ": "nancorr","func arg: ": "(a, b, method, min_periods)","comments: ": "a, b: ndarrays\n\n\n"},"func30": {"source file: ": "nanops1.py","line number: ": "1243","func name: ": "get_corr_func","func arg: ": "(method)","comments: ": ""},"func31": {"source file: ": "nanops1.py","line number: ": "1271","func name: ": "nancov","func arg: ": "(a, b, min_periods)","comments: ": ""},"func32": {"source file: ": "nanops1.py","line number: ": "1289","func name: ": "_ensure_numeric","func arg: ": "(x)","comments: ": ""},"func33": {"source file: ": "nanops1.py","line number: ": "1317","func name: ": "make_nancomp","func arg: ": "(op)","comments: ": ""},"func34": {"source file: ": "nanops1.py","line number: ": "1344","func name: ": "_nanpercentile_1d","func arg: ": "(values, mask, q, na_value, interpolation)","comments: ": "Wrapper for np.percentile that skips missing values, specialized to 1-dimensional case.\n\nParameters ---------- values : array over which to find quantiles mask : ndarray[bool] locations in values that should be considered missing q : scalar or array of quantile indices to find na_value : scalar value to return for empty or all-null values interpolation : str\n##### Returns\n* **quantiles **: scalar or array\n\n"},"func35": {"source file: ": "nanops1.py","line number: ": "1375","func name: ": "nanpercentile","func arg: ": "(values, q, axis, na_value, mask, ndim, interpolation)","comments: ": "Wrapper for np.percentile that skips missing values.\n\nParameters ---------- values : array over which to find quantiles q : scalar or array of quantile indices to find axis : {0, 1} na_value : scalar value to return for empty or all-null values mask : ndarray[bool] locations in values that should be considered missing ndim : {1, 2} interpolation : str\n##### Returns\n* **quantiles **: scalar or array\n\n"}}{"func1": {"source file: ": "numba_1.py","line number: ": "11","func name: ": "make_rolling_apply","func arg: ": "(func, args, nogil, parallel, nopython)","comments: ": "Creates a JITted rolling apply function with a JITted version of the user's function.\n\nParameters ---------- func : function function to be applied to each window and will be JITed args : tuple *args to be passed into the function nogil : bool nogil parameter from engine_kwargs for numba.jit parallel : bool parallel parameter from engine_kwargs for numba.jit nopython : bool nopython parameter from engine_kwargs for numba.jit\n##### Returns\n"},"func2": {"source file: ": "numba_1.py","line number: ": "89","func name: ": "generate_numba_apply_func","func arg: ": "(args, kwargs, func, engine_kwargs)","comments: ": "Generate a numba jitted apply function specified by values from engine_kwargs.\n\n1. jit the user's function 2. Return a rolling apply function with the jitted function inline\n\nConfigurations specified in engine_kwargs apply to both the user's function _AND_ the rolling apply function.\n\nParameters ---------- args : tuple *args to be passed into the function kwargs : dict **kwargs to be passed into the function func : function function to be applied to each window and will be JITed engine_kwargs : dict dictionary of arguments to be passed into numba.jit\n##### Returns\n"}}{"func1": {"source file: ": "numeric1.py","line number: ": "19","func name: ": "to_numeric","func arg: ": "(arg, errors, downcast)","comments: ": "Convert argument to a numeric type.\n\nThe default return dtype is `float64` or `int64` depending on the data supplied. Use the `downcast` parameter to obtain other dtypes.\n\nPlease note that precision loss may occur if really large numbers are passed in. Due to the internal limitations of `ndarray`, if numbers smaller than `-9223372036854775808` (np.iinfo(np.int64).min) or larger than `18446744073709551615` (np.iinfo(np.uint64).max) are passed in, it is very likely they will be converted to float so that they can stored in an `ndarray`. These warnings apply similarly to `Series` since it internally leverages `ndarray`.\n\nParameters ---------- arg : scalar, list, tuple, 1-d array, or Series errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n- If 'raise', then invalid parsing will raise an exception.\n\n- If 'coerce', then invalid parsing will be set as NaN.\n\n- If 'ignore', then invalid parsing will return the input. downcast : {'integer', 'signed', 'unsigned', 'float'}, default None If not None, and if the data has been successfully cast to a numerical dtype (or if the data was numeric to begin with), downcast that resulting data to the smallest numerical dtype possible according to the following rules:\n\n- 'integer' or 'signed': smallest signed int dtype (min.: np.int8)\n\n- 'unsigned': smallest unsigned int dtype (min.: np.uint8)\n\n- 'float': smallest float dtype (min.: np.float32)\n\nAs this behaviour is separate from the core conversion to numeric values, any errors raised during the downcasting will be surfaced regardless of the value of the 'errors' input.\n\nIn addition, downcasting will only occur if the size of the resulting data's dtype is strictly larger than the dtype it is to be cast to, so if none of the dtypes checked satisfy that specification, no downcasting will be performed on the data.\n##### Returns\n* **ret **: numeric if parsing succeeded.\nReturn type depends on input.  Series if Series, otherwise ndarray.\n\n* **DataFrame.astype **: Cast argument to a specified dtype.\n\n* **to_datetime **: Convert argument to datetime.\n\n* **to_timedelta **: Convert argument to timedelta.\n\n* **numpy.ndarray.astype **: Cast a numpy array to a specified type.\n\n* **convert_dtypes **: Convert dtypes.\n\n* **dtype**: float64\n\n"}}{}{}{"func1": {"source file: ": "offsets1.py","line number: ": "83","func name: ": "as_timestamp","func arg: ": "(obj)","comments: ": ""},"func2": {"source file: ": "offsets1.py","line number: ": "93","func name: ": "apply_wraps","func arg: ": "(func)","comments: ": ""},"func3": {"source file: ": "offsets1.py","line number: ": "2529","func name: ": "_tick_comp","func arg: ": "(op)","comments: ": ""},"func4": {"source file: ": "offsets1.py","line number: ": "2655","func name: ": "_delta_to_tick","func arg: ": "(delta)","comments: ": ""},"func5": {"source file: ": "offsets1.py","line number: ": "2723","func name: ": "generate_range","func arg: ": "(start, end, periods, offset)","comments: ": "Generates a sequence of dates corresponding to the specified time offset. Similar to dateutil.rrule except uses pandas DateOffset objects to represent time increments.\n\nParameters ---------- start : datetime, (default None) end : datetime, (default None) periods : int, (default None) offset : DateOffset, (default BDay())\n\nNotes ----- * This method is faster for generating weekdays than dateutil.rrule * At least two of (start, end, periods) must be specified. * If both start and end are specified, the returned dates will satisfy start <= date <= end.\n##### Returns\n* **dates **: generator object\n\n"}}{}{"func1": {"source file: ": "ops2.py","line number: ": "866","func name: ": "_is_indexed_like","func arg: ": "(obj, axes)","comments: ": ""},"func2": {"source file: ": "ops2.py","line number: ": "940","func name: ": "get_splitter","func arg: ": "(data, **kwargs)","comments: ": ""}}{"func1": {"source file: ": "ops3.py","line number: ": "249","func name: ": "_in","func arg: ": "(x, y)","comments: ": "Compute the vectorized membership of ``x in y`` if possible, otherwise use Python.\n\n\n"},"func2": {"source file: ": "ops3.py","line number: ": "264","func name: ": "_not_in","func arg: ": "(x, y)","comments: ": "Compute the vectorized membership of ``x not in y`` if possible, otherwise use Python.\n\n\n"},"func3": {"source file: ": "ops3.py","line number: ": "320","func name: ": "_cast_inplace","func arg: ": "(terms, acceptable_dtypes, dtype)","comments: ": "Cast an expression inplace.\n\nParameters ---------- terms : Op The expression that should cast. acceptable_dtypes : list of acceptable numpy.dtype Will not cast if term's dtype in this list. dtype : str or numpy.dtype The dtype to cast to.\n"},"func4": {"source file: ": "ops3.py","line number: ": "345","func name: ": "is_term","func arg: ": "(obj)","comments: ": ""},"func5": {"source file: ": "ops3.py","line number: ": "490","func name: ": "isnumeric","func arg: ": "(dtype)","comments: ": ""}}{"func1": {"source file: ": "orc1.py","line number: ": "14","func name: ": "read_orc","func arg: ": "(path, columns, **kwargs)","comments: ": "Load an ORC object from the file path, returning a DataFrame.\n\n.. versionadded:: 1.0.0\n\nParameters ---------- path : str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.orc``.\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``. columns : list, default None If not None, only these columns will be read from the file. **kwargs Any additional kwargs are passed to pyarrow.\n##### Returns\n"}}{"func1": {"source file: ": "parquet1.py","line number: ": "14","func name: ": "get_engine","func arg: ": "(engine)","comments: ": "return our implementation\n\n\n"},"func2": {"source file: ": "parquet1.py","line number: ": "209","func name: ": "to_parquet","func arg: ": "(df, path, engine, compression, index, partition_cols, **kwargs)","comments: ": "Write a DataFrame to the parquet format.\n\nParameters ---------- df : DataFrame path : str File path or Root Directory path. Will be used as Root Directory path while writing a partitioned dataset.\n\n.. versionchanged:: 0.24.0\n\nengine : {'auto', 'pyarrow', 'fastparquet'}, default 'auto' Parquet library to use. If 'auto', then the option ``io.parquet.engine`` is used. The default ``io.parquet.engine`` behavior is to try 'pyarrow', falling back to 'fastparquet' if 'pyarrow' is unavailable. compression : {'snappy', 'gzip', 'brotli', None}, default 'snappy' Name of the compression to use. Use ``None`` for no compression. index : bool, default None If ``True``, include the dataframe's index(es) in the file output. If ``False``, they will not be written to the file. If ``None``, similar to ``True`` the dataframe's index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn't require much space and is faster. Other indexes will be included as columns in the file output.\n\n.. versionadded:: 0.24.0\n\npartition_cols : str or list, optional, default None Column names by which to partition the dataset Columns are partitioned in the order they are given\n\n.. versionadded:: 0.24.0\n\nkwargs Additional keyword arguments passed to the engine\n"},"func3": {"source file: ": "parquet1.py","line number: ": "270","func name: ": "read_parquet","func arg: ": "(path, engine, columns, **kwargs)","comments: ": "Load a parquet object from the file path, returning a DataFrame.\n\n.. versionadded:: 0.21.0\n\nParameters ---------- path : str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.parquet``. A file URL can also be a path to a directory that contains multiple partitioned parquet files. Both pyarrow and fastparquet support paths to directories as well as file URLs. A directory path could be: ``file://localhost/path/to/tables``\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``. engine : {'auto', 'pyarrow', 'fastparquet'}, default 'auto' Parquet library to use. If 'auto', then the option ``io.parquet.engine`` is used. The default ``io.parquet.engine`` behavior is to try 'pyarrow', falling back to 'fastparquet' if 'pyarrow' is unavailable. columns : list, default=None If not None, only these columns will be read from the file.\n\n.. versionadded:: 0.21.1 **kwargs Any additional kwargs are passed to the engine.\n##### Returns\n"}}{"func1": {"source file: ": "parsers1.py","line number: ": "367","func name: ": "_validate_integer","func arg: ": "(name, val, min_val)","comments: ": "Checks whether the 'name' parameter for parsing is either an integer OR float that can SAFELY be cast to an integer without losing accuracy. Raises a ValueError if that is not the case.\n\nParameters ---------- name : string Parameter name (used for error reporting) val : int or float The value to check min_val : int Minimum allowed value (val < min_val will result in a ValueError)\n"},"func2": {"source file: ": "parsers1.py","line number: ": "396","func name: ": "_validate_names","func arg: ": "(names)","comments: ": "Raise ValueError if the `names` parameter contains duplicates.\n\nParameters ---------- names : array-like or None An array containing a list of the names used for the output DataFrame.\n"},"func3": {"source file: ": "parsers1.py","line number: ": "416","func name: ": "_read","func arg: ": "(filepath_or_buffer, kwds)","comments: ": "Generic reader of line files.\n\n\n"},"func4": {"source file: ": "parsers1.py","line number: ": "529","func name: ": "_make_parser_function","func arg: ": "(name, default_sep)","comments: ": ""},"func5": {"source file: ": "parsers1.py","line number: ": "702","func name: ": "read_fwf","func arg: ": "(filepath_or_buffer, colspecs, widths, infer_nrows, **kwds)","comments: ": "Read a table of fixed-width formatted lines into DataFrame.\n\nAlso supports optionally iterating or breaking of the file into chunks.\n\nAdditional help can be found in the `online docs for IO Tools <https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html>`_.\n\nParameters ---------- filepath_or_buffer : str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.csv``.\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``. colspecs : list of tuple (int, int) or 'infer'. optional A list of tuples giving the extents of the fixed-width fields of each line as half-open intervals (i.e.,\n\n[from, to[ ). String value 'infer' can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data which are not being skipped via skiprows (default='infer'). widths : list of int, optional A list of field widths which can be used instead of 'colspecs' if the intervals are contiguous. infer_nrows : int, default 100 The number of rows to consider when letting the parser determine the `colspecs`.\n\n.. versionadded:: 0.24.0 **kwds : optional Optional keyword arguments can be passed to ``TextFileReader``.\n##### Returns\n* **to_csv **: Write DataFrame to a comma-separated values (csv) file.\n\n* **read_csv **: Read a comma-separated values (csv) file into DataFrame.\n\n* **>>> pd.read_fwf('data.csv')  # doctest**: +SKIP\n\n"},"func6": {"source file: ": "parsers1.py","line number: ": "1170","func name: ": "_is_index_col","func arg: ": "(col)","comments: ": ""},"func7": {"source file: ": "parsers1.py","line number: ": "1174","func name: ": "_is_potential_multi_index","func arg: ": "(columns)","comments: ": "Check whether or not the `columns` parameter could be converted into a MultiIndex.\n\nParameters ---------- columns : array-like Object which may or may not be convertible into a MultiIndex\n##### Returns\n* **boolean **: Whether or not columns could become a MultiIndex\n\n"},"func8": {"source file: ": "parsers1.py","line number: ": "1195","func name: ": "_evaluate_usecols","func arg: ": "(usecols, names)","comments: ": "Check whether or not the 'usecols' parameter is a callable.  If so, enumerates the 'names' parameter and returns a set of indices for each entry in 'names' that evaluates to True. If not a callable, returns 'usecols'.\n\n\n"},"func9": {"source file: ": "parsers1.py","line number: ": "1208","func name: ": "_validate_usecols_names","func arg: ": "(usecols, names)","comments: ": "Validates that all usecols are present in a given list of names. If not, raise a ValueError that shows what usecols are missing.\n\nParameters ---------- usecols : iterable of usecols The columns to validate are present in names. names : iterable of names The column names to check against.\n##### Returns\n* **usecols **: iterable of usecols\nThe `usecols` parameter if the validation succeeds.\n\n"},"func10": {"source file: ": "parsers1.py","line number: ": "1240","func name: ": "_validate_skipfooter_arg","func arg: ": "(skipfooter)","comments: ": "Validate the 'skipfooter' parameter.\n\nChecks whether 'skipfooter' is a non-negative integer.\n##### Returns\n* **validated_skipfooter **: non-negative integer\nThe original input if the validation succeeds.\n\n"},"func11": {"source file: ": "parsers1.py","line number: ": "1271","func name: ": "_validate_usecols_arg","func arg: ": "(usecols)","comments: ": "Validate the 'usecols' parameter.\n\nChecks whether or not the 'usecols' parameter contains all integers (column selection by index), strings (column by name) or is a callable.\n##### Returns\n* **usecols_tuple **: tuple\nA tuple of (verified_usecols, usecols_dtype).\n'verified_usecols' is either a set if an array-like is passed in or\n'usecols' if a callable or None is passed in.\n'usecols_dtype` is the inferred dtype of 'usecols' if an array-like\nis passed in or None if a callable or None is passed in.\n\n"},"func12": {"source file: ": "parsers1.py","line number: ": "1321","func name: ": "_validate_parse_dates_arg","func arg: ": "(parse_dates)","comments: ": "Check whether or not the 'parse_dates' parameter is a non-boolean scalar. Raises a ValueError if that is the case.\n\n\n"},"func13": {"source file: ": "parsers1.py","line number: ": "2146","func name: ": "TextParser","func arg: ": "(**kwds)","comments: ": "Converts lists of lists/tuples into DataFrames with proper type inference and optional (e.g. string to datetime) conversion. Also enables iterating lazily over chunks of large files\n\nParameters ---------- data : file-like object or list delimiter : separator character to use dialect : str or csv.Dialect instance, optional Ignored if delimiter is longer than 1 character names : sequence, default header : int, default 0 Row to use to parse column labels. Defaults to the first row. Prior rows will be discarded index_col : int or list, optional Column or columns to use as the (possibly hierarchical) index has_index_names: bool, default False True if the cols defined in index_col have an index name and are not in the header. na_values : scalar, str, list-like, or dict, optional Additional strings to recognize as NA/NaN. keep_default_na : bool, default True thousands : str, optional Thousands separator comment : str, optional Comment out remainder of line parse_dates : bool, default False keep_date_col : bool, default False date_parser : function, optional skiprows : list of integers Row numbers to skip skipfooter : int Number of line at bottom of file to skip converters : dict, optional Dict of functions for converting values in certain columns. Keys can either be integers or column labels, values are functions that take one input argument, the cell (not column) content, and return the transformed content. encoding : str, optional Encoding to use for UTF when reading/writing (ex. 'utf-8') squeeze : bool, default False returns Series if only one column. infer_datetime_format: bool, default False If True and `parse_dates` is True for a column, try to infer the datetime format based on the first datetime string. If the format can be inferred, there often will be a large parsing speed-up. float_precision : str, optional Specifies which converter the C engine should use for floating-point values. The options are None for the ordinary converter, 'high' for the high-precision converter, and 'round_trip' for the round-trip converter.\n"},"func14": {"source file: ": "parsers1.py","line number: ": "2204","func name: ": "count_empty_vals","func arg: ": "(vals)","comments: ": ""},"func15": {"source file: ": "parsers1.py","line number: ": "3213","func name: ": "_make_date_converter","func arg: ": "(date_parser, dayfirst, infer_datetime_format, cache_dates)","comments: ": ""},"func16": {"source file: ": "parsers1.py","line number: ": "3258","func name: ": "_process_date_conversion","func arg: ": "(data_dict, converter, parse_spec, index_col, index_names, columns, keep_date_col)","comments: ": ""},"func17": {"source file: ": "parsers1.py","line number: ": "3327","func name: ": "_try_convert_dates","func arg: ": "(parser, colspec, data_dict, columns)","comments: ": ""},"func18": {"source file: ": "parsers1.py","line number: ": "3346","func name: ": "_clean_na_values","func arg: ": "(na_values, keep_default_na)","comments: ": ""},"func19": {"source file: ": "parsers1.py","line number: ": "3383","func name: ": "_clean_index_names","func arg: ": "(columns, index_col, unnamed_cols)","comments: ": ""},"func20": {"source file: ": "parsers1.py","line number: ": "3416","func name: ": "_get_empty_meta","func arg: ": "(columns, index_col, index_names, dtype)","comments: ": ""},"func21": {"source file: ": "parsers1.py","line number: ": "3460","func name: ": "_floatify_na_values","func arg: ": "(na_values)","comments: ": ""},"func22": {"source file: ": "parsers1.py","line number: ": "3473","func name: ": "_stringify_na_values","func arg: ": "(na_values)","comments: ": "return a stringified and numeric for these values\n\n\n"},"func23": {"source file: ": "parsers1.py","line number: ": "3498","func name: ": "_get_na_values","func arg: ": "(col, na_values, na_fvalues, keep_default_na)","comments: ": "Get the NaN values for a given column.\n\nParameters ---------- col : str The name of the column. na_values : array-like, dict The object listing the NaN values as strings. na_fvalues : array-like, dict The object listing the NaN values as floats. keep_default_na : bool If `na_values` is a dict, and the column is not mapped in the dictionary, whether to return the default NaN values or the empty set.\n##### Returns\n* **nan_tuple **: A length-two tuple composed of\n1) na_values\n\n"},"func24": {"source file: ": "parsers1.py","line number: ": "3534","func name: ": "_get_col_names","func arg: ": "(colspec, columns)","comments: ": ""}}{"func1": {"source file: ": "parsing1.py","line number: ": "14","func name: ": "create_valid_python_identifier","func arg: ": "(name)","comments: ": "Create valid Python identifiers from any string.\n\nCheck if name contains any special characters. If it contains any special characters, the special characters will be replaced by a special string and a prefix is added.\n"},"func2": {"source file: ": "parsing1.py","line number: ": "65","func name: ": "clean_backtick_quoted_toks","func arg: ": "(tok)","comments: ": "Clean up a column name if surrounded by backticks.\n\nBacktick quoted string are indicated by a certain tokval value. If a string is a backtick quoted token it will processed by :func:`_create_valid_python_identifier` so that the parser can find this string when the query is executed. In this case the tok will get the NAME tokval.\n\nParameters ---------- tok : tuple of int, str ints correspond to the all caps constants in the tokenize module\n##### Returns\n* **tok **: Tuple[int, str]\nEither the input or token or the replacement values\n\n"},"func3": {"source file: ": "parsing1.py","line number: ": "91","func name: ": "clean_column_name","func arg: ": "(name)","comments: ": "Function to emulate the cleaning of a backtick quoted name.\n\nThe purpose for this function is to see what happens to the name of identifier if it goes to the process of being parsed a Python code inside a backtick quoted string and than being cleaned (removed of any special characters).\n\nParameters ---------- name : str Name to be cleaned.\n##### Returns\n* **-----\nFor some cases, a name cannot be converted to a valid Python identifier.\nIn that case **: func\n\n"},"func4": {"source file: ": "parsing1.py","line number: ": "128","func name: ": "tokenize_backtick_quoted_string","func arg: ": "(token_generator, source, string_start)","comments: ": "Creates a token from a backtick quoted string.\n\nMoves the token_generator forwards till right after the next backtick.\n\nParameters ---------- token_generator : Iterator[tokenize.TokenInfo] The generator that yields the tokens of the source string (Tuple[int, str]). The generator is at the first token after the backtick (`)\n\nsource : str The Python source code string.\n\nstring_start : int This is the start of backtick quoted string inside the source string.\n##### Returns\n* **tok**: Tuple[int, str]\nThe token that represents the backtick quoted string.\nThe integer is equal to BACKTICK_QUOTED_STRING (100).\n\n"},"func5": {"source file: ": "parsing1.py","line number: ": "162","func name: ": "tokenize_string","func arg: ": "(source)","comments: ": "Tokenize a Python source code string.\n\nParameters ---------- source : str The Python source code string.\n##### Returns\n* **tok_generator **: Iterator[Tuple[int, str]]\nAn iterator yielding all tokens with only toknum and tokval (Tuple[ing, str]).\n\n"}}{"func1": {"source file: ": "period1.py","line number: ": "59","func name: ": "_new_PeriodIndex","func arg: ": "(cls, **d)","comments: ": ""},"func2": {"source file: ": "period1.py","line number: ": "852","func name: ": "period_range","func arg: ": "(start, end, periods, freq, name)","comments: ": "Return a fixed frequency PeriodIndex.\n\nThe day (calendar) is the default frequency.\n\nParameters ---------- start : str or period-like, default None Left bound for generating periods. end : str or period-like, default None Right bound for generating periods. periods : int, default None Number of periods to generate. freq : str or DateOffset, optional Frequency alias. By default the freq is taken from `start` or `end` if those are Period objects. Otherwise, the default is ``\"D\"`` for daily frequency. name : str, default None Name of the resulting PeriodIndex.\n##### Returns\n* **Of the three parameters**: ``start``, ``end``, and ``periods``, exactly two\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n"}}{"func1": {"source file: ": "period2.py","line number: ": "50","func name: ": "_field_accessor","func arg: ": "(name, alias, docstring)","comments: ": ""},"func2": {"source file: ": "period2.py","line number: ": "761","func name: ": "raise_on_incompatible","func arg: ": "(left, right)","comments: ": "Helper function to render a consistent error message when raising IncompatibleFrequency.\n\nParameters ---------- left : PeriodArray right : None, DateOffset, Period, ndarray, or timedelta-like\n##### Returns\n"},"func3": {"source file: ": "period2.py","line number: ": "794","func name: ": "period_array","func arg: ": "(data, freq, copy)","comments: ": "Construct a new PeriodArray from a sequence of Period scalars.\n\nParameters ---------- data : Sequence of Period objects A sequence of Period objects. These are required to all have the same ``freq.`` Missing values can be indicated by ``None`` or ``pandas.NaT``. freq : str, Tick, or Offset The frequency of every element of the array. This can be specified to avoid inferring the `freq` from `data`. copy : bool, default False Whether to ensure a copy of the data is made.\n##### Returns\n* **Length**: 4, dtype\n\n"},"func4": {"source file: ": "period2.py","line number: ": "876","func name: ": "validate_dtype_freq","func arg: ": "(dtype, freq)","comments: ": "If both a dtype and a freq are available, ensure they match.  If only dtype is available, extract the implied freq.\n\nParameters ---------- dtype : dtype freq : DateOffset or None\n##### Returns\n* **freq **: DateOffset\n\n"},"func5": {"source file: ": "period2.py","line number: ": "909","func name: ": "dt64arr_to_periodarr","func arg: ": "(data, freq, tz)","comments: ": "Convert an datetime-like array to values Period ordinals.\n\nParameters ---------- data : Union[Series[datetime64[ns]], DatetimeIndex, ndarray[datetime64ns]] freq : Optional[Union[str, Tick]] Must match the `freq` on the `data` if `data` is a DatetimeIndex or Series. tz : Optional[tzinfo]\n##### Returns\n* **ordinals **: ndarray[int]\n\n* **freq **: Tick\nThe frequency extracted from the Series or DatetimeIndex if that's\nused.\n\n"},"func6": {"source file: ": "period2.py","line number: ": "947","func name: ": "_get_ordinal_range","func arg: ": "(start, end, periods, freq, mult)","comments: ": ""},"func7": {"source file: ": "period2.py","line number: ": "994","func name: ": "_range_from_fields","func arg: ": "(year, month, quarter, day, hour, minute, second, freq)","comments: ": ""},"func8": {"source file: ": "period2.py","line number: ": "1038","func name: ": "_make_field_arrays","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "pickle_compat1.py","line number: ": "16","func name: ": "load_reduce","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "pickle_compat1.py","line number: ": "187","func name: ": "load_newobj","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "pickle_compat1.py","line number: ": "203","func name: ": "load_newobj_ex","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "pickle_compat1.py","line number: ": "222","func name: ": "load","func arg: ": "(fh, encoding, is_verbose)","comments: ": "Load a pickle, with a provided encoding,\n\nParameters ---------- fh : a filelike object encoding : an optional encoding is_verbose : show exception output\n"}}{"func1": {"source file: ": "pickle1.py","line number: ": "12","func name: ": "to_pickle","func arg: ": "(obj, filepath_or_buffer, compression, protocol)","comments: ": "Pickle (serialize) object to file.\n\nParameters ---------- obj : any object Any python object. filepath_or_buffer : str, path object or file-like object File path, URL, or buffer where the pickled object will be stored.\n\n.. versionchanged:: 1.0.0 Accept URL. URL has to be of S3 or GCS.\n\ncompression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer' If 'infer' and 'path_or_url' is path-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no compression) If 'infer' and 'path_or_url' is not path-like, then use None (= no decompression). protocol : int Int which indicates which protocol should be used by the pickler, default HIGHEST_PROTOCOL (see [1], paragraph 12.1.2). The possible values for this parameter depend on the version of Python. For Python 2.x, possible values are 0, 1, 2. For Python>=3.0, 3 is a valid value. For Python >= 3.4, 4 is a valid value. A negative value for the protocol parameter is equivalent to setting its value to HIGHEST_PROTOCOL.\n\n.. [1] https://docs.python.org/3/library/pickle.html .. versionadded:: 0.21.0\n\nSee Also -------- read_pickle : Load pickled pandas object (or any object) from file. DataFrame.to_hdf : Write DataFrame to an HDF5 file. DataFrame.to_sql : Write DataFrame to a SQL database. DataFrame.to_parquet : Write a DataFrame to the binary parquet format.\n\nExamples -------- >>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)}) >>> original_df foo\n\nbar 0\n\n\n\n0\n\n\n\n5 1\n\n\n\n1\n\n\n\n6 2\n\n\n\n2\n\n\n\n7 3\n\n\n\n3\n\n\n\n8 4\n\n\n\n4\n\n\n\n9 >>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n>>> unpickled_df = pd.read_pickle(\"./dummy.pkl\") >>> unpickled_df foo\n\nbar 0\n\n\n\n0\n\n\n\n5 1\n\n\n\n1\n\n\n\n6 2\n\n\n\n2\n\n\n\n7 3\n\n\n\n3\n\n\n\n8 4\n\n\n\n4\n\n\n\n9\n\n>>> import os >>> os.remove(\"./dummy.pkl\")\n"},"func2": {"source file: ": "pickle1.py","line number: ": "100","func name: ": "read_pickle","func arg: ": "(filepath_or_buffer, compression)","comments: ": "Load pickled pandas object (or any object) from file.\n\n.. warning::\n\nLoading pickled data received from untrusted sources can be unsafe. See `here <https://docs.python.org/3/library/pickle.html>`__.\n\nParameters ---------- filepath_or_buffer : str, path object or file-like object File path, URL, or buffer where the pickled object will be loaded from.\n\n.. versionchanged:: 1.0.0 Accept URL. URL is not limited to S3 and GCS.\n\ncompression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer' If 'infer' and 'path_or_url' is path-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no compression) If 'infer' and 'path_or_url' is not path-like, then use None (= no decompression).\n##### Returns\n* **unpickled **: same type as object stored in file\n\n* **DataFrame.to_pickle **: Pickle (serialize) DataFrame object to file.\n\n* **Series.to_pickle **: Pickle (serialize) Series object to file.\n\n* **read_hdf **: Read HDF5 file into a DataFrame.\n\n* **read_sql **: Read SQL query or database table into a DataFrame.\n\n* **read_parquet **: Load a parquet object, returning a DataFrame.\n\n* **>>> original_df = pd.DataFrame({\"foo\"**: range(5), \"bar\"\n\n"}}{"func1": {"source file: ": "pivot1.py","line number: ": "27","func name: ": "pivot_table","func arg: ": "(data, values, index, columns, aggfunc, fill_value, margins, dropna, margins_name, observed)","comments: ": ""},"func2": {"source file: ": "pivot1.py","line number: ": "189","func name: ": "_add_margins","func arg: ": "(table, data, values, rows, cols, aggfunc, observed, margins_name, fill_value)","comments: ": ""},"func3": {"source file: ": "pivot1.py","line number: ": "283","func name: ": "_compute_grand_margin","func arg: ": "(data, values, aggfunc, margins_name)","comments: ": ""},"func4": {"source file: ": "pivot1.py","line number: ": "305","func name: ": "_generate_marginal_results","func arg: ": "(table, data, values, rows, cols, aggfunc, observed, grand_margin, margins_name)","comments: ": ""},"func5": {"source file: ": "pivot1.py","line number: ": "377","func name: ": "_generate_marginal_results_without_values","func arg: ": "(table, data, rows, cols, aggfunc, observed, margins_name)","comments: ": ""},"func6": {"source file: ": "pivot1.py","line number: ": "415","func name: ": "_convert_by","func arg: ": "(by)","comments: ": ""},"func7": {"source file: ": "pivot1.py","line number: ": "431","func name: ": "pivot","func arg: ": "(data, index, columns, values)","comments: ": ""},"func8": {"source file: ": "pivot1.py","line number: ": "453","func name: ": "crosstab","func arg: ": "(index, columns, values, rownames, colnames, aggfunc, margins, margins_name, dropna, normalize)","comments: ": "Compute a simple cross tabulation of two (or more) factors. By default computes a frequency table of the factors unless an array of values and an aggregation function are passed.\n\nParameters ---------- index : array-like, Series, or list of arrays/Series Values to group by in the rows. columns : array-like, Series, or list of arrays/Series Values to group by in the columns. values : array-like, optional Array of values to aggregate according to the factors. Requires `aggfunc` be specified. rownames : sequence, default None If passed, must match number of row arrays passed. colnames : sequence, default None If passed, must match number of column arrays passed. aggfunc : function, optional If specified, requires `values` be specified as well. margins : bool, default False Add row/column margins (subtotals). margins_name : str, default 'All' Name of the row/column that will contain the totals when margins is True.\n\n.. versionadded:: 0.21.0\n\ndropna : bool, default True Do not include columns whose entries are all NaN. normalize : bool, {'all', 'index', 'columns'}, or {0,1}, default False Normalize by dividing all values by the sum of values.\n\n- If passed 'all' or `True`, will normalize over all values.\n\n- If passed 'index' will normalize over each row.\n\n- If passed 'columns' will normalize over each column.\n\n- If margins is `True`, will also normalize margin values.\n##### Returns\n* **DataFrame.pivot **: Reshape data based on column values.\n\n* **pivot_table **: Create a pivot table as a DataFrame.\n\n"},"func9": {"source file: ": "pivot1.py","line number: ": "610","func name: ": "_normalize","func arg: ": "(table, normalize, margins, margins_name)","comments: ": ""},"func10": {"source file: ": "pivot1.py","line number: ": "693","func name: ": "_get_names","func arg: ": "(arrs, names, prefix)","comments: ": ""}}{}{"func1": {"source file: ": "printing2.py","line number: ": "25","func name: ": "adjoin","func arg: ": "(space, **kwargs)","comments: ": "Glues together two sets of strings using the amount of space requested. The idea is to prettify.\n\n---------- space : int number of spaces for padding lists : str list of str which being joined strlen : callable function used to calculate the length of each str. Needed for unicode handling. justfunc : callable function used to justify str. Needed for unicode handling.\n"},"func2": {"source file: ": "printing2.py","line number: ": "60","func name: ": "justify","func arg: ": "(texts, max_len, mode)","comments: ": "Perform ljust, center, rjust against string or list-like\n\n\n"},"func3": {"source file: ": "printing2.py","line number: ": "96","func name: ": "_pprint_seq","func arg: ": "(seq, _nest_lvl, max_seq_items, **kwds)","comments: ": "internal. pprinter for iterables. you should probably use pprint_thing() rather then calling this directly.\n\nbounds length of printed sequence, depending on options\n"},"func4": {"source file: ": "printing2.py","line number: ": "131","func name: ": "_pprint_dict","func arg: ": "(seq, _nest_lvl, max_seq_items, **kwds)","comments: ": "internal. pprinter for iterables. you should probably use pprint_thing() rather then calling this directly.\n\n\n"},"func5": {"source file: ": "printing2.py","line number: ": "162","func name: ": "pprint_thing","func arg: ": "(thing, _nest_lvl, escape_chars, default_escapes, quote_strings, max_seq_items)","comments: ": "This function is the sanctioned way of converting objects to a string representation and properly handles nested sequences.\n\nParameters ---------- thing : anything to be formatted _nest_lvl : internal use only. pprint_thing() is mutually-recursive with pprint_sequence, this argument is used to keep track of the current nesting level, and limit it. escape_chars : list or dict, optional Characters to escape. If a dict is passed the values are the replacements default_escapes : bool, default False Whether the input escape characters replaces or adds to the defaults max_seq_items : int or None, default None Pass through to other pretty printers to limit sequence printing\n##### Returns\n"},"func6": {"source file: ": "printing2.py","line number: ": "235","func name: ": "pprint_thing_encoded","func arg: ": "(object, encoding, errors)","comments: ": ""},"func7": {"source file: ": "printing2.py","line number: ": "242","func name: ": "_enable_data_resource_formatter","func arg: ": "(enable)","comments: ": ""},"func8": {"source file: ": "printing2.py","line number: ": "280","func name: ": "format_object_summary","func arg: ": "(obj, formatter, is_justify, name, indent_for_name, line_break_each_value)","comments: ": "Return the formatted obj as a unicode string\n\nParameters ---------- obj : object must be iterable and support __getitem__ formatter : callable string formatter for an element is_justify : boolean should justify the display name : name, optional defaults to the class name of the obj indent_for_name : bool, default True Whether subsequent lines should be be indented to align with the name. line_break_each_value : bool, default False If True, inserts a line break for each value of ``obj``. If False, only break lines when the a line of values gets wider than the display width.\n\n.. versionadded:: 0.25.0\n##### Returns\n"},"func9": {"source file: ": "printing2.py","line number: ": "452","func name: ": "_justify","func arg: ": "(head, tail)","comments: ": "Justify items in head and tail, so they are right-aligned when stacked.\n\nParameters ---------- head : list-like of list-likes of strings tail : list-like of list-likes of strings\n##### Returns\n"},"func10": {"source file: ": "printing2.py","line number: ": "497","func name: ": "format_object_attrs","func arg: ": "(obj, include_dtype)","comments: ": "Return a list of tuples of the (attr, formatted_value) for common attrs, including dtype, name, length\n\nParameters ---------- obj : object must be iterable include_dtype : bool If False, dtype won't be in the returned list\n##### Returns\n"}}{"func1": {"source file: ": "pytables1.py","line number: ": "459","func name: ": "_validate_where","func arg: ": "(w)","comments: ": "Validate that the where statement is of the right type.\n\nThe type may either be String, Expr, or list-like of Exprs.\n\nParameters ---------- w : String term expression, Expr, or list-like of Exprs.\n##### Returns\n* **where **: The original where clause if the check was successful.\n\n"},"func2": {"source file: ": "pytables1.py","line number: ": "617","func name: ": "maybe_expression","func arg: ": "(s)","comments: ": "loose checking if s is a pytables-acceptable expression\n\n\n"}}{"func1": {"source file: ": "pytables2.py","line number: ": "80","func name: ": "_ensure_decoded","func arg: ": "(s)","comments: ": "if we have bytes, decode them to unicode\n\n\n"},"func2": {"source file: ": "pytables2.py","line number: ": "87","func name: ": "_ensure_encoding","func arg: ": "(encoding)","comments: ": ""},"func3": {"source file: ": "pytables2.py","line number: ": "95","func name: ": "_ensure_str","func arg: ": "(name)","comments: ": "Ensure that an index / column name is a str (python 3); otherwise they may be np.string dtype. Non-string dtypes are passed through unchanged.\n\nhttps://github.com/pandas-dev/pandas/issues/13492\n"},"func4": {"source file: ": "pytables2.py","line number: ": "110","func name: ": "_ensure_term","func arg: ": "(where, scope_level)","comments: ": "ensure that the where is a Term or a list of Term this makes sure that we are capturing the scope of variables that are passed create the terms here with a frame_level=2 (we are 2 levels down)\n\n\n"},"func5": {"source file: ": "pytables2.py","line number: ": "207","func name: ": "_tables","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "pytables2.py","line number: ": "231","func name: ": "to_hdf","func arg: ": "(path_or_buf, key, value, mode, complevel, complib, append, format, index, min_itemsize, nan_rep, dropna, data_columns, errors, encoding)","comments: ": "store this object, close it if we opened it\n\n\n"},"func7": {"source file: ": "pytables2.py","line number: ": "287","func name: ": "read_hdf","func arg: ": "(path_or_buf, key, mode, errors, where, start, stop, columns, iterator, chunksize, **kwargs)","comments: ": "Read from the store, close it if we opened it.\n\nRetrieve pandas object stored in file, optionally based on where criteria\n\nParameters ---------- path_or_buf : str, path object, pandas.HDFStore or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.h5``.\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nAlternatively, pandas accepts an open :class:`pandas.HDFStore` object.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``.\n\n.. versionadded:: 0.21.0 support for __fspath__ protocol.\n\nkey : object, optional The group identifier in the store. Can be omitted if the HDF file contains a single pandas object. mode : {'r', 'r+', 'a'}, default 'r' Mode to use when opening the file. Ignored if path_or_buf is a :class:`pandas.HDFStore`. Default is 'r'. where : list, optional A list of Term (or convertible) objects. start : int, optional Row number to start selection. stop\n\n: int, optional Row number to stop selection. columns : list, optional A list of columns names to return. iterator : bool, optional Return an iterator object. chunksize : int, optional Number of rows to include in an iteration when using an iterator. errors : str, default 'strict' Specifies how encoding and decoding errors are to be handled. See the errors argument for :func:`open` for a full list of options. **kwargs Additional keyword arguments passed to HDFStore.\n##### Returns\n* **item **: object\nThe selected object. Return type depends on the object stored.\n\n* **DataFrame.to_hdf **: Write a HDF file from a DataFrame.\n\n* **HDFStore **: Low-level access to HDF files.\n\n"},"func8": {"source file: ": "pytables2.py","line number: ": "441","func name: ": "_is_metadata_of","func arg: ": "(group, parent_group)","comments: ": "Check if a given group is a metadata group for a given parent_group.\n\n\n"},"func9": {"source file: ": "pytables2.py","line number: ": "4616","func name: ": "_reindex_axis","func arg: ": "(obj, axis, labels, other)","comments: ": ""},"func10": {"source file: ": "pytables2.py","line number: ": "4640","func name: ": "_get_tz","func arg: ": "(tz)","comments: ": "for a tz-aware type, return an encoded zone\n\n\n"},"func11": {"source file: ": "pytables2.py","line number: ": "4646","func name: ": "_set_tz","func arg: ": "(values, tz, coerce)","comments: ": "coerce the values to a DatetimeIndex if tz is set preserve the input shape if possible\n\nParameters ---------- values : ndarray or Index tz : str or tzinfo coerce : if we do not have a passed timezone, coerce to M8[ns] ndarray\n"},"func12": {"source file: ": "pytables2.py","line number: ": "4679","func name: ": "_convert_index","func arg: ": "(name, index, encoding, errors)","comments: ": ""},"func13": {"source file: ": "pytables2.py","line number: ": "4738","func name: ": "_unconvert_index","func arg: ": "(data, kind, encoding, errors)","comments: ": ""},"func14": {"source file: ": "pytables2.py","line number: ": "4765","func name: ": "_maybe_convert_for_string_atom","func arg: ": "(name, block, existing_col, min_itemsize, nan_rep, encoding, errors)","comments: ": ""},"func15": {"source file: ": "pytables2.py","line number: ": "4831","func name: ": "_convert_string_array","func arg: ": "(data, encoding, errors)","comments: ": "Take a string-like that is object dtype and coerce to a fixed size string type.\n\nParameters ---------- data : np.ndarray[object] encoding : str errors : str Handler for encoding errors.\n##### Returns\n"},"func16": {"source file: ": "pytables2.py","line number: ": "4861","func name: ": "_unconvert_string_array","func arg: ": "(data, nan_rep, encoding, errors)","comments: ": "Inverse of _convert_string_array.\n\nParameters ---------- data : np.ndarray[fixed-length-string] nan_rep : the storage repr of NaN encoding : str errors : str Handler for encoding errors.\n##### Returns\n"},"func17": {"source file: ": "pytables2.py","line number: ": "4900","func name: ": "_maybe_convert","func arg: ": "(values, val_kind, encoding, errors)","comments: ": ""},"func18": {"source file: ": "pytables2.py","line number: ": "4908","func name: ": "_get_converter","func arg: ": "(kind, encoding, errors)","comments: ": ""},"func19": {"source file: ": "pytables2.py","line number: ": "4919","func name: ": "_need_convert","func arg: ": "(kind)","comments: ": ""},"func20": {"source file: ": "pytables2.py","line number: ": "4925","func name: ": "_maybe_adjust_name","func arg: ": "(name, version)","comments: ": "Prior to 0.10.1, we named values blocks like: values_block_0 an the name values_0, adjust the given name if necessary.\n\nParameters ---------- name : str version : Tuple[int, int, int]\n##### Returns\n"},"func21": {"source file: ": "pytables2.py","line number: ": "4950","func name: ": "_dtype_to_kind","func arg: ": "(dtype_str)","comments: ": "Find the \"kind\" string describing the given dtype name.\n\n\n"},"func22": {"source file: ": "pytables2.py","line number: ": "4983","func name: ": "_get_data_and_dtype_name","func arg: ": "(data)","comments: ": "Convert the passed data into a storable form and a dtype string.\n\n\n"}}{}{}{"func1": {"source file: ": "resample1.py","line number: ": "1265","func name: ": "resample","func arg: ": "(obj, kind, **kwds)","comments: ": "Create a TimeGrouper and return our resampler.\n\n\n"},"func2": {"source file: ": "resample1.py","line number: ": "1276","func name: ": "get_resampler_for_grouping","func arg: ": "(groupby, rule, how, fill_method, limit, kind, **kwargs)","comments: ": "Return our appropriate resampler when grouping as well.\n\n\n"},"func3": {"source file: ": "resample1.py","line number: ": "1605","func name: ": "_take_new_index","func arg: ": "(obj, indexer, new_index, axis)","comments: ": ""},"func4": {"source file: ": "resample1.py","line number: ": "1620","func name: ": "_get_timestamp_range_edges","func arg: ": "(first, last, offset, closed, base)","comments: ": "Adjust the `first` Timestamp to the preceding Timestamp that resides on the provided offset. Adjust the `last` Timestamp to the following Timestamp that resides on the provided offset. Input Timestamps that already reside on the offset will be adjusted depending on the type of offset and the `closed` parameter.\n\nParameters ---------- first : pd.Timestamp The beginning Timestamp of the range to be adjusted. last : pd.Timestamp The ending Timestamp of the range to be adjusted. offset : pd.DateOffset The dateoffset to which the Timestamps will be adjusted. closed : {'right', 'left'}, default None Which side of bin interval is closed. base : int, default 0 The \"origin\" of the adjusted Timestamps.\n##### Returns\n"},"func5": {"source file: ": "resample1.py","line number: ": "1676","func name: ": "_get_period_range_edges","func arg: ": "(first, last, offset, closed, base)","comments: ": "Adjust the provided `first` and `last` Periods to the respective Period of the given offset that encompasses them.\n\nParameters ---------- first : pd.Period The beginning Period of the range to be adjusted. last : pd.Period The ending Period of the range to be adjusted. offset : pd.DateOffset The dateoffset to which the Periods will be adjusted. closed : {'right', 'left'}, default None Which side of bin interval is closed. base : int, default 0 The \"origin\" of the adjusted Periods.\n##### Returns\n"},"func6": {"source file: ": "resample1.py","line number: ": "1716","func name: ": "_adjust_dates_anchored","func arg: ": "(first, last, offset, closed, base)","comments: ": ""},"func7": {"source file: ": "resample1.py","line number: ": "1774","func name: ": "asfreq","func arg: ": "(obj, freq, method, how, normalize, fill_value)","comments: ": "Utility frequency conversion method for Series/DataFrame.\n\n\n"}}{"func1": {"source file: ": "reshape1.py","line number: ": "312","func name: ": "_unstack_multiple","func arg: ": "(data, clocs, fill_value)","comments: ": ""},"func2": {"source file: ": "reshape1.py","line number: ": "393","func name: ": "unstack","func arg: ": "(obj, level, fill_value)","comments: ": ""},"func3": {"source file: ": "reshape1.py","line number: ": "424","func name: ": "_unstack_frame","func arg: ": "(obj, level, fill_value)","comments: ": ""},"func4": {"source file: ": "reshape1.py","line number: ": "443","func name: ": "_unstack_extension_series","func arg: ": "(series, level, fill_value)","comments: ": "Unstack an ExtensionArray-backed Series.\n\nThe ExtensionDtype is preserved.\n\nParameters ---------- series : Series A Series with an ExtensionArray for values level : Any The level name or number. fill_value : Any The user-level (not physical storage) fill value to use for missing values introduced by the reshape. Passed to ``series.values.take``.\n##### Returns\n"},"func5": {"source file: ": "reshape1.py","line number: ": "493","func name: ": "stack","func arg: ": "(frame, level, dropna)","comments: ": "Convert DataFrame to Series with multi-level Index. Columns become the second level of the resulting hierarchical index\n\n\n##### Returns\n* **stacked **: Series\n\n"},"func6": {"source file: ": "reshape1.py","line number: ": "567","func name: ": "stack_multiple","func arg: ": "(frame, level, dropna)","comments: ": ""},"func7": {"source file: ": "reshape1.py","line number: ": "608","func name: ": "_stack_multi_columns","func arg: ": "(frame, level_num, dropna)","comments: ": ""},"func8": {"source file: ": "reshape1.py","line number: ": "750","func name: ": "get_dummies","func arg: ": "(data, prefix, prefix_sep, dummy_na, columns, sparse, drop_first, dtype)","comments: ": "Convert categorical variable into dummy/indicator variables.\n\nParameters ---------- data : array-like, Series, or DataFrame Data of which to get dummy indicators. prefix : str, list of str, or dict of str, default None String to append DataFrame column names. Pass a list with length equal to the number of columns when calling get_dummies on a DataFrame. Alternatively, `prefix` can be a dictionary mapping column names to prefixes. prefix_sep : str, default '_' If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with `prefix`. dummy_na : bool, default False Add a column to indicate NaNs, if False NaNs are ignored. columns : list-like, default None Column names in the DataFrame to be encoded. If `columns` is None then all the columns with `object` or `category` dtype will be converted. sparse : bool, default False Whether the dummy-encoded columns should be backed by a :class:`SparseArray` (True) or a regular NumPy array (False). drop_first : bool, default False Whether to get k-1 dummies out of k categorical levels by removing the first level. dtype : dtype, default np.uint8 Data type for new columns. Only a single dtype is allowed.\n\n.. versionadded:: 0.23.0\n##### Returns\n* **Series.str.get_dummies **: Convert Series to dummy codes.\n\n* **>>> df = pd.DataFrame({'A'**: ['a', 'b', 'a'], 'B'\n\n* **...'C'**: [1, 2, 3]})\n\n"},"func9": {"source file: ": "reshape1.py","line number: ": "939","func name: ": "_get_dummies_1d","func arg: ": "(data, prefix, prefix_sep, dummy_na, sparse, drop_first, dtype)","comments: ": ""},"func10": {"source file: ": "reshape1.py","line number: ": "1048","func name: ": "_reorder_for_extension_array_stack","func arg: ": "(arr, n_rows, n_columns)","comments: ": "Re-orders the values when stacking multiple extension-arrays.\n\nThe indirect stacking method used for EAs requires a followup take to get the order correct.\n\nParameters ---------- arr : ExtensionArray n_rows, n_columns : int The number of rows and columns in the original DataFrame.\n##### Returns\n* **taken **: ExtensionArray\nThe original `arr` with elements re-ordered appropriately\n\n"}}{}{}{"func1": {"source file: ": "roperator1.py","line number: ": "8","func name: ": "radd","func arg: ": "(left, right)","comments: ": ""},"func2": {"source file: ": "roperator1.py","line number: ": "12","func name: ": "rsub","func arg: ": "(left, right)","comments: ": ""},"func3": {"source file: ": "roperator1.py","line number: ": "16","func name: ": "rmul","func arg: ": "(left, right)","comments: ": ""},"func4": {"source file: ": "roperator1.py","line number: ": "20","func name: ": "rdiv","func arg: ": "(left, right)","comments: ": ""},"func5": {"source file: ": "roperator1.py","line number: ": "24","func name: ": "rtruediv","func arg: ": "(left, right)","comments: ": ""},"func6": {"source file: ": "roperator1.py","line number: ": "28","func name: ": "rfloordiv","func arg: ": "(left, right)","comments: ": ""},"func7": {"source file: ": "roperator1.py","line number: ": "32","func name: ": "rmod","func arg: ": "(left, right)","comments: ": ""},"func8": {"source file: ": "roperator1.py","line number: ": "43","func name: ": "rdivmod","func arg: ": "(left, right)","comments: ": ""},"func9": {"source file: ": "roperator1.py","line number: ": "47","func name: ": "rpow","func arg: ": "(left, right)","comments: ": ""},"func10": {"source file: ": "roperator1.py","line number: ": "51","func name: ": "rand_","func arg: ": "(left, right)","comments: ": ""},"func11": {"source file: ": "roperator1.py","line number: ": "55","func name: ": "ror_","func arg: ": "(left, right)","comments: ": ""},"func12": {"source file: ": "roperator1.py","line number: ": "59","func name: ": "rxor","func arg: ": "(left, right)","comments: ": ""}}{"func1": {"source file: ": "s3(1).py","line number: ": "13","func name: ": "_strip_schema","func arg: ": "(url)","comments: ": "Returns the url without the s3:// part\n\n\n"},"func2": {"source file: ": "s3(1).py","line number: ": "19","func name: ": "get_file_and_filesystem","func arg: ": "(filepath_or_buffer, mode)","comments: ": ""},"func3": {"source file: ": "s3(1).py","line number: ": "42","func name: ": "get_filepath_or_buffer","func arg: ": "(filepath_or_buffer, encoding, compression, mode)","comments: ": ""}}{}{"func1": {"source file: ": "sas_xport1.py","line number: ": "146","func name: ": "_parse_date","func arg: ": "(datestr)","comments: ": "Given a date in xport format, return Python date.\n\n\n"},"func2": {"source file: ": "sas_xport1.py","line number: ": "155","func name: ": "_split_line","func arg: ": "(s, parts)","comments: ": "Parameters ---------- s: str Fixed-length string to split parts: list of (name, length) pairs Used to break up string, name '_' will be filtered from output.\n\n\n##### Returns\n* **Dict of name**: contents of string at given location.\n\n"},"func3": {"source file: ": "sas_xport1.py","line number: ": "177","func name: ": "_handle_truncated_float_vec","func arg: ": "(vec, nbytes)","comments: ": ""},"func4": {"source file: ": "sas_xport1.py","line number: ": "196","func name: ": "_parse_float_vec","func arg: ": "(vec)","comments: ": "Parse a vector of float values representing IBM 8 byte floats into native 8 byte floats.\n\n\n"}}{}{"func1": {"source file: ": "sasreader1.py","line number: ": "7","func name: ": "read_sas","func arg: ": "(filepath_or_buffer, format, index, encoding, chunksize, iterator)","comments: ": "Read SAS files stored as either XPORT or SAS7BDAT format files.\n\nParameters ---------- filepath_or_buffer : str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a host is expected. A local file could be: ``file://localhost/path/to/table.sas``.\n\nIf you want to pass in a path object, pandas accepts any ``os.PathLike``.\n\nBy file-like object, we refer to objects with a ``read()`` method, such as a file handler (e.g. via builtin ``open`` function) or ``StringIO``. format : str {'xport', 'sas7bdat'} or None If None, file format is inferred from file extension. If 'xport' or 'sas7bdat', uses the corresponding format. index : identifier of index column, defaults to None Identifier of column that should be used as index of the DataFrame. encoding : str, default is None Encoding for text data.\n\nIf None, text data are stored as raw bytes. chunksize : int Read file `chunksize` lines at a time, returns iterator. iterator : bool, defaults to False If True, returns an iterator for reading the file incrementally.\n##### Returns\n"}}{"func1": {"source file: ": "scipy_sparse1.py","line number: ": "10","func name: ": "_check_is_partition","func arg: ": "(parts, whole)","comments: ": ""},"func2": {"source file: ": "scipy_sparse1.py","line number: ": "19","func name: ": "_to_ijv","func arg: ": "(ss, row_levels, column_levels, sort_labels)","comments: ": "For arbitrary (MultiIndexed) SparseSeries return (v, i, j, ilabels, jlabels) where (v, (i, j)) is suitable for passing to scipy.sparse.coo constructor.\n\n\n"},"func3": {"source file: ": "scipy_sparse1.py","line number: ": "86","func name: ": "_sparse_series_to_coo","func arg: ": "(ss, row_levels, column_levels, sort_labels)","comments: ": "Convert a SparseSeries to a scipy.sparse.coo_matrix using index levels row_levels, column_levels as the row and column labels respectively. Returns the sparse_matrix, row and column labels.\n\n\n"},"func4": {"source file: ": "scipy_sparse1.py","line number: ": "115","func name: ": "_coo_to_sparse_series","func arg: ": "(A, dense_index)","comments: ": "Convert a scipy.sparse.coo_matrix to a SparseSeries.\n\nParameters ---------- A : scipy.sparse.coo.coo_matrix dense_index : bool, default False\n##### Returns\n"}}{"func1": {"source file: ": "scope1.py","line number: ": "20","func name: ": "ensure_scope","func arg: ": "(level, global_dict, local_dict, resolvers, target, **kwargs)","comments: ": "Ensure that we are grabbing the correct scope.\n\n\n"},"func2": {"source file: ": "scope1.py","line number: ": "33","func name: ": "_replacer","func arg: ": "(x)","comments: ": "Replace a number with its hexadecimal representation. Used to tag temporary variables with their calling scope's id.\n\n\n"},"func3": {"source file: ": "scope1.py","line number: ": "48","func name: ": "_raw_hex_id","func arg: ": "(obj)","comments: ": "Return the padded hexadecimal id of ``obj``.\n\n\n"},"func4": {"source file: ": "scope1.py","line number: ": "67","func name: ": "_get_pretty_string","func arg: ": "(obj)","comments: ": "Return a prettier version of obj.\n\nParameters ---------- obj : object Object to pretty print\n##### Returns\n"}}{"func1": {"source file: ": "series1.py","line number: ": "104","func name: ": "_coerce_method","func arg: ": "(converter)","comments: ": "Install the scalar coercion methods.\n\n\n"}}{}{"func1": {"source file: ": "sorting1.py","line number: ": "21","func name: ": "get_group_index","func arg: ": "(labels, shape, sort, xnull)","comments: ": "For the particular label_list, gets the offsets into the hypothetical list representing the totally ordered cartesian product of all possible label combinations, *as long as* this space fits within int64 bounds; otherwise, though group indices identify unique combinations of labels, they cannot be deconstructed. - If `sort`, rank of returned ids preserve lexical ranks of labels. i.e. returned id's can be used to do lexical sort on labels; - If `xnull` nulls (-1 labels) are passed through.\n\nParameters ---------- labels : sequence of arrays Integers identifying levels at each location shape : sequence of ints Number of unique levels at each location sort : bool If the ranks of returned ids should match lexical ranks of labels xnull : bool If true nulls are excluded. i.e. -1 values in the labels are passed through.\n##### Returns\n"},"func2": {"source file: ": "sorting1.py","line number: ": "110","func name: ": "get_compressed_ids","func arg: ": "(labels, sizes)","comments: ": "Group_index is offsets into cartesian product of all possible labels. This space can be huge, so this function compresses it, by computing offsets (comp_ids) into the list of unique labels (obs_group_ids).\n\nParameters ---------- labels : list of label arrays sizes : list of size of the levels\n##### Returns\n"},"func3": {"source file: ": "sorting1.py","line number: ": "129","func name: ": "is_int64_overflow_possible","func arg: ": "(shape)","comments: ": ""},"func4": {"source file: ": "sorting1.py","line number: ": "137","func name: ": "decons_group_index","func arg: ": "(comp_labels, shape)","comments: ": ""},"func5": {"source file: ": "sorting1.py","line number: ": "157","func name: ": "decons_obs_group_ids","func arg: ": "(comp_ids, obs_ids, shape, labels, xnull)","comments: ": "Reconstruct labels from observed group ids.\n\nParameters ---------- xnull : bool If nulls are excluded; i.e. -1 labels are passed through.\n"},"func6": {"source file: ": "sorting1.py","line number: ": "180","func name: ": "indexer_from_factorized","func arg: ": "(labels, shape, compress)","comments: ": ""},"func7": {"source file: ": "sorting1.py","line number: ": "192","func name: ": "lexsort_indexer","func arg: ": "(keys, orders, na_position)","comments: ": "Parameters ---------- na_position : {'first', 'last'}, default 'last'\n\n\n"},"func8": {"source file: ": "sorting1.py","line number: ": "243","func name: ": "nargsort","func arg: ": "(items, kind, ascending, na_position)","comments: ": "Intended to be a drop-in replacement for np.argsort which handles NaNs.\n\nAdds ascending and na_position parameters.\n\n(GH #6399, #5231)\n\nParameters ---------- kind : str, default 'quicksort' ascending : bool, default True na_position : {'first', 'last'}, default 'last'\n"},"func9": {"source file: ": "sorting1.py","line number: ": "314","func name: ": "get_flattened_iterator","func arg: ": "(comp_ids, ngroups, levels, labels)","comments: ": ""},"func10": {"source file: ": "sorting1.py","line number: ": "320","func name: ": "get_indexer_dict","func arg: ": "(label_list, keys)","comments: ": "Returns ------- dict Labels mapped to indexers.\n\n\n"},"func11": {"source file: ": "sorting1.py","line number: ": "348","func name: ": "get_group_index_sorter","func arg: ": "(group_index, ngroups)","comments: ": "algos.groupsort_indexer implements `counting sort` and it is at least O(ngroups), where ngroups = prod(shape) shape = map(len, keys) that is, linear in the number of combinations (cartesian product) of unique values of groupby keys. This can be huge when doing multi-key groupby. np.argsort(kind='mergesort') is O(count x log(count)) where count is the length of the data-frame; Both algorithms are `stable` sort and that is necessary for correctness of groupby operations. e.g. consider: df.groupby(key)[col].transform('first')\n\n\n"},"func12": {"source file: ": "sorting1.py","line number: ": "373","func name: ": "compress_group_index","func arg: ": "(group_index, sort)","comments: ": "Group_index is offsets into cartesian product of all possible labels. This space can be huge, so this function compresses it, by computing offsets (comp_ids) into the list of unique labels (obs_group_ids).\n\n\n"},"func13": {"source file: ": "sorting1.py","line number: ": "394","func name: ": "_reorder_by_uniques","func arg: ": "(uniques, labels)","comments: ": ""}}{"func1": {"source file: ": "spss1.py","line number: ": "11","func name: ": "read_spss","func arg: ": "(path, usecols, convert_categoricals)","comments: ": "Load an SPSS file from the file path, returning a DataFrame.\n\n.. versionadded:: 0.25.0\n\nParameters ---------- path : string or Path File path. usecols : list-like, optional Return a subset of the columns. If None, return all columns. convert_categoricals : bool, default is True Convert categorical columns into pd.Categorical.\n##### Returns\n"}}{"func1": {"source file: ": "sql1.py","line number: ": "39","func name: ": "_is_sqlalchemy_connectable","func arg: ": "(con)","comments: ": ""},"func2": {"source file: ": "sql1.py","line number: ": "57","func name: ": "_convert_params","func arg: ": "(sql, params)","comments: ": "Convert SQL and params args to DBAPI2.0 compliant format.\n\n\n"},"func3": {"source file: ": "sql1.py","line number: ": "68","func name: ": "_process_parse_dates_argument","func arg: ": "(parse_dates)","comments: ": "Process parse_dates argument for read_sql functions\n\n\n"},"func4": {"source file: ": "sql1.py","line number: ": "79","func name: ": "_handle_date_column","func arg: ": "(col, utc, format)","comments: ": ""},"func5": {"source file: ": "sql1.py","line number: ": "100","func name: ": "_parse_date_columns","func arg: ": "(data_frame, parse_dates)","comments: ": "Force non-datetime columns to be read as such. Supports both string formatted and integer timestamp columns.\n\n\n"},"func6": {"source file: ": "sql1.py","line number: ": "121","func name: ": "_wrap_result","func arg: ": "(data, columns, index_col, coerce_float, parse_dates)","comments: ": "Wrap result set of query in a DataFrame.\n\n\n"},"func7": {"source file: ": "sql1.py","line number: ": "134","func name: ": "execute","func arg: ": "(sql, con, cur, params)","comments: ": "Execute the given SQL query using the provided connection object.\n\nParameters ---------- sql : string SQL query to be executed. con : SQLAlchemy connectable(engine/connection) or sqlite3 connection Using SQLAlchemy makes it possible to use any DB supported by the library. If a DBAPI2 object, only sqlite3 is supported. cur : deprecated, cursor is obtained from connection, default: None params : list or tuple, optional, default: None List of parameters to pass to execute method.\n##### Returns\n"},"func8": {"source file: ": "sql1.py","line number: ": "166","func name: ": "read_sql_table","func arg: ": "(table_name, con, schema, index_col, coerce_float, parse_dates, columns, chunksize)","comments: ": "Read SQL database table into a DataFrame.\n\nGiven a table name and a SQLAlchemy connectable, returns a DataFrame. This function does not support DBAPI connections.\n\nParameters ---------- table_name : str Name of SQL table in database. con : SQLAlchemy connectable or str A database URI could be provided as as str. SQLite DBAPI connection mode not supported. schema : str, default None Name of SQL schema in database to query (if database flavor supports this). Uses default schema if None (default). index_col : str or list of str, optional, default: None Column(s) to set as index(MultiIndex). coerce_float : bool, default True Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point. Can result in loss of Precision. parse_dates : list or dict, default None\n\n- List of column names to parse as dates.\n\n- Dict of ``{column_name: format string}`` where format string is strftime compatible in case of parsing string times or is one of (D, s, ns, ms, us) in case of parsing integer timestamps.\n\n- Dict of ``{column_name: arg dict}``, where the arg dict corresponds to the keyword arguments of :func:`pandas.to_datetime` Especially useful with databases without native Datetime support, such as SQLite. columns : list, default None List of column names to select from SQL table. chunksize : int, default None If specified, returns an iterator where `chunksize` is the number of rows to include in each chunk.\n##### Returns\n* **read_sql_query **: Read SQL query into a DataFrame.\n\n* **read_sql **: Read SQL query or database table into a DataFrame.\n\n* **>>> pd.read_sql_table('table_name', 'postgres**: ///db_name')  # doctest\n\n"},"func9": {"source file: ": "sql1.py","line number: ": "262","func name: ": "read_sql_query","func arg: ": "(sql, con, index_col, coerce_float, params, parse_dates, chunksize)","comments: ": "Read SQL query into a DataFrame.\n\n\n##### Returns\n* **read_sql_table **: Read SQL database table into a DataFrame.\n\n"},"func10": {"source file: ": "sql1.py","line number: ": "336","func name: ": "read_sql","func arg: ": "(sql, con, index_col, coerce_float, params, parse_dates, columns, chunksize)","comments: ": "Read SQL query or database table into a DataFrame.\n\nThis function is a convenience wrapper around ``read_sql_table`` and ``read_sql_query`` (for backward compatibility). It will delegate to the specific function depending on the provided input. A SQL query will be routed to ``read_sql_query``, while a database table name will be routed to ``read_sql_table``. Note that the delegated function might have more specific notes about their functionality not listed here.\n\nParameters ---------- sql : str or SQLAlchemy Selectable (select or text object) SQL query to be executed or a table name. con : SQLAlchemy connectable (engine/connection) or database str URI or DBAPI2 connection (fallback mode)'\n\nUsing SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported. The user is responsible for engine disposal and connection closure for the SQLAlchemy connectable. See `here <https://docs.sqlalchemy.org/en/13/core/connections.html>`_ index_col : str or list of strings, optional, default: None Column(s) to set as index(MultiIndex). coerce_float : bool, default True Attempts to convert values of non-string, non-numeric objects (like decimal.Decimal) to floating point, useful for SQL result sets. params : list, tuple or dict, optional, default: None List of parameters to pass to execute method.\n\nThe syntax used to pass parameters is database driver dependent. Check your database driver documentation for which of the five syntax styles, described in PEP 249's paramstyle, is supported. Eg. for psycopg2, uses %(name)s so use params={'name' : 'value'}. parse_dates : list or dict, default: None\n\n- List of column names to parse as dates.\n\n- Dict of ``{column_name: format string}`` where format string is strftime compatible in case of parsing string times, or is one of (D, s, ns, ms, us) in case of parsing integer timestamps.\n\n- Dict of ``{column_name: arg dict}``, where the arg dict corresponds to the keyword arguments of :func:`pandas.to_datetime` Especially useful with databases without native Datetime support, such as SQLite. columns : list, default: None List of column names to select from SQL table (only used when reading a table). chunksize : int, default None If specified, return an iterator where `chunksize` is the number of rows to include in each chunk.\n##### Returns\n* **read_sql_table **: Read SQL database table into a DataFrame.\n\n* **read_sql_query **: Read SQL query into a DataFrame.\n\n"},"func11": {"source file: ": "sql1.py","line number: ": "442","func name: ": "to_sql","func arg: ": "(frame, name, con, schema, if_exists, index, index_label, chunksize, dtype, method)","comments: ": "Write records stored in a DataFrame to a SQL database.\n\nParameters ---------- frame : DataFrame, Series name : str Name of SQL table. con : SQLAlchemy connectable(engine/connection) or database string URI or sqlite3 DBAPI2 connection Using SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported. schema : str, optional Name of SQL schema in database to write to (if database flavor supports this). If None, use default schema (default). if_exists : {'fail', 'replace', 'append'}, default 'fail'\n\n- fail: If table exists, do nothing.\n\n- replace: If table exists, drop it, recreate it, and insert data.\n\n- append: If table exists, insert data. Create if does not exist. index : boolean, default True Write DataFrame index as a column. index_label : str or sequence, optional Column label for index column(s). If None is given (default) and `index` is True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. chunksize : int, optional Specify the number of rows in each batch to be written at a time. By default, all rows will be written at once. dtype : dict or scalar, optional Specifying the datatype for columns. If a dictionary is used, the keys should be the column names and the values should be the SQLAlchemy types or strings for the sqlite3 fallback mode. If a scalar is provided, it will be applied to all columns. method : {None, 'multi', callable}, optional Controls the SQL insertion clause used:\n\n- None : Uses standard SQL ``INSERT`` clause (one per row).\n\n- 'multi': Pass multiple values in a single ``INSERT`` clause.\n\n- callable with signature ``(pd_table, conn, keys, data_iter)``.\n\nDetails and a sample callable implementation can be found in the section :ref:`insert method <io.sql.method>`.\n\n.. versionadded:: 0.24.0\n"},"func12": {"source file: ": "sql1.py","line number: ": "525","func name: ": "has_table","func arg: ": "(table_name, con, schema)","comments: ": "Check if DataBase has named table.\n\nParameters ---------- table_name: string Name of SQL table. con: SQLAlchemy connectable(engine/connection) or sqlite3 DBAPI2 connection Using SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported. schema : string, default None Name of SQL schema in database to write to (if database flavor supports this). If None, use default schema (default).\n##### Returns\n"},"func13": {"source file: ": "sql1.py","line number: ": "552","func name: ": "_engine_builder","func arg: ": "(con)","comments: ": "Returns a SQLAlchemy engine from a URI (if con is a string) else it just return con without modifying it.\n\n\n"},"func14": {"source file: ": "sql1.py","line number: ": "570","func name: ": "pandasSQL_builder","func arg: ": "(con, schema, meta, is_cursor)","comments: ": "Convenience function to return the correct PandasSQL subclass based on the provided parameters.\n\n\n"},"func15": {"source file: ": "sql1.py","line number: ": "1388","func name: ": "_get_unicode_name","func arg: ": "(name)","comments: ": ""},"func16": {"source file: ": "sql1.py","line number: ": "1396","func name: ": "_get_valid_sqlite_name","func arg: ": "(name)","comments: ": ""},"func17": {"source file: ": "sql1.py","line number: ": "1760","func name: ": "get_schema","func arg: ": "(frame, name, keys, con, dtype)","comments: ": "Get the SQL db table schema for the given frame.\n\nParameters ---------- frame : DataFrame name : string name of SQL table keys : string or sequence, default: None columns to use a primary key con: an open SQL database connection object or a SQLAlchemy connectable Using SQLAlchemy makes it possible to use any DB supported by that library, default: None If a DBAPI2 object, only sqlite3 is supported. dtype : dict of column name to SQL type, default None Optional specifying the datatype for columns. The SQL type should be a SQLAlchemy type, or a string for sqlite3 fallback connection.\n"}}{"func1": {"source file: ": "stata1.py","line number: ": "164","func name: ": "read_stata","func arg: ": "(filepath_or_buffer, convert_dates, convert_categoricals, index_col, convert_missing, preserve_dtypes, columns, order_categoricals, chunksize, iterator)","comments: ": ""},"func2": {"source file: ": "stata1.py","line number: ": "205","func name: ": "_stata_elapsed_date_to_datetime_vec","func arg: ": "(dates, fmt)","comments: ": "Convert from SIF to datetime. http://www.stata.com/help.cgi?datetime\n\nParameters ---------- dates : Series The Stata Internal Format date to convert to datetime according to fmt fmt : str The format to convert to. Can be, tc, td, tw, tm, tq, th, ty\n##### Returns\n* **converted **: Series\nThe converted dates\n\n* **dtype**: datetime64[ns]\n\n* **datetime/c - tc\nmilliseconds since 01jan1960 00**: 00\n\n* **datetime/C - tC - NOT IMPLEMENTED\nmilliseconds since 01jan1960 00**: 00\n\n"},"func3": {"source file: ": "stata1.py","line number: ": "370","func name: ": "_datetime_to_stata_elapsed_vec","func arg: ": "(dates, fmt)","comments: ": "Convert from datetime to SIF. http://www.stata.com/help.cgi?datetime\n\nParameters ---------- dates : Series Series or array containing datetime.datetime or datetime64[ns] to convert to the Stata Internal Format given by fmt fmt : str The format to convert to. Can be, tc, td, tw, tm, tq, th, ty\n"},"func4": {"source file: ": "stata1.py","line number: ": "510","func name: ": "_cast_to_stata_types","func arg: ": "(data)","comments: ": "Checks the dtypes of the columns of a pandas DataFrame for compatibility with the data types and ranges supported by Stata, and converts if necessary.\n\nParameters ---------- data : DataFrame The DataFrame to check and convert\n\nNotes ----- Numeric columns in Stata must be one of int8, int16, int32, float32 or float64, with some additional value restrictions.\n\nint8 and int16 columns are checked for violations of the value restrictions and upcast if needed. int64 data is not usable in Stata, and so it is downcast to int32 whenever the value are in the int32 range, and sidecast to float64 when larger than this range.\n\nIf the int64 values are outside of the range of those perfectly representable as float64 values, a warning is raised.\n\nbool columns are cast to int8.\n\nuint columns are converted to int of the same size if there is no loss in precision, otherwise are upcast to a larger type.\n\nuint64 is currently not supported since it is concerted to object in a DataFrame.\n"},"func5": {"source file: ": "stata1.py","line number: ": "1836","func name: ": "_open_file_binary_write","func arg: ": "(fname)","comments: ": "Open a binary file or no-op if file-like.\n\nParameters ---------- fname : string path, path object or buffer\n##### Returns\n* **file **: file-like object\nFile object supporting write\n\n* **own **: bool\nTrue if the file was created, otherwise False\n\n"},"func6": {"source file: ": "stata1.py","line number: ": "1857","func name: ": "_set_endianness","func arg: ": "(endianness)","comments: ": ""},"func7": {"source file: ": "stata1.py","line number: ": "1866","func name: ": "_pad_bytes","func arg: ": "(name, length)","comments: ": "Take a char string and pads it with null bytes until it's length chars.\n\n\n"},"func8": {"source file: ": "stata1.py","line number: ": "1875","func name: ": "_convert_datetime_to_stata_type","func arg: ": "(fmt)","comments: ": "Convert from one of the stata date formats to a type in TYPE_MAP.\n\n\n"},"func9": {"source file: ": "stata1.py","line number: ": "1900","func name: ": "_maybe_convert_to_int_keys","func arg: ": "(convert_dates, varlist)","comments: ": ""},"func10": {"source file: ": "stata1.py","line number: ": "1914","func name: ": "_dtype_to_stata_type","func arg: ": "(dtype, column)","comments: ": "Convert dtype types to stata types. Returns the byte of the given ordinal. See TYPE_MAP and comments for an explanation. This is also explained in the dta spec. 1 - 244 are strings of this length PandasStata 251 - for int8  byte 252 - for int16 int 253 - for int32 long 254 - for float32   float 255 - for doubledouble\n\nIf there are dates to convert, then dtype will already have the correct type inserted.\n"},"func11": {"source file: ": "stata1.py","line number: ": "1950","func name: ": "_dtype_to_default_stata_fmt","func arg: ": "(dtype, column, dta_version, force_strl)","comments: ": "Map numpy dtype to stata's default format for this type. Not terribly important since users can change this in Stata. Semantics are\n\nobject\n\n-> \"%DDs\" where DD is the length of the string.\n\nIf not a string, raise ValueError float64 -> \"%10.0g\" float32 -> \"%9.0g\" int64\n\n -> \"%9.0g\" int32\n\n -> \"%12.0g\" int16\n\n -> \"%8.0g\" int8\n\n\n\n-> \"%8.0g\" strl\n\n\n\n-> \"%9s\"\n"},"func12": {"source file: ": "stata1.py","line number: ": "2587","func name: ": "_dtype_to_stata_type_117","func arg: ": "(dtype, column, force_strl)","comments: ": "Converts dtype types to stata types. Returns the byte of the given ordinal. See TYPE_MAP and comments for an explanation. This is also explained in the dta spec. 1 - 2045 are strings of this length PandasStata 32768 - for objectstrL 65526 - for int8  byte 65527 - for int16 int 65528 - for int32 long 65529 - for float32   float 65530 - for doubledouble\n\nIf there are dates to convert, then dtype will already have the correct type inserted.\n"},"func13": {"source file: ": "stata1.py","line number: ": "2629","func name: ": "_pad_bytes_new","func arg: ": "(name, length)","comments: ": "Takes a bytes instance and pads it with null bytes until it's length chars.\n\n\n"}}{}{"func1": {"source file: ": "strings1.py","line number: ": "59","func name: ": "cat_core","func arg: ": "(list_of_columns, sep)","comments: ": "Auxiliary function for :meth:`str.cat`\n\nParameters ---------- list_of_columns : list of numpy arrays List of arrays to be concatenated with sep; these arrays may not contain NaNs! sep : string The separator string for concatenating the columns.\n##### Returns\n"},"func2": {"source file: ": "strings1.py","line number: ": "86","func name: ": "cat_safe","func arg: ": "(list_of_columns, sep)","comments: ": "Auxiliary function for :meth:`str.cat`.\n\nSame signature as cat_core, but handles TypeErrors in concatenation, which happen if the arrays in list_of columns have the wrong dtypes or content.\n\nParameters ---------- list_of_columns : list of numpy arrays List of arrays to be concatenated with sep; these arrays may not contain NaNs! sep : string The separator string for concatenating the columns.\n##### Returns\n"},"func3": {"source file: ": "strings1.py","line number: ": "122","func name: ": "_na_map","func arg: ": "(f, arr, na_result, dtype)","comments: ": ""},"func4": {"source file: ": "strings1.py","line number: ": "134","func name: ": "_map_stringarray","func arg: ": "(func, arr, na_value, dtype)","comments: ": "Map a callable over valid elements of a StringArrray.\n\nParameters ---------- func : Callable[[str], Any] Apply to each valid element. arr : StringArray na_value : Any The value to use for missing values. By default, this is the original value (NA). dtype : Dtype The result dtype to use. Specifying this avoids an intermediate object-dtype allocation.\n##### Returns\n"},"func5": {"source file: ": "strings1.py","line number: ": "204","func name: ": "_map_object","func arg: ": "(f, arr, na_mask, na_value, dtype)","comments: ": ""},"func6": {"source file: ": "strings1.py","line number: ": "245","func name: ": "str_count","func arg: ": "(arr, pat, flags)","comments: ": "Count occurrences of pattern in each string of the Series/Index.\n\nThis function is used to count the number of times a particular regex pattern is repeated in each of the string elements of the :class:`~pandas.Series`.\n\nParameters ---------- pat : str Valid regular expression. flags : int, default 0, meaning no flags Flags for the `re` module. For a complete list, `see here <https://docs.python.org/3/howto/regex.html#compilation-flags>`_. **kwargs For compatibility with other string methods. Not used.\n##### Returns\n* **re **: Standard library module for regular expressions.\n\n* **str.count **: Standard library version, without regular expression support.\n\n* **dtype**: int64\n\n"},"func7": {"source file: ": "strings1.py","line number: ": "314","func name: ": "str_contains","func arg: ": "(arr, pat, case, flags, na, regex)","comments: ": "Test if pattern or regex is contained within a string of a Series or Index.\n\nReturn boolean Series or Index based on whether a given pattern or regex is contained within a string of a Series or Index.\n\nParameters ---------- pat : str Character sequence or regular expression. case : bool, default True If True, case sensitive. flags : int, default 0 (no flags) Flags to pass through to the re module, e.g. re.IGNORECASE. na : default NaN Fill value for missing values. regex : bool, default True If True, assumes the pat is a regular expression.\n\nIf False, treats the pat as a literal string.\n##### Returns\n* **match **: Analogous, but stricter, relying on re.match instead of re.search.\n\n* **Series.str.startswith **: Test if the start of each string element matches a\npattern.\n\n* **Series.str.endswith **: Same as startswith, but tests the end of string.\n\n* **dtype**: bool\n\n"},"func8": {"source file: ": "strings1.py","line number: ": "463","func name: ": "str_startswith","func arg: ": "(arr, pat, na)","comments: ": "Test if the start of each string element matches a pattern.\n\nEquivalent to :meth:`str.startswith`.\n\nParameters ---------- pat : str Character sequence. Regular expressions are not accepted. na : object, default NaN Object shown if element tested is not a string.\n##### Returns\n* **str.startswith **: Python standard library string method.\n\n* **Series.str.endswith **: Same as startswith, but tests the end of string.\n\n* **Series.str.contains **: Tests if string element contains a pattern.\n\n* **dtype**: bool\n\n"},"func9": {"source file: ": "strings1.py","line number: ": "518","func name: ": "str_endswith","func arg: ": "(arr, pat, na)","comments: ": "Test if the end of each string element matches a pattern.\n\nEquivalent to :meth:`str.endswith`.\n\nParameters ---------- pat : str Character sequence. Regular expressions are not accepted. na : object, default NaN Object shown if element tested is not a string.\n##### Returns\n* **str.endswith **: Python standard library string method.\n\n* **Series.str.startswith **: Same as endswith, but tests the start of string.\n\n* **Series.str.contains **: Tests if string element contains a pattern.\n\n* **dtype**: bool\n\n"},"func10": {"source file: ": "strings1.py","line number: ": "573","func name: ": "str_replace","func arg: ": "(arr, pat, repl, n, case, flags, regex)","comments: ": "Replace occurrences of pattern/regex in the Series/Index with some other string. Equivalent to :meth:`str.replace` or :func:`re.sub`.\n\nParameters ---------- pat : str or compiled regex String can be a character sequence or regular expression. repl : str or callable Replacement string or a callable. The callable is passed the regex match object and must return a replacement string to be used. See :func:`re.sub`. n : int, default -1 (all) Number of replacements to make from start. case : bool, default None Determines if replace is case sensitive:\n\n- If True, case sensitive (the default if `pat` is a string)\n\n- Set to False for case insensitive\n\n- Cannot be set if `pat` is a compiled regex.\n\nflags : int, default 0 (no flags) Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled regex. regex : bool, default True Determines if assumes the passed-in pattern is a regular expression:\n\n- If True, assumes the passed-in pattern is a regular expression.\n\n- If False, treats the pattern as a literal string\n\n- Cannot be set to False if `pat` is a compiled regex or `repl` is a callable.\n\n.. versionadded:: 0.23.0\n##### Returns\n"},"func11": {"source file: ": "strings1.py","line number: ": "729","func name: ": "str_repeat","func arg: ": "(arr, repeats)","comments: ": "Duplicate each string in the Series or Index.\n\nParameters ---------- repeats : int or sequence of int Same value for all (int) or different value per (sequence).\n##### Returns\n* **dtype**: object\n\n"},"func12": {"source file: ": "strings1.py","line number: ": "793","func name: ": "str_match","func arg: ": "(arr, pat, case, flags, na)","comments: ": "Determine if each string matches a regular expression.\n\nParameters ---------- pat : str Character sequence or regular expression. case : bool, default True If True, case sensitive. flags : int, default 0 (no flags) Regex module flags, e.g. re.IGNORECASE. na : default NaN Fill value for missing values.\n##### Returns\n* **contains **: Analogous, but less strict, relying on re.search instead of\nre.match.\n\n* **extract **: Extract matched groups.\n\n"},"func13": {"source file: ": "strings1.py","line number: ": "829","func name: ": "_get_single_group_name","func arg: ": "(rx)","comments: ": ""},"func14": {"source file: ": "strings1.py","line number: ": "836","func name: ": "_groups_or_na_fun","func arg: ": "(regex)","comments: ": "Used in both extract_noexpand and extract_frame\n\n\n"},"func15": {"source file: ": "strings1.py","line number: ": "854","func name: ": "_result_dtype","func arg: ": "(arr)","comments: ": ""},"func16": {"source file: ": "strings1.py","line number: ": "864","func name: ": "_str_extract_noexpand","func arg: ": "(arr, pat, flags)","comments: ": "Find groups in each string in the Series using passed regular expression. This function is called from str_extract(expand=False), and can return Series, DataFrame, or Index.\n\n\n"},"func17": {"source file: ": "strings1.py","line number: ": "899","func name: ": "_str_extract_frame","func arg: ": "(arr, pat, flags)","comments: ": "For each subject string in the Series, extract groups from the first match of regular expression pat. This function is called from str_extract(expand=True), and always returns a DataFrame.\n\n\n"},"func18": {"source file: ": "strings1.py","line number: ": "928","func name: ": "str_extract","func arg: ": "(arr, pat, flags, expand)","comments: ": "Extract capture groups in the regex `pat` as columns in a DataFrame.\n\nFor each subject string in the Series, extract groups from the first match of regular expression `pat`.\n\nParameters ---------- pat : str Regular expression pattern with capturing groups. flags : int, default 0 (no flags) Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that modify regular expression matching for things like case, spaces, etc. For more details, see :mod:`re`. expand : bool, default True If True, return DataFrame with one column per capture group. If False, return a Series/Index if there is one capture group or DataFrame if there are multiple capture groups.\n##### Returns\n* **extractall **: Returns all matches (not just the first match).\n\n* **dtype**: object\n\n"},"func19": {"source file: ": "strings1.py","line number: ": "1018","func name: ": "str_extractall","func arg: ": "(arr, pat, flags)","comments: ": "For each subject string in the Series, extract groups from all matches of regular expression pat. When each subject string in the Series has exactly one match, extractall(pat).xs(0, level='match') is the same as extract(pat).\n\nParameters ---------- pat : str Regular expression pattern with capturing groups. flags : int, default 0 (no flags) A ``re`` module flag, for example ``re.IGNORECASE``. These allow to modify regular expression matching for things like case, spaces, etc. Multiple flags can be combined with the bitwise OR operator, for example ``re.IGNORECASE | re.MULTILINE``.\n##### Returns\n* **extract **: Returns first match only (not all matches).\n\n"},"func20": {"source file: ": "strings1.py","line number: ": "1130","func name: ": "str_get_dummies","func arg: ": "(arr, sep)","comments: ": "Split each string in the Series by sep and return a DataFrame of dummy/indicator variables.\n\nParameters ---------- sep : str, default \"|\" String to split on.\n##### Returns\n* **get_dummies **: Convert categorical variable into dummy/indicator\nvariables.\n\n"},"func21": {"source file: ": "strings1.py","line number: ": "1183","func name: ": "str_join","func arg: ": "(arr, sep)","comments: ": "Join lists contained as elements in the Series/Index with passed delimiter.\n\nIf the elements of a Series are lists themselves, join the content of these lists using the delimiter passed to the function. This function is an equivalent to :meth:`str.join`.\n\nParameters ---------- sep : str Delimiter to use between list entries.\n##### Returns\n* **Series/Index**: object\nThe list entries concatenated by intervening occurrences of the\ndelimiter.\n\n"},"func22": {"source file: ": "strings1.py","line number: ": "1248","func name: ": "str_findall","func arg: ": "(arr, pat, flags)","comments: ": "Find all occurrences of pattern or regular expression in the Series/Index.\n\nEquivalent to applying :func:`re.findall` to all the elements in the Series/Index.\n\nParameters ---------- pat : str Pattern or regular expression. flags : int, default 0 Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which means no flags).\n##### Returns\n* **count **: Count occurrences of pattern or regular expression in each string\nof the Series/Index.\n\n* **extractall **: For each string in the Series, extract groups from all matches\nof regular expression and return a DataFrame with one row for each\nmatch and one column for each group.\n\n* **re.findall **: The equivalent ``re`` function to all non-overlapping matches\nof pattern or regular expression in string, as a list of strings.\n\n* **The search for the pattern 'Monkey' returns one match**: \n\n* **dtype**: object\n\n* **match**: \n\n* **to find the pattern 'MONKEY' ignoring the case**: \n\n* **are returned**: \n\n* **strings ending with the word 'on' is shown next**: \n\n* **multiple strings is returned**: \n\n"},"func23": {"source file: ": "strings1.py","line number: ": "1342","func name: ": "str_find","func arg: ": "(arr, sub, start, end, side)","comments: ": "Return indexes in each strings in the Series/Index where the substring is fully contained between [start:end]. Return -1 on failure.\n\nParameters ---------- sub : str Substring being searched. start : int Left edge index. end : int Right edge index. side : {'left', 'right'}, default 'left' Specifies a starting side, equivalent to ``find`` or ``rfind``.\n##### Returns\n"},"func24": {"source file: ": "strings1.py","line number: ": "1383","func name: ": "str_index","func arg: ": "(arr, sub, start, end, side)","comments: ": ""},"func25": {"source file: ": "strings1.py","line number: ": "1403","func name: ": "str_pad","func arg: ": "(arr, width, side, fillchar)","comments: ": "Pad strings in the Series/Index up to width.\n\nParameters ---------- width : int Minimum width of resulting string; additional characters will be filled with character defined in `fillchar`. side : {'left', 'right', 'both'}, default 'left' Side from which to fill resulting string. fillchar : str, default ' ' Additional character for filling, default is whitespace.\n##### Returns\n* **Series.str.rjust **: Fills the left side of strings with an arbitrary\ncharacter. Equivalent to ``Series.str.pad(side='left')``.\n\n* **Series.str.ljust **: Fills the right side of strings with an arbitrary\ncharacter. Equivalent to ``Series.str.pad(side='right')``.\n\n* **Series.str.center **: Fills boths sides of strings with an arbitrary\ncharacter. Equivalent to ``Series.str.pad(side='both')``.\n\n* **Series.str.zfill **: Pad strings in the Series/Index by prepending '0'\ncharacter. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.\n\n* **dtype**: object\n\n"},"func26": {"source file: ": "strings1.py","line number: ": "1479","func name: ": "str_split","func arg: ": "(arr, pat, n)","comments: ": ""},"func27": {"source file: ": "strings1.py","line number: ": "1499","func name: ": "str_rsplit","func arg: ": "(arr, pat, n)","comments: ": ""},"func28": {"source file: ": "strings1.py","line number: ": "1508","func name: ": "str_slice","func arg: ": "(arr, start, stop, step)","comments: ": "Slice substrings from each element in the Series or Index.\n\nParameters ---------- start : int, optional Start position for slice operation. stop : int, optional Stop position for slice operation. step : int, optional Step size for slice operation.\n##### Returns\n* **Series.str.slice_replace **: Replace a slice with a string.\n\n* **Series.str.get **: Return element at position.\nEquivalent to `Series.str.slice(start=i, stop=i+1)` with `i`\nbeing the position.\n\n* **dtype**: object\n\n* **Equivalent behaviour to**: \n\n* **>>> s.str[0**: 5\n\n"},"func29": {"source file: ": "strings1.py","line number: ": "1585","func name: ": "str_slice_replace","func arg: ": "(arr, start, stop, repl)","comments: ": "Replace a positional slice of a string with another value.\n\nParameters ---------- start : int, optional Left index position to use for the slice. If not specified (None), the slice is unbounded on the left, i.e. slice from the start of the string. stop : int, optional Right index position to use for the slice. If not specified (None), the slice is unbounded on the right, i.e. slice until the end of the string. repl : str, optional String for replacement. If not specified (None), the sliced region is replaced with an empty string.\n##### Returns\n* **Series.str.slice **: Just slicing without replacement.\n\n* **dtype**: object\n\n"},"func30": {"source file: ": "strings1.py","line number: ": "1676","func name: ": "str_strip","func arg: ": "(arr, to_strip, side)","comments: ": "Strip whitespace (including newlines) from each string in the Series/Index.\n\nParameters ---------- to_strip : str or unicode side : {'left', 'right', 'both'}, default 'both'\n##### Returns\n"},"func31": {"source file: ": "strings1.py","line number: ": "1701","func name: ": "str_wrap","func arg: ": "(arr, width, **kwargs)","comments: ": "Wrap long strings in the Series/Index to be formatted in paragraphs with length less than a given width.\n\nThis method has the same keyword parameters and defaults as :class:`textwrap.TextWrapper`.\n\nParameters ---------- width : int Maximum line width. expand_tabs : bool, optional If True, tab characters will be expanded to spaces (default: True). replace_whitespace : bool, optional If True, each whitespace character (as defined by string.whitespace) remaining after tab expansion will be replaced by a single space (default: True). drop_whitespace : bool, optional If True, whitespace that, after wrapping, happens to end up at the beginning or end of a line is dropped (default: True). break_long_words : bool, optional If True, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width (default: True). break_on_hyphens : bool, optional If True, wrapping will occur preferably on whitespace and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words (default: True).\n##### Returns\n* **Internally, this method uses a **: class\n\n* **function, use the arguments**: \n\n* **dtype**: object\n\n"},"func32": {"source file: ": "strings1.py","line number: ": "1765","func name: ": "str_translate","func arg: ": "(arr, table)","comments: ": "Map all characters in the string through the given mapping table. Equivalent to standard :meth:`str.translate`.\n\nParameters ---------- table : dict Table is a mapping of Unicode ordinals to Unicode ordinals, strings, or None. Unmapped characters are left untouched. Characters mapped to None are deleted. :meth:`str.maketrans` is a helper function for making translation tables.\n##### Returns\n"},"func33": {"source file: ": "strings1.py","line number: ": "1785","func name: ": "str_get","func arg: ": "(arr, i)","comments: ": "Extract element from each component at specified position.\n\nExtract element from lists, tuples, or strings in each element in the Series/Index.\n\nParameters ---------- i : int Position of element to extract.\n##### Returns\n* **...   {1**: \"Hello\", \"2\"\n\n* **5{1**: 'Hello', '2'\n\n* **dtype**: object\n\n"},"func34": {"source file: ": "strings1.py","line number: ": "1847","func name: ": "str_decode","func arg: ": "(arr, encoding, errors)","comments: ": "Decode character string in the Series/Index using indicated encoding. Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in python3.\n\nParameters ---------- encoding : str errors : str, optional\n##### Returns\n"},"func35": {"source file: ": "strings1.py","line number: ": "1871","func name: ": "str_encode","func arg: ": "(arr, encoding, errors)","comments: ": "Encode character string in the Series/Index using indicated encoding. Equivalent to :meth:`str.encode`.\n\nParameters ---------- encoding : str errors : str, optional\n##### Returns\n* **encoded **: Series/Index of objects\n\n"},"func36": {"source file: ": "strings1.py","line number: ": "1894","func name: ": "forbid_nonstring_types","func arg: ": "(forbidden, name)","comments: ": "Decorator to forbid specific types for a method of StringMethods.\n\nFor calling `.str.{method}` on a Series or Index, it is necessary to first initialize the :class:`StringMethods` object, and then call the method. However, different methods allow different input types, and so this can not be checked during :meth:`StringMethods.__init__`, but must be done on a per-method basis. This decorator exists to facilitate this process, and make it explicit which (inferred) types are disallowed by the method.\n\n:meth:`StringMethods.__init__` allows the *union* of types its different methods allow (after skipping NaNs; see :meth:`StringMethods._validate`), namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].\n\nThe default string types ['string', 'empty'] are allowed for all methods. For the additional types ['bytes', 'mixed', 'mixed-integer'], each method then needs to forbid the types it is not intended for.\n\nParameters ---------- forbidden : list-of-str or None List of forbidden non-string types, may be one or more of `['bytes', 'mixed', 'mixed-integer']`. name : str, default None Name of the method to use in the error message. By default, this is None, in which case the name from the method being wrapped will be copied. However, for working with further wrappers (like _pat_wrapper and _noarg_wrapper), it is necessary to specify the name.\n##### Returns\n* **func **: wrapper\nThe method to which the decorator is applied, with an added check that\nenforces the inferred type to not be in the list of forbidden types.\n\n"},"func37": {"source file: ": "strings1.py","line number: ": "1962","func name: ": "_noarg_wrapper","func arg: ": "(f, name, docstring, forbidden_types, returns_string, **kargs)","comments: ": ""},"func38": {"source file: ": "strings1.py","line number: ": "1984","func name: ": "_pat_wrapper","func arg: ": "(f, flags, na, name, forbidden_types, returns_string, **kwargs)","comments: ": ""},"func39": {"source file: ": "strings1.py","line number: ": "2017","func name: ": "copy","func arg: ": "(source)","comments: ": "Copy a docstring from another source function (if present)\n\n\n"}}{"func1": {"source file: ": "style1.py","line number: ": "13","func name: ": "_get_standard_colors","func arg: ": "(num_colors, colormap, color_type, color)","comments: ": ""}}{"func1": {"source file: ": "style2.py","line number: ": "44","func name: ": "_mpl","func arg: ": "(func)","comments: ": ""},"func2": {"source file: ": "style2.py","line number: ": "1463","func name: ": "_is_visible","func arg: ": "(idx_row, idx_col, lengths)","comments: ": "Index -> {(idx_row, idx_col): bool}).\n\n\n"},"func3": {"source file: ": "style2.py","line number: ": "1470","func name: ": "_get_level_lengths","func arg: ": "(index, hidden_elements)","comments: ": "Given an index, find the level length for each element.\n\nOptional argument is a list of index positions which should not be visible.\n\nResult is a dictionary of (level, initial_position): span\n"},"func4": {"source file: ": "style2.py","line number: ": "1513","func name: ": "_maybe_wrap_formatter","func arg: ": "(formatter, na_rep)","comments: ": ""}}{}{"func1": {"source file: ": "test_aggregate1.py","line number: ": "17","func name: ": "test_groupby_agg_no_extra_calls","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_aggregate1.py","line number: ": "29","func name: ": "test_agg_regression1","func arg: ": "(tsframe)","comments: ": ""},"func3": {"source file: ": "test_aggregate1.py","line number: ": "36","func name: ": "test_agg_must_agg","func arg: ": "(df)","comments: ": ""},"func4": {"source file: ": "test_aggregate1.py","line number: ": "46","func name: ": "test_agg_ser_multi_key","func arg: ": "(df)","comments: ": ""},"func5": {"source file: ": "test_aggregate1.py","line number: ": "56","func name: ": "test_groupby_aggregation_mixed_dtype","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_aggregate1.py","line number: ": "106","func name: ": "test_groupby_aggregation_multi_level_column","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_aggregate1.py","line number: ": "125","func name: ": "test_agg_apply_corner","func arg: ": "(ts, tsframe)","comments: ": ""},"func8": {"source file: ": "test_aggregate1.py","line number: ": "146","func name: ": "test_agg_grouping_is_list_tuple","func arg: ": "(ts)","comments: ": ""},"func9": {"source file: ": "test_aggregate1.py","line number: ": "164","func name: ": "test_agg_python_multiindex","func arg: ": "(mframe)","comments: ": ""},"func10": {"source file: ": "test_aggregate1.py","line number: ": "175","func name: ": "test_aggregate_str_func","func arg: ": "(tsframe, groupbyfunc)","comments: ": ""},"func11": {"source file: ": "test_aggregate1.py","line number: ": "201","func name: ": "test_aggregate_item_by_item","func arg: ": "(df)","comments: ": ""},"func12": {"source file: ": "test_aggregate1.py","line number: ": "230","func name: ": "test_wrap_agg_out","func arg: ": "(three_group)","comments: ": ""},"func13": {"source file: ": "test_aggregate1.py","line number: ": "245","func name: ": "test_agg_multiple_functions_maintain_order","func arg: ": "(df)","comments: ": ""},"func14": {"source file: ": "test_aggregate1.py","line number: ": "254","func name: ": "test_multiple_functions_tuples_and_non_tuples","func arg: ": "(df)","comments: ": ""},"func15": {"source file: ": "test_aggregate1.py","line number: ": "268","func name: ": "test_more_flexible_frame_multi_function","func arg: ": "(df)","comments: ": ""},"func16": {"source file: ": "test_aggregate1.py","line number: ": "304","func name: ": "test_multi_function_flexible_mix","func arg: ": "(df)","comments: ": ""},"func17": {"source file: ": "test_aggregate1.py","line number: ": "328","func name: ": "test_groupby_agg_coercing_bools","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_aggregate1.py","line number: ": "344","func name: ": "test_order_aggregate_multiple_funcs","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_aggregate1.py","line number: ": "358","func name: ": "test_uint64_type_handling","func arg: ": "(dtype, how)","comments: ": ""},"func20": {"source file: ": "test_aggregate1.py","line number: ": "368","func name: ": "test_func_duplicates_raises","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_aggregate1.py","line number: ": "385","func name: ": "test_agg_index_has_complex_internals","func arg: ": "(index)","comments: ": ""},"func22": {"source file: ": "test_aggregate1.py","line number: ": "393","func name: ": "test_agg_split_block","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_aggregate1.py","line number: ": "410","func name: ": "test_agg_split_object_part_datetime","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_aggregate1.py","line number: ": "436","func name: ": "test_agg_cython_category_not_implemented_fallback","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_aggregate1.py","line number: ": "644","func name: ": "test_agg_relabel_multiindex_column","func arg: ": "(agg_col1, agg_col2, agg_col3, agg_result1, agg_result2, agg_result3)","comments: ": ""},"func26": {"source file: ": "test_aggregate1.py","line number: ": "667","func name: ": "test_agg_relabel_multiindex_raises_not_exist","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_aggregate1.py","line number: ": "678","func name: ": "test_agg_relabel_multiindex_duplicates","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_aggregate1.py","line number: ": "698","func name: ": "test_multiindex_custom_func","func arg: ": "(func)","comments: ": ""},"func29": {"source file: ": "test_aggregate1.py","line number: ": "708","func name: ": "myfunc","func arg: ": "(s)","comments: ": ""},"func30": {"source file: ": "test_aggregate1.py","line number: ": "713","func name: ": "test_lambda_named_agg","func arg: ": "(func)","comments: ": ""},"func31": {"source file: ": "test_aggregate1.py","line number: ": "735","func name: ": "test_aggregate_mixed_types","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_aggregate1.py","line number: ": "752","func name: ": "test_aggregate_udf_na_extension_type","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_aggregate1.py","line number: ": "773","func name: ": "test_groupby_aggregate_period_column","func arg: ": "(func)","comments: ": ""},"func34": {"source file: ": "test_aggregate1.py","line number: ": "787","func name: ": "test_groupby_aggregate_period_frame","func arg: ": "(func)","comments: ": ""}}{"func1": {"source file: ": "test_algos1.py","line number: ": "10","func name: ": "test_factorize","func arg: ": "(categories, ordered)","comments: ": ""},"func2": {"source file: ": "test_algos1.py","line number: ": "24","func name: ": "test_factorized_sort","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_algos1.py","line number: ": "34","func name: ": "test_factorized_sort_ordered","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_algos1.py","line number: ": "49","func name: ": "test_isin_cats","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_algos1.py","line number: ": "72","func name: ": "test_replace","func arg: ": "(to_replace, value, result, expected_error_msg)","comments: ": ""},"func6": {"source file: ": "test_algos1.py","line number: ": "87","func name: ": "test_isin_empty","func arg: ": "(empty)","comments: ": ""},"func7": {"source file: ": "test_algos1.py","line number: ": "95","func name: ": "test_diff","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_algos2.py","line number: ": "1616","func name: ": "test_quantile","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_algos2.py","line number: ": "1624","func name: ": "test_unique_label_indices","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_algos2.py","line number: ": "1690","func name: ": "test_pad_backfill_object_segfault","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_algos2.py","line number: ": "1762","func name: ": "test_is_lexsorted","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_algos2.py","line number: ": "2027","func name: ": "test_groupsort_indexer","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_algos2.py","line number: ": "2052","func name: ": "test_infinity_sort","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_algos2.py","line number: ": "2085","func name: ": "test_infinity_against_nan","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_algos2.py","line number: ": "2104","func name: ": "test_ensure_platform_int","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_algos2.py","line number: ": "2111","func name: ": "test_int64_add_overflow","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_alter_index1.py","line number: ": "21","func name: ": "test_align","func arg: ": "(datetime_series, first_slice, second_slice, join_type, fill)","comments: ": ""},"func2": {"source file: ": "test_alter_index1.py","line number: ": "62","func name: ": "test_align_fill_method","func arg: ": "(datetime_series, first_slice, second_slice, join_type, method, limit)","comments: ": ""},"func3": {"source file: ": "test_alter_index1.py","line number: ": "81","func name: ": "test_align_nocopy","func arg: ": "(datetime_series)","comments: ": ""},"func4": {"source file: ": "test_alter_index1.py","line number: ": "111","func name: ": "test_align_same_index","func arg: ": "(datetime_series)","comments: ": ""},"func5": {"source file: ": "test_alter_index1.py","line number: ": "121","func name: ": "test_align_multiindex","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_alter_index1.py","line number: ": "157","func name: ": "test_align_method","func arg: ": "(method)","comments: ": ""},"func7": {"source file: ": "test_alter_index1.py","line number: ": "167","func name: ": "test_reindex","func arg: ": "(datetime_series, string_series)","comments: ": ""},"func8": {"source file: ": "test_alter_index1.py","line number: ": "206","func name: ": "test_reindex_nan","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_alter_index1.py","line number: ": "218","func name: ": "test_reindex_series_add_nat","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_alter_index1.py","line number: ": "230","func name: ": "test_reindex_with_datetimes","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_alter_index1.py","line number: ": "242","func name: ": "test_reindex_corner","func arg: ": "(datetime_series)","comments: ": ""},"func12": {"source file: ": "test_alter_index1.py","line number: ": "264","func name: ": "test_reindex_pad","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_alter_index1.py","line number: ": "305","func name: ": "test_reindex_nearest","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_alter_index1.py","line number: ": "329","func name: ": "test_reindex_backfill","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_alter_index1.py","line number: ": "333","func name: ": "test_reindex_int","func arg: ": "(datetime_series)","comments: ": ""},"func16": {"source file: ": "test_alter_index1.py","line number: ": "348","func name: ": "test_reindex_bool","func arg: ": "(datetime_series)","comments: ": ""},"func17": {"source file: ": "test_alter_index1.py","line number: ": "364","func name: ": "test_reindex_bool_pad","func arg: ": "(datetime_series)","comments: ": ""},"func18": {"source file: ": "test_alter_index1.py","line number: ": "372","func name: ": "test_reindex_categorical","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_alter_index1.py","line number: ": "396","func name: ": "test_reindex_like","func arg: ": "(datetime_series)","comments: ": ""},"func20": {"source file: ": "test_alter_index1.py","line number: ": "415","func name: ": "test_reindex_fill_value","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_alter_index1.py","line number: ": "466","func name: ": "test_reindex_datetimeindexes_tz_naive_and_aware","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_alter_index1.py","line number: ": "475","func name: ": "test_reindex_empty_series_tz_dtype","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_alter_index1.py","line number: ": "482","func name: ": "test_rename","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_alter_index1.py","line number: ": "505","func name: ": "test_drop_unique_and_non_unique_index","func arg: ": "(data, index, axis, drop_labels, expected_data, expected_index)","comments: ": ""},"func25": {"source file: ": "test_alter_index1.py","line number: ": "525","func name: ": "test_drop_exception_raised","func arg: ": "(data, index, drop_labels, axis, error_type, error_desc)","comments: ": ""},"func26": {"source file: ": "test_alter_index1.py","line number: ": "531","func name: ": "test_drop_with_ignore_errors","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_alter_index1.py","line number: ": "550","func name: ": "test_drop_empty_list","func arg: ": "(index, drop_labels)","comments: ": ""},"func28": {"source file: ": "test_alter_index1.py","line number: ": "566","func name: ": "test_drop_non_empty_list","func arg: ": "(data, index, drop_labels)","comments: ": ""}}{}{"func1": {"source file: ": "test_analytics2.py","line number: ": "28","func name: ": "assert_stat_op_calc","func arg: ": "(opname, alternative, frame, has_skipna, check_dtype, check_dates, check_less_precise, skipna_alternative)","comments: ": "Check that operator opname works as advertised on frame\n\nParameters ---------- opname : string Name of the operator to test on frame alternative : function Function that opname is tested against; i.e. \"frame.opname()\" should equal \"alternative(frame)\". frame : DataFrame The object that the tests are executed on has_skipna : bool, default True Whether the method \"opname\" has the kwarg \"skip_na\" check_dtype : bool, default True Whether the dtypes of the result of \"frame.opname()\" and \"alternative(frame)\" should be checked. check_dates : bool, default false Whether opname should be tested on a Datetime Series check_less_precise : bool, default False Whether results should only be compared approximately; passed on to tm.assert_series_equal skipna_alternative : function, default None NaN-safe version of alternative\n"},"func2": {"source file: ": "test_analytics2.py","line number: ": "138","func name: ": "assert_stat_op_api","func arg: ": "(opname, float_frame, float_string_frame, has_numeric_only)","comments: ": "Check that API for operator opname works as advertised on frame\n\nParameters ---------- opname : string Name of the operator to test on frame float_frame : DataFrame DataFrame with columns of type float float_string_frame : DataFrame DataFrame with both float and string columns has_numeric_only : bool, default False Whether the method \"opname\" has the kwarg \"numeric_only\"\n"},"func3": {"source file: ": "test_analytics2.py","line number: ": "165","func name: ": "assert_bool_op_calc","func arg: ": "(opname, alternative, frame, has_skipna)","comments: ": "Check that bool operator opname works as advertised on frame\n\nParameters ---------- opname : string Name of the operator to test on frame alternative : function Function that opname is tested against; i.e. \"frame.opname()\" should equal \"alternative(frame)\". frame : DataFrame The object that the tests are executed on has_skipna : bool, default True Whether the method \"opname\" has the kwarg \"skip_na\"\n"},"func4": {"source file: ": "test_analytics2.py","line number: ": "229","func name: ": "assert_bool_op_api","func arg: ": "(opname, bool_frame_with_na, float_string_frame, has_bool_only)","comments: ": "Check that API for boolean operator opname works as advertised on frame\n\nParameters ---------- opname : string Name of the operator to test on frame float_frame : DataFrame DataFrame with columns of type float float_string_frame : DataFrame DataFrame with both float and string columns has_bool_only : bool, default False Whether the method \"opname\" has the kwarg \"bool_only\"\n"}}{}{"func1": {"source file: ": "test_analytics4.py","line number: ": "11","func name: ": "test_shift","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_analytics4.py","line number: ": "21","func name: ": "test_groupby","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_analytics4.py","line number: ": "33","func name: ": "test_truncate","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_analytics4.py","line number: ": "60","func name: ": "test_where","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_analytics4.py","line number: ": "69","func name: ": "test_where_array_like","func arg: ": "(klass)","comments: ": ""},"func6": {"source file: ": "test_analytics4.py","line number: ": "80","func name: ": "test_reorder_levels","func arg: ": "(idx)","comments: ": ""},"func7": {"source file: ": "test_analytics4.py","line number: ": "86","func name: ": "test_numpy_repeat","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_analytics4.py","line number: ": "100","func name: ": "test_append_mixed_dtypes","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_analytics4.py","line number: ": "149","func name: ": "test_take","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_analytics4.py","line number: ": "164","func name: ": "test_take_invalid_kwargs","func arg: ": "(idx)","comments: ": ""},"func11": {"source file: ": "test_analytics4.py","line number: ": "181","func name: ": "test_take_fill_value","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_analytics4.py","line number: ": "226","func name: ": "test_iter","func arg: ": "(idx)","comments: ": ""},"func13": {"source file: ": "test_analytics4.py","line number: ": "239","func name: ": "test_sub","func arg: ": "(idx)","comments: ": ""},"func14": {"source file: ": "test_analytics4.py","line number: ": "256","func name: ": "test_map","func arg: ": "(idx)","comments: ": ""},"func15": {"source file: ": "test_analytics4.py","line number: ": "277","func name: ": "test_map_dictlike","func arg: ": "(idx, mapper)","comments: ": ""},"func16": {"source file: ": "test_analytics4.py","line number: ": "327","func name: ": "test_numpy_ufuncs","func arg: ": "(idx, func)","comments: ": ""},"func17": {"source file: ": "test_analytics4.py","line number: ": "349","func name: ": "test_numpy_type_funcs","func arg: ": "(idx, func)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_api3.py","line number: ": "252","func name: ": "test_datetime","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_api3.py","line number: ": "263","func name: ": "test_sparsearray","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_api3.py","line number: ": "271","func name: ": "test_np","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_api6.py","line number: ": "6","func name: ": "test_namespace","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_apply1.py","line number: ": "11","func name: ": "test_rolling_apply_invalid_raw","func arg: ": "(bad_raw)","comments: ": ""},"func2": {"source file: ": "test_apply1.py","line number: ": "16","func name: ": "test_rolling_apply_out_of_bounds","func arg: ": "(engine_and_raw)","comments: ": ""},"func3": {"source file: ": "test_apply1.py","line number: ": "31","func name: ": "test_rolling_apply_with_pandas_objects","func arg: ": "(window)","comments: ": ""},"func4": {"source file: ": "test_apply1.py","line number: ": "53","func name: ": "test_rolling_apply","func arg: ": "(engine_and_raw)","comments: ": ""},"func5": {"source file: ": "test_apply1.py","line number: ": "70","func name: ": "test_all_apply","func arg: ": "(engine_and_raw)","comments: ": ""},"func6": {"source file: ": "test_apply1.py","line number: ": "87","func name: ": "test_ragged_apply","func arg: ": "(engine_and_raw)","comments: ": ""},"func7": {"source file: ": "test_apply1.py","line number: ": "116","func name: ": "test_invalid_engine","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_apply1.py","line number: ": "121","func name: ": "test_invalid_engine_kwargs_cython","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_apply1.py","line number: ": "128","func name: ": "test_invalid_raw_numba","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_apply1.py","line number: ": "136","func name: ": "test_invalid_kwargs_nopython","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_apply1.py","line number: ": "144","func name: ": "test_rolling_apply_args_kwargs","func arg: ": "(args_kwargs)","comments: ": ""}}{"func1": {"source file: ": "test_apply2.py","line number: ": "21","func name: ": "int_frame_const_col","func arg: ": "()","comments: ": "Fixture for DataFrame of ints which are constant per column\n\nColumns are ['A', 'B', 'C'], with values (per column): [1, 2, 3]\n"},"func2": {"source file: ": "test_apply2.py","line number: ": "963","func name: ": "zip_frames","func arg: ": "(frames, axis)","comments: ": "take a list of frames, zip them together under the assumption that these all have the first frames' index/columns.\n\n\n##### Returns\n* **new_frame **: DataFrame\n\n"}}{}{"func1": {"source file: ": "test_apply4.py","line number: ": "12","func name: ": "test_apply_issues","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_apply4.py","line number: ": "51","func name: ": "test_apply_trivial","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_apply4.py","line number: ": "71","func name: ": "test_apply_trivial_fail","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_apply4.py","line number: ": "85","func name: ": "test_fast_apply","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_apply4.py","line number: ": "147","func name: ": "test_group_apply_once_per_group","func arg: ": "(df, group_names)","comments: ": ""},"func6": {"source file: ": "test_apply4.py","line number: ": "192","func name: ": "test_apply_with_mixed_dtype","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_apply4.py","line number: ": "212","func name: ": "test_groupby_as_index_apply","func arg: ": "(df)","comments: ": ""},"func8": {"source file: ": "test_apply4.py","line number: ": "249","func name: ": "test_apply_concat_preserve_names","func arg: ": "(three_group)","comments: ": ""},"func9": {"source file: ": "test_apply4.py","line number: ": "284","func name: ": "test_apply_series_to_frame","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_apply4.py","line number: ": "302","func name: ": "test_apply_series_yield_constant","func arg: ": "(df)","comments: ": ""},"func11": {"source file: ": "test_apply4.py","line number: ": "307","func name: ": "test_apply_frame_yield_constant","func arg: ": "(df)","comments: ": ""},"func12": {"source file: ": "test_apply4.py","line number: ": "318","func name: ": "test_apply_frame_to_series","func arg: ": "(df)","comments: ": ""},"func13": {"source file: ": "test_apply4.py","line number: ": "326","func name: ": "test_apply_frame_concat_series","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_apply4.py","line number: ": "348","func name: ": "test_apply_transform","func arg: ": "(ts)","comments: ": ""},"func15": {"source file: ": "test_apply4.py","line number: ": "355","func name: ": "test_apply_multikey_corner","func arg: ": "(tsframe)","comments: ": ""},"func16": {"source file: ": "test_apply4.py","line number: ": "366","func name: ": "test_apply_chunk_view","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_apply4.py","line number: ": "375","func name: ": "test_apply_no_name_column_conflict","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_apply4.py","line number: ": "389","func name: ": "test_apply_typecast_fail","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_apply4.py","line number: ": "411","func name: ": "test_apply_multiindex_fail","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_apply4.py","line number: ": "435","func name: ": "test_apply_corner","func arg: ": "(tsframe)","comments: ": ""},"func21": {"source file: ": "test_apply4.py","line number: ": "441","func name: ": "test_apply_without_copy","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_apply4.py","line number: ": "470","func name: ": "test_apply_corner_cases","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_apply4.py","line number: ": "493","func name: ": "test_apply_numeric_coercion_when_datetime","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_apply4.py","line number: ": "546","func name: ": "test_apply_aggregating_timedelta_and_datetime","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_apply4.py","line number: ": "573","func name: ": "test_time_field_bug","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_apply4.py","line number: ": "601","func name: ": "test_gb_apply_list_of_unequal_len_arrays","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_apply4.py","line number: ": "628","func name: ": "test_groupby_apply_all_none","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_apply4.py","line number: ": "641","func name: ": "test_groupby_apply_none_first","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_apply4.py","line number: ": "661","func name: ": "test_groupby_apply_return_empty_chunk","func arg: ": "()","comments: ": ""},"func30": {"source file: ": "test_apply4.py","line number: ": "676","func name: ": "test_apply_with_mixed_types","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_apply4.py","line number: ": "689","func name: ": "test_func_returns_object","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_apply4.py","line number: ": "704","func name: ": "test_apply_datetime_issue","func arg: ": "(group_column_dtlike)","comments: ": ""},"func33": {"source file: ": "test_apply4.py","line number: ": "719","func name: ": "test_apply_series_return_dataframe_groups","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_apply4.py","line number: ": "758","func name: ": "test_apply_multi_level_name","func arg: ": "(category)","comments: ": ""},"func35": {"source file: ": "test_apply4.py","line number: ": "783","func name: ": "test_apply_index_has_complex_internals","func arg: ": "(index)","comments: ": ""},"func36": {"source file: ": "test_apply4.py","line number: ": "806","func name: ": "test_apply_function_returns_non_pandas_non_scalar","func arg: ": "(function, expected_values)","comments: ": ""}}{}{"func1": {"source file: ": "test_arithmetic1.py","line number: ": "13","func name: ": "_permute","func arg: ": "(obj)","comments: ": ""}}{}{"func1": {"source file: ": "test_arithmetic3.py","line number: ": "719","func name: ": "test_frame_with_zero_len_series_corner_cases","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_arithmetic3.py","line number: ": "740","func name: ": "test_zero_len_frame_with_series_corner_cases","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_arithmetic3.py","line number: ": "750","func name: ": "test_frame_single_columns_object_sum_axis_1","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_arithmetic3.py","line number: ": "761","func name: ": "test_pow_with_realignment","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_arithmetic3.py","line number: ": "772","func name: ": "test_pow_nan_with_zero","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_arithmetics1.py","line number: ": "13","func name: ": "kind","func arg: ": "(request)","comments: ": "kind kwarg to pass to SparseArray/SparseSeries\n\n\n"},"func2": {"source file: ": "test_arithmetics1.py","line number: ": "19","func name: ": "mix","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_arithmetics1.py","line number: ": "401","func name: ": "test_with_list","func arg: ": "(op)","comments: ": ""},"func4": {"source file: ": "test_arithmetics1.py","line number: ": "408","func name: ": "test_with_dataframe","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_arithmetics1.py","line number: ": "416","func name: ": "test_with_zerodim_ndarray","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_arithmetics1.py","line number: ": "429","func name: ": "test_ufuncs","func arg: ": "(ufunc, arr)","comments: ": ""},"func7": {"source file: ": "test_arithmetics1.py","line number: ": "447","func name: ": "test_binary_ufuncs","func arg: ": "(ufunc, a, b)","comments: ": ""},"func8": {"source file: ": "test_arithmetics1.py","line number: ": "455","func name: ": "test_ndarray_inplace","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_arithmetics1.py","line number: ": "463","func name: ": "test_sparray_inplace","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_arithmetics1.py","line number: ": "472","func name: ": "test_invert","func arg: ": "(fill_value)","comments: ": ""},"func11": {"source file: ": "test_arithmetics1.py","line number: ": "490","func name: ": "test_unary_op","func arg: ": "(op, fill_value)","comments: ": ""}}{"func1": {"source file: ": "test_array_to_datetime1.py","line number: ": "34","func name: ": "test_parsing_valid_dates","func arg: ": "(data, expected)","comments: ": ""},"func2": {"source file: ": "test_array_to_datetime1.py","line number: ": "51","func name: ": "test_parsing_timezone_offsets","func arg: ": "(dt_string, expected_tz)","comments: ": ""},"func3": {"source file: ": "test_array_to_datetime1.py","line number: ": "64","func name: ": "test_parsing_non_iso_timezone_offset","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_array_to_datetime1.py","line number: ": "75","func name: ": "test_parsing_different_timezone_offsets","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_array_to_datetime1.py","line number: ": "96","func name: ": "test_number_looking_strings_not_into_datetime","func arg: ": "(data)","comments: ": ""},"func6": {"source file: ": "test_array_to_datetime1.py","line number: ": "118","func name: ": "test_coerce_outside_ns_bounds","func arg: ": "(invalid_date, errors)","comments: ": ""},"func7": {"source file: ": "test_array_to_datetime1.py","line number: ": "134","func name: ": "test_coerce_outside_ns_bounds_one_valid","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_array_to_datetime1.py","line number: ": "145","func name: ": "test_coerce_of_invalid_datetimes","func arg: ": "(errors)","comments: ": ""},"func9": {"source file: ": "test_array_to_datetime1.py","line number: ": "164","func name: ": "test_to_datetime_barely_out_of_bounds","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_array_to_datetime1.py","line number: ": "188","func name: ": "test_datetime_subclass","func arg: ": "(data, expected)","comments: ": ""}}{"func1": {"source file: ": "test_array1.py","line number: ": "18","func name: ": "kind","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_array1.py","line number: ": "1163","func name: ": "test_setting_fill_value_fillna_still_works","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_array1.py","line number: ": "1177","func name: ": "test_setting_fill_value_updates","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_array1.py","line number: ": "1201","func name: ": "test_first_fill_value_loc","func arg: ": "(arr, loc)","comments: ": ""},"func5": {"source file: ": "test_array1.py","line number: ": "1210","func name: ": "test_unique_na_fill","func arg: ": "(arr, fill_value)","comments: ": ""},"func6": {"source file: ": "test_array1.py","line number: ": "1218","func name: ": "test_unique_all_sparse","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_array1.py","line number: ": "1226","func name: ": "test_map","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_array1.py","line number: ": "1244","func name: ": "test_map_missing","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_array2.py","line number: ": "145","func name: ": "test_array","func arg: ": "(data, dtype, expected)","comments: ": ""},"func2": {"source file: ": "test_array2.py","line number: ": "150","func name: ": "test_array_copy","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_array2.py","line number: ": "233","func name: ": "test_array_inference","func arg: ": "(data, expected)","comments: ": ""},"func4": {"source file: ": "test_array2.py","line number: ": "252","func name: ": "test_array_inference_fails","func arg: ": "(data)","comments: ": ""},"func5": {"source file: ": "test_array2.py","line number: ": "259","func name: ": "test_nd_raises","func arg: ": "(data)","comments: ": ""},"func6": {"source file: ": "test_array2.py","line number: ": "264","func name: ": "test_scalar_raises","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_array2.py","line number: ": "299","func name: ": "test_array_unboxes","func arg: ": "(index_or_series)","comments: ": ""},"func8": {"source file: ": "test_array2.py","line number: ": "313","func name: ": "registry_without_decimal","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_array2.py","line number: ": "320","func name: ": "test_array_not_registered","func arg: ": "(registry_without_decimal)","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_asof2.py","line number: ": "9","func name: ": "date_range_frame","func arg: ": "()","comments: ": "Fixture for DataFrame of ints with date_range index\n\nColumns are ['A', 'B'].\n"}}{"func1": {"source file: ": "test_assert_almost_equal1.py","line number: ": "8","func name: ": "_assert_almost_equal_both","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two objects are approximately equal.\n\nThis check is performed commutatively.\n\nParameters ---------- a : object The first object to compare. b : object The second object to compare. kwargs : dict The arguments passed to `tm.assert_almost_equal`.\n"},"func2": {"source file: ": "test_assert_almost_equal1.py","line number: ": "27","func name: ": "_assert_not_almost_equal","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two objects are not approximately equal.\n\nParameters ---------- a : object The first object to compare. b : object The second object to compare. kwargs : dict The arguments passed to `tm.assert_almost_equal`.\n"},"func3": {"source file: ": "test_assert_almost_equal1.py","line number: ": "48","func name: ": "_assert_not_almost_equal_both","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two objects are not approximately equal.\n\nThis check is performed commutatively.\n\nParameters ---------- a : object The first object to compare. b : object The second object to compare. kwargs : dict The arguments passed to `tm.assert_almost_equal`.\n"},"func4": {"source file: ": "test_assert_almost_equal1.py","line number: ": "77","func name: ": "test_assert_almost_equal_numbers","func arg: ": "(a, b)","comments: ": ""},"func5": {"source file: ": "test_assert_almost_equal1.py","line number: ": "82","func name: ": "test_assert_not_almost_equal_numbers","func arg: ": "(a, b)","comments: ": ""},"func6": {"source file: ": "test_assert_almost_equal1.py","line number: ": "87","func name: ": "test_assert_almost_equal_numbers_with_zeros","func arg: ": "(a, b)","comments: ": ""},"func7": {"source file: ": "test_assert_almost_equal1.py","line number: ": "92","func name: ": "test_assert_not_almost_equal_numbers_with_zeros","func arg: ": "(a, b)","comments: ": ""},"func8": {"source file: ": "test_assert_almost_equal1.py","line number: ": "97","func name: ": "test_assert_not_almost_equal_numbers_with_mixed","func arg: ": "(a, b)","comments: ": ""},"func9": {"source file: ": "test_assert_almost_equal1.py","line number: ": "107","func name: ": "test_assert_almost_equal_edge_case_ndarrays","func arg: ": "(left_dtype, right_dtype)","comments: ": ""},"func10": {"source file: ": "test_assert_almost_equal1.py","line number: ": "116","func name: ": "test_assert_almost_equal_dicts","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_assert_almost_equal1.py","line number: ": "130","func name: ": "test_assert_not_almost_equal_dicts","func arg: ": "(a, b)","comments: ": ""},"func12": {"source file: ": "test_assert_almost_equal1.py","line number: ": "135","func name: ": "test_assert_almost_equal_dict_like_object","func arg: ": "(val)","comments: ": ""},"func13": {"source file: ": "test_assert_almost_equal1.py","line number: ": "153","func name: ": "test_assert_almost_equal_strings","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_assert_almost_equal1.py","line number: ": "160","func name: ": "test_assert_not_almost_equal_strings","func arg: ": "(a, b)","comments: ": ""},"func15": {"source file: ": "test_assert_almost_equal1.py","line number: ": "167","func name: ": "test_assert_almost_equal_iterables","func arg: ": "(a, b)","comments: ": ""},"func16": {"source file: ": "test_assert_almost_equal1.py","line number: ": "185","func name: ": "test_assert_not_almost_equal_iterables","func arg: ": "(a, b)","comments: ": ""},"func17": {"source file: ": "test_assert_almost_equal1.py","line number: ": "189","func name: ": "test_assert_almost_equal_null","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_assert_almost_equal1.py","line number: ": "194","func name: ": "test_assert_not_almost_equal_null","func arg: ": "(a, b)","comments: ": ""},"func19": {"source file: ": "test_assert_almost_equal1.py","line number: ": "210","func name: ": "test_assert_almost_equal_inf","func arg: ": "(a, b)","comments: ": ""},"func20": {"source file: ": "test_assert_almost_equal1.py","line number: ": "214","func name: ": "test_assert_not_almost_equal_inf","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_assert_almost_equal1.py","line number: ": "227","func name: ": "test_assert_almost_equal_pandas","func arg: ": "(a, b)","comments: ": ""},"func22": {"source file: ": "test_assert_almost_equal1.py","line number: ": "231","func name: ": "test_assert_almost_equal_object","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_assert_almost_equal1.py","line number: ": "237","func name: ": "test_assert_almost_equal_value_mismatch","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_assert_almost_equal1.py","line number: ": "248","func name: ": "test_assert_almost_equal_class_mismatch","func arg: ": "(a, b, klass1, klass2)","comments: ": ""},"func25": {"source file: ": "test_assert_almost_equal1.py","line number: ": "260","func name: ": "test_assert_almost_equal_value_mismatch1","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_assert_almost_equal1.py","line number: ": "271","func name: ": "test_assert_almost_equal_value_mismatch2","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_assert_almost_equal1.py","line number: ": "282","func name: ": "test_assert_almost_equal_value_mismatch3","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_assert_almost_equal1.py","line number: ": "295","func name: ": "test_assert_almost_equal_value_mismatch4","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_assert_almost_equal1.py","line number: ": "306","func name: ": "test_assert_almost_equal_shape_mismatch_override","func arg: ": "()","comments: ": ""},"func30": {"source file: ": "test_assert_almost_equal1.py","line number: ": "316","func name: ": "test_assert_almost_equal_unicode","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_assert_almost_equal1.py","line number: ": "328","func name: ": "test_assert_almost_equal_timestamp","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_assert_almost_equal1.py","line number: ": "342","func name: ": "test_assert_almost_equal_iterable_length_mismatch","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_assert_almost_equal1.py","line number: ": "353","func name: ": "test_assert_almost_equal_iterable_values_mismatch","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_assert_categorical_equal1.py","line number: ": "11","func name: ": "test_categorical_equal","func arg: ": "(c)","comments: ": ""},"func2": {"source file: ": "test_assert_categorical_equal1.py","line number: ": "16","func name: ": "test_categorical_equal_order_mismatch","func arg: ": "(check_category_order)","comments: ": ""},"func3": {"source file: ": "test_assert_categorical_equal1.py","line number: ": "33","func name: ": "test_categorical_equal_categories_mismatch","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_assert_categorical_equal1.py","line number: ": "47","func name: ": "test_categorical_equal_codes_mismatch","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_assert_categorical_equal1.py","line number: ": "62","func name: ": "test_categorical_equal_ordered_mismatch","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_assert_categorical_equal1.py","line number: ": "78","func name: ": "test_categorical_equal_object_override","func arg: ": "(obj)","comments: ": ""}}{"func1": {"source file: ": "test_assert_extension_array_equal1.py","line number: ": "16","func name: ": "test_assert_extension_array_equal_not_exact","func arg: ": "(kwargs)","comments: ": ""},"func2": {"source file: ": "test_assert_extension_array_equal1.py","line number: ": "38","func name: ": "test_assert_extension_array_equal_less_precise","func arg: ": "(check_less_precise)","comments: ": ""},"func3": {"source file: ": "test_assert_extension_array_equal1.py","line number: ": "58","func name: ": "test_assert_extension_array_equal_dtype_mismatch","func arg: ": "(check_dtype)","comments: ": ""},"func4": {"source file: ": "test_assert_extension_array_equal1.py","line number: ": "79","func name: ": "test_assert_extension_array_equal_missing_values","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_assert_extension_array_equal1.py","line number: ": "95","func name: ": "test_assert_extension_array_equal_non_extension_array","func arg: ": "(side)","comments: ": ""}}{"func1": {"source file: ": "test_assert_frame_equal1.py","line number: ": "8","func name: ": "by_blocks_fixture","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_assert_frame_equal1.py","line number: ": "13","func name: ": "obj_fixture","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_assert_frame_equal1.py","line number: ": "17","func name: ": "_assert_frame_equal_both","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two DataFrame equal.\n\nThis check is performed commutatively.\n\nParameters ---------- a : DataFrame The first DataFrame to compare. b : DataFrame The second DataFrame to compare. kwargs : dict The arguments passed to `tm.assert_frame_equal`.\n"},"func4": {"source file: ": "test_assert_frame_equal1.py","line number: ": "36","func name: ": "_assert_not_frame_equal","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two DataFrame are not equal.\n\nParameters ---------- a : DataFrame The first DataFrame to compare. b : DataFrame The second DataFrame to compare. kwargs : dict The arguments passed to `tm.assert_frame_equal`.\n"},"func5": {"source file: ": "test_assert_frame_equal1.py","line number: ": "58","func name: ": "_assert_not_frame_equal_both","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two DataFrame are not equal.\n\nThis check is performed commutatively.\n\nParameters ---------- a : DataFrame The first DataFrame to compare. b : DataFrame The second DataFrame to compare. kwargs : dict The arguments passed to `tm.assert_frame_equal`.\n"},"func6": {"source file: ": "test_assert_frame_equal1.py","line number: ": "78","func name: ": "test_frame_equal_row_order_mismatch","func arg: ": "(check_like, obj_fixture)","comments: ": ""},"func7": {"source file: ": "test_assert_frame_equal1.py","line number: ": "97","func name: ": "test_frame_equal_shape_mismatch","func arg: ": "(df1, df2, obj_fixture)","comments: ": ""},"func8": {"source file: ": "test_assert_frame_equal1.py","line number: ": "125","func name: ": "test_frame_equal_index_dtype_mismatch","func arg: ": "(df1, df2, msg, check_index_type)","comments: ": ""},"func9": {"source file: ": "test_assert_frame_equal1.py","line number: ": "135","func name: ": "test_empty_dtypes","func arg: ": "(check_dtype)","comments: ": ""},"func10": {"source file: ": "test_assert_frame_equal1.py","line number: ": "151","func name: ": "test_frame_equal_index_mismatch","func arg: ": "(obj_fixture)","comments: ": ""},"func11": {"source file: ": "test_assert_frame_equal1.py","line number: ": "165","func name: ": "test_frame_equal_columns_mismatch","func arg: ": "(obj_fixture)","comments: ": ""},"func12": {"source file: ": "test_assert_frame_equal1.py","line number: ": "179","func name: ": "test_frame_equal_block_mismatch","func arg: ": "(by_blocks_fixture, obj_fixture)","comments: ": ""},"func13": {"source file: ": "test_assert_frame_equal1.py","line number: ": "217","func name: ": "test_frame_equal_unicode","func arg: ": "(df1, df2, msg, by_blocks_fixture, obj_fixture)","comments: ": ""}}{"func1": {"source file: ": "test_assert_index_equal1.py","line number: ": "8","func name: ": "test_index_equal_levels_mismatch","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_assert_index_equal1.py","line number: ": "26","func name: ": "test_index_equal_values_mismatch","func arg: ": "(check_exact)","comments: ": ""},"func3": {"source file: ": "test_assert_index_equal1.py","line number: ": "40","func name: ": "test_index_equal_length_mismatch","func arg: ": "(check_exact)","comments: ": ""},"func4": {"source file: ": "test_assert_index_equal1.py","line number: ": "54","func name: ": "test_index_equal_class_mismatch","func arg: ": "(check_exact)","comments: ": ""},"func5": {"source file: ": "test_assert_index_equal1.py","line number: ": "68","func name: ": "test_index_equal_values_close","func arg: ": "(check_exact)","comments: ": ""},"func6": {"source file: ": "test_assert_index_equal1.py","line number: ": "85","func name: ": "test_index_equal_values_less_close","func arg: ": "(check_exact, check_less_precise)","comments: ": ""},"func7": {"source file: ": "test_assert_index_equal1.py","line number: ": "103","func name: ": "test_index_equal_values_too_far","func arg: ": "(check_exact, check_less_precise)","comments: ": ""},"func8": {"source file: ": "test_assert_index_equal1.py","line number: ": "118","func name: ": "test_index_equal_level_values_mismatch","func arg: ": "(check_exact, check_less_precise)","comments: ": ""},"func9": {"source file: ": "test_assert_index_equal1.py","line number: ": "137","func name: ": "test_index_equal_names","func arg: ": "(name1, name2)","comments: ": ""},"func10": {"source file: ": "test_assert_index_equal1.py","line number: ": "157","func name: ": "test_index_equal_category_mismatch","func arg: ": "(check_categorical)","comments: ": ""}}{"func1": {"source file: ": "test_assert_interval_array_equal1.py","line number: ": "15","func name: ": "test_interval_array_equal","func arg: ": "(kwargs)","comments: ": ""},"func2": {"source file: ": "test_assert_interval_array_equal1.py","line number: ": "20","func name: ": "test_interval_array_equal_closed_mismatch","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_assert_interval_array_equal1.py","line number: ": "36","func name: ": "test_interval_array_equal_periods_mismatch","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_assert_interval_array_equal1.py","line number: ": "52","func name: ": "test_interval_array_equal_end_mismatch","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_assert_interval_array_equal1.py","line number: ": "68","func name: ": "test_interval_array_equal_start_mismatch","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "9","func name: ": "test_assert_numpy_array_equal_shape_mismatch","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "20","func name: ": "test_assert_numpy_array_equal_bad_type","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "31","func name: ": "test_assert_numpy_array_equal_class_mismatch","func arg: ": "(a, b, klass1, klass2)","comments: ": ""},"func4": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "42","func name: ": "test_assert_numpy_array_equal_value_mismatch1","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "53","func name: ": "test_assert_numpy_array_equal_value_mismatch2","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "64","func name: ": "test_assert_numpy_array_equal_value_mismatch3","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "77","func name: ": "test_assert_numpy_array_equal_value_mismatch4","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "88","func name: ": "test_assert_numpy_array_equal_value_mismatch5","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "101","func name: ": "test_assert_numpy_array_equal_value_mismatch6","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "114","func name: ": "test_assert_numpy_array_equal_shape_mismatch_override","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "125","func name: ": "test_numpy_array_equal_unicode","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "142","func name: ": "test_numpy_array_equal_object","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "158","func name: ": "test_numpy_array_equal_copy_flag","func arg: ": "(other_type, check_same)","comments: ": ""},"func14": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "181","func name: ": "test_numpy_array_equal_contains_na","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "196","func name: ": "test_numpy_array_equal_identical_na","func arg: ": "(nulls_fixture)","comments: ": ""},"func16": {"source file: ": "test_assert_numpy_array_equal1.py","line number: ": "202","func name: ": "test_numpy_array_equal_different_na","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_assert_produces_warning1.py","line number: ": "8","func name: ": "f","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_assert_produces_warning1.py","line number: ": "14","func name: ": "test_assert_produces_warning_honors_filter","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_assert_series_equal1.py","line number: ": "7","func name: ": "_assert_series_equal_both","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two Series equal.\n\nThis check is performed commutatively.\n\nParameters ---------- a : Series The first Series to compare. b : Series The second Series to compare. kwargs : dict The arguments passed to `tm.assert_series_equal`.\n"},"func2": {"source file: ": "test_assert_series_equal1.py","line number: ": "26","func name: ": "_assert_not_series_equal","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two Series are not equal.\n\nParameters ---------- a : Series The first Series to compare. b : Series The second Series to compare. kwargs : dict The arguments passed to `tm.assert_series_equal`.\n"},"func3": {"source file: ": "test_assert_series_equal1.py","line number: ": "48","func name: ": "_assert_not_series_equal_both","func arg: ": "(a, b, **kwargs)","comments: ": "Check that two Series are not equal.\n\nThis check is performed commutatively.\n\nParameters ---------- a : Series The first Series to compare. b : Series The second Series to compare. kwargs : dict The arguments passed to `tm.assert_series_equal`.\n"},"func4": {"source file: ": "test_assert_series_equal1.py","line number: ": "68","func name: ": "test_series_equal","func arg: ": "(data)","comments: ": ""},"func5": {"source file: ": "test_assert_series_equal1.py","line number: ": "82","func name: ": "test_series_not_equal_value_mismatch","func arg: ": "(data1, data2)","comments: ": ""},"func6": {"source file: ": "test_assert_series_equal1.py","line number: ": "94","func name: ": "test_series_not_equal_metadata_mismatch","func arg: ": "(kwargs)","comments: ": ""},"func7": {"source file: ": "test_assert_series_equal1.py","line number: ": "105","func name: ": "test_less_precise","func arg: ": "(data1, data2, dtype, check_less_precise)","comments: ": ""},"func8": {"source file: ": "test_assert_series_equal1.py","line number: ": "143","func name: ": "test_series_equal_index_dtype","func arg: ": "(s1, s2, msg, check_index_type)","comments: ": ""},"func9": {"source file: ": "test_assert_series_equal1.py","line number: ": "153","func name: ": "test_series_equal_length_mismatch","func arg: ": "(check_less_precise)","comments: ": ""},"func10": {"source file: ": "test_assert_series_equal1.py","line number: ": "167","func name: ": "test_series_equal_values_mismatch","func arg: ": "(check_less_precise)","comments: ": ""},"func11": {"source file: ": "test_assert_series_equal1.py","line number: ": "181","func name: ": "test_series_equal_categorical_mismatch","func arg: ": "(check_categorical)","comments: ": ""}}{"func1": {"source file: ": "test_astype1.py","line number: ": "9","func name: ": "test_astype","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_astype1.py","line number: ": "21","func name: ": "test_astype_category","func arg: ": "(idx, ordered)","comments: ": ""}}{}{}{}{}{}{"func1": {"source file: ": "test_backend1.py","line number: ": "16","func name: ": "restore_backend","func arg: ": "()","comments: ": "Restore the plotting backend to matplotlib\n\n\n"},"func2": {"source file: ": "test_backend1.py","line number: ": "23","func name: ": "test_backend_is_not_module","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_backend1.py","line number: ": "31","func name: ": "test_backend_is_correct","func arg: ": "(monkeypatch, restore_backend)","comments: ": ""},"func4": {"source file: ": "test_backend1.py","line number: ": "41","func name: ": "test_backend_can_be_set_in_plot_call","func arg: ": "(monkeypatch, restore_backend)","comments: ": ""},"func5": {"source file: ": "test_backend1.py","line number: ": "50","func name: ": "test_register_entrypoint","func arg: ": "(restore_backend)","comments: ": ""},"func6": {"source file: ": "test_backend1.py","line number: ": "79","func name: ": "test_setting_backend_without_plot_raises","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_backend1.py","line number: ": "94","func name: ": "test_no_matplotlib_ok","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_backend1.py","line number: ": "99","func name: ": "test_extra_kinds_ok","func arg: ": "(monkeypatch, restore_backend)","comments: ": ""}}{"func1": {"source file: ": "test_base_indexer1.py","line number: ": "10","func name: ": "test_bad_get_window_bounds_signature","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_base_indexer1.py","line number: ": "20","func name: ": "test_expanding_indexer","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_base_indexer1.py","line number: ": "28","func name: ": "test_indexer_constructor_arg","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_base_indexer1.py","line number: ": "52","func name: ": "test_indexer_accepts_rolling_args","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_base_indexer1.py","line number: ": "74","func name: ": "test_win_type_not_implemented","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_base1.py","line number: ": "32","func name: ": "create_index","func arg: ": "(_index_factory)","comments: ": ""},"func2": {"source file: ": "test_base1.py","line number: ": "44","func name: ": "test_asfreq","func arg: ": "(series_and_frame, freq, create_index)","comments: ": ""},"func3": {"source file: ": "test_base1.py","line number: ": "56","func name: ": "test_asfreq_fill_value","func arg: ": "(series, create_index)","comments: ": ""},"func4": {"source file: ": "test_base1.py","line number: ": "75","func name: ": "test_resample_interpolate","func arg: ": "(frame)","comments: ": ""},"func5": {"source file: ": "test_base1.py","line number: ": "83","func name: ": "test_raises_on_non_datetimelike_index","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_base1.py","line number: ": "96","func name: ": "test_resample_empty_series","func arg: ": "(freq, empty_series, resample_method)","comments: ": ""},"func7": {"source file: ": "test_base1.py","line number: ": "118","func name: ": "test_resample_count_empty_series","func arg: ": "(freq, empty_series, resample_method)","comments: ": ""},"func8": {"source file: ": "test_base1.py","line number: ": "133","func name: ": "test_resample_empty_dataframe","func arg: ": "(empty_frame, freq, resample_method)","comments: ": ""},"func9": {"source file: ": "test_base1.py","line number: ": "157","func name: ": "test_resample_count_empty_dataframe","func arg: ": "(freq, empty_frame)","comments: ": ""},"func10": {"source file: ": "test_base1.py","line number: ": "176","func name: ": "test_resample_size_empty_dataframe","func arg: ": "(freq, empty_frame)","comments: ": ""},"func11": {"source file: ": "test_base1.py","line number: ": "195","func name: ": "test_resample_empty_dtypes","func arg: ": "(index, dtype, resample_method)","comments: ": ""},"func12": {"source file: ": "test_base1.py","line number: ": "211","func name: ": "test_resample_loffset_arg_type","func arg: ": "(frame, create_index, arg)","comments: ": ""},"func13": {"source file: ": "test_base1.py","line number: ": "239","func name: ": "test_apply_to_empty_series","func arg: ": "(empty_series)","comments: ": ""},"func14": {"source file: ": "test_base1.py","line number: ": "250","func name: ": "test_resampler_is_iterable","func arg: ": "(series)","comments: ": ""},"func15": {"source file: ": "test_base1.py","line number: ": "262","func name: ": "test_resample_quantile","func arg: ": "(series)","comments: ": ""}}{}{"func1": {"source file: ": "test_base3.py","line number: ": "2772","func name: ": "test_generated_op_names","func arg: ": "(opname, indices)","comments: ": ""},"func2": {"source file: ": "test_base3.py","line number: ": "2783","func name: ": "test_index_subclass_constructor_wrong_kwargs","func arg: ": "(index_maker)","comments: ": ""},"func3": {"source file: ": "test_base3.py","line number: ": "2789","func name: ": "test_deprecated_fastpath","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_base3.py","line number: ": "2804","func name: ": "test_shape_of_invalid_index","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_base3.py","line number: ": "2816","func name: ": "test_validate_1d_input","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_bin_groupby1.py","line number: ": "13","func name: ": "test_series_grouper","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_bin_groupby1.py","line number: ": "29","func name: ": "test_series_grouper_requires_nonempty_raises","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_bin_groupby1.py","line number: ": "39","func name: ": "test_series_bin_grouper","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_bin_groupby1.py","line number: ": "55","func name: ": "assert_block_lengths","func arg: ": "(x)","comments: ": ""},"func5": {"source file: ": "test_bin_groupby1.py","line number: ": "60","func name: ": "cumsum_max","func arg: ": "(x)","comments: ": ""},"func6": {"source file: ": "test_bin_groupby1.py","line number: ": "66","func name: ": "test_mgr_locs_updated","func arg: ": "(func)","comments: ": ""},"func7": {"source file: ": "test_bin_groupby1.py","line number: ": "100","func name: ": "test_generate_bins","func arg: ": "(binner, closed, expected)","comments: ": ""},"func8": {"source file: ": "test_bin_groupby1.py","line number: ": "106","func name: ": "test_group_ohlc","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_bool1.py","line number: ": "14","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_bool1.py","line number: ": "19","func name: ": "data","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_bool1.py","line number: ": "26","func name: ": "data_missing","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_bool1.py","line number: ": "68","func name: ": "test_is_bool_dtype","func arg: ": "(data)","comments: ": ""}}{"func1": {"source file: ": "test_boolean1.py","line number: ": "15","func name: ": "make_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_boolean1.py","line number: ": "20","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_boolean1.py","line number: ": "25","func name: ": "data","func arg: ": "(dtype)","comments: ": ""},"func4": {"source file: ": "test_boolean1.py","line number: ": "29","func name: ": "test_boolean_array_constructor","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_boolean1.py","line number: ": "56","func name: ": "test_boolean_array_constructor_copy","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_boolean1.py","line number: ": "69","func name: ": "test_to_boolean_array","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_boolean1.py","line number: ": "92","func name: ": "test_to_boolean_array_all_none","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_boolean1.py","line number: ": "111","func name: ": "test_to_boolean_array_missing_indicators","func arg: ": "(a, b)","comments: ": ""},"func9": {"source file: ": "test_boolean1.py","line number: ": "132","func name: ": "test_to_boolean_array_error","func arg: ": "(values)","comments: ": ""},"func10": {"source file: ": "test_boolean1.py","line number: ": "138","func name: ": "test_to_boolean_array_from_integer_array","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_boolean1.py","line number: ": "149","func name: ": "test_to_boolean_array_from_float_array","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_boolean1.py","line number: ": "160","func name: ": "test_to_boolean_array_integer_like","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_boolean1.py","line number: ": "172","func name: ": "test_coerce_to_array","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_boolean1.py","line number: ": "211","func name: ": "test_coerce_to_array_from_boolean_array","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_boolean1.py","line number: ": "231","func name: ": "test_coerce_to_numpy_array","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_boolean1.py","line number: ": "254","func name: ": "test_to_boolean_array_from_strings","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_boolean1.py","line number: ": "265","func name: ": "test_to_boolean_array_from_strings_invalid_string","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_boolean1.py","line number: ": "270","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_boolean1.py","line number: ": "283","func name: ": "test_to_numpy","func arg: ": "(box)","comments: ": ""},"func20": {"source file: ": "test_boolean1.py","line number: ": "336","func name: ": "test_to_numpy_copy","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_boolean1.py","line number: ": "351","func name: ": "test_astype","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_boolean1.py","line number: ": "380","func name: ": "test_astype_to_boolean_array","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_boolean1.py","line number: ": "390","func name: ": "test_astype_to_integer_array","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_boolean1.py","line number: ": "400","func name: ": "test_setitem_missing_values","func arg: ": "(na)","comments: ": ""},"func25": {"source file: ": "test_boolean1.py","line number: ": "410","func name: ": "test_ufuncs_binary","func arg: ": "(ufunc)","comments: ": ""},"func26": {"source file: ": "test_boolean1.py","line number: ": "453","func name: ": "test_ufuncs_unary","func arg: ": "(ufunc)","comments: ": ""},"func27": {"source file: ": "test_boolean1.py","line number: ": "468","func name: ": "test_ufunc_reduce_raises","func arg: ": "(values)","comments: ": ""},"func28": {"source file: ": "test_boolean1.py","line number: ": "822","func name: ": "test_reductions_return_types","func arg: ": "(dropna, data, all_numeric_reductions)","comments: ": ""},"func29": {"source file: ": "test_boolean1.py","line number: ": "846","func name: ": "test_any_all","func arg: ": "(values, exp_any, exp_all, exp_any_noskip, exp_all_noskip)","comments: ": ""},"func30": {"source file: ": "test_boolean1.py","line number: ": "880","func name: ": "test_arrow_array","func arg: ": "(data)","comments: ": ""},"func31": {"source file: ": "test_boolean1.py","line number: ": "894","func name: ": "test_arrow_roundtrip","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_boolean1.py","line number: ": "907","func name: ": "test_value_counts_na","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_boolean1.py","line number: ": "918","func name: ": "test_diff","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_boolean2.py","line number: ": "14","func name: ": "test_getitem_boolean","func arg: ": "(string_series)","comments: ": ""},"func2": {"source file: ": "test_boolean2.py","line number: ": "25","func name: ": "test_getitem_boolean_empty","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_boolean2.py","line number: ": "57","func name: ": "test_getitem_boolean_object","func arg: ": "(string_series)","comments: ": ""},"func4": {"source file: ": "test_boolean2.py","line number: ": "85","func name: ": "test_getitem_setitem_boolean_corner","func arg: ": "(datetime_series)","comments: ": ""},"func5": {"source file: ": "test_boolean2.py","line number: ": "106","func name: ": "test_setitem_boolean","func arg: ": "(string_series)","comments: ": ""},"func6": {"source file: ": "test_boolean2.py","line number: ": "123","func name: ": "test_get_set_boolean_different_order","func arg: ": "(string_series)","comments: ": ""},"func7": {"source file: ": "test_boolean2.py","line number: ": "141","func name: ": "test_where_unsafe_int","func arg: ": "(sint_dtype)","comments: ": ""},"func8": {"source file: ": "test_boolean2.py","line number: ": "151","func name: ": "test_where_unsafe_float","func arg: ": "(float_dtype)","comments: ": ""},"func9": {"source file: ": "test_boolean2.py","line number: ": "173","func name: ": "test_where_unsafe_upcast","func arg: ": "(dtype, expected_dtype)","comments: ": ""},"func10": {"source file: ": "test_boolean2.py","line number: ": "183","func name: ": "test_where_unsafe","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_boolean2.py","line number: ": "238","func name: ": "test_where","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_boolean2.py","line number: ": "267","func name: ": "test_where_error","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_boolean2.py","line number: ": "296","func name: ": "test_where_array_like","func arg: ": "(klass)","comments: ": ""},"func14": {"source file: ": "test_boolean2.py","line number: ": "315","func name: ": "test_where_invalid_input","func arg: ": "(cond)","comments: ": ""},"func15": {"source file: ": "test_boolean2.py","line number: ": "328","func name: ": "test_where_ndframe_align","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_boolean2.py","line number: ": "351","func name: ": "test_where_setitem_invalid","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_boolean2.py","line number: ": "418","func name: ": "test_broadcast","func arg: ": "(size, mask, item, box)","comments: ": ""},"func18": {"source file: ": "test_boolean2.py","line number: ": "442","func name: ": "test_where_inplace","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_boolean2.py","line number: ": "457","func name: ": "test_where_dups","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_boolean2.py","line number: ": "478","func name: ": "test_where_numeric_with_string","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_boolean2.py","line number: ": "504","func name: ": "test_where_timedelta_coerce","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_boolean2.py","line number: ": "526","func name: ": "test_where_datetime_conversion","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_boolean2.py","line number: ": "555","func name: ": "test_where_dt_tz_values","func arg: ": "(tz_naive_fixture)","comments: ": ""},"func24": {"source file: ": "test_boolean2.py","line number: ": "570","func name: ": "test_mask","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_boolean2.py","line number: ": "616","func name: ": "test_mask_inplace","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_boolean3.py","line number: ": "27","func name: ": "make_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_boolean3.py","line number: ": "32","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_boolean3.py","line number: ": "37","func name: ": "data","func arg: ": "(dtype)","comments: ": ""},"func4": {"source file: ": "test_boolean3.py","line number: ": "42","func name: ": "data_for_twos","func arg: ": "(dtype)","comments: ": ""},"func5": {"source file: ": "test_boolean3.py","line number: ": "47","func name: ": "data_missing","func arg: ": "(dtype)","comments: ": ""},"func6": {"source file: ": "test_boolean3.py","line number: ": "52","func name: ": "data_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func7": {"source file: ": "test_boolean3.py","line number: ": "57","func name: ": "data_missing_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func8": {"source file: ": "test_boolean3.py","line number: ": "62","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_boolean3.py","line number: ": "68","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_boolean3.py","line number: ": "73","func name: ": "data_for_grouping","func arg: ": "(dtype)","comments: ": ""}}{}{"func1": {"source file: ": "test_c_parser_only1.py","line number: ": "28","func name: ": "test_buffer_overflow","func arg: ": "(c_parser_only, malformed)","comments: ": ""},"func2": {"source file: ": "test_c_parser_only1.py","line number: ": "38","func name: ": "test_buffer_rd_bytes","func arg: ": "(c_parser_only)","comments: ": ""},"func3": {"source file: ": "test_c_parser_only1.py","line number: ": "58","func name: ": "test_delim_whitespace_custom_terminator","func arg: ": "(c_parser_only)","comments: ": ""},"func4": {"source file: ": "test_c_parser_only1.py","line number: ": "68","func name: ": "test_dtype_and_names_error","func arg: ": "(c_parser_only)","comments: ": ""},"func5": {"source file: ": "test_c_parser_only1.py","line number: ": "136","func name: ": "test_unsupported_dtype","func arg: ": "(c_parser_only, match, kwargs)","comments: ": ""},"func6": {"source file: ": "test_c_parser_only1.py","line number: ": "150","func name: ": "test_precise_conversion","func arg: ": "(c_parser_only)","comments: ": ""},"func7": {"source file: ": "test_c_parser_only1.py","line number: ": "185","func name: ": "test_usecols_dtypes","func arg: ": "(c_parser_only)","comments: ": ""},"func8": {"source file: ": "test_c_parser_only1.py","line number: ": "214","func name: ": "test_disable_bool_parsing","func arg: ": "(c_parser_only)","comments: ": ""},"func9": {"source file: ": "test_c_parser_only1.py","line number: ": "231","func name: ": "test_custom_lineterminator","func arg: ": "(c_parser_only)","comments: ": ""},"func10": {"source file: ": "test_c_parser_only1.py","line number: ": "241","func name: ": "test_parse_ragged_csv","func arg: ": "(c_parser_only)","comments: ": ""},"func11": {"source file: ": "test_c_parser_only1.py","line number: ": "275","func name: ": "test_tokenize_CR_with_quoting","func arg: ": "(c_parser_only)","comments: ": ""},"func12": {"source file: ": "test_c_parser_only1.py","line number: ": "289","func name: ": "test_grow_boundary_at_cap","func arg: ": "(c_parser_only)","comments: ": ""},"func13": {"source file: ": "test_c_parser_only1.py","line number: ": "312","func name: ": "test_parse_trim_buffers","func arg: ": "(c_parser_only)","comments: ": ""},"func14": {"source file: ": "test_c_parser_only1.py","line number: ": "400","func name: ": "test_internal_null_byte","func arg: ": "(c_parser_only)","comments: ": ""},"func15": {"source file: ": "test_c_parser_only1.py","line number: ": "420","func name: ": "test_read_nrows_large","func arg: ": "(c_parser_only)","comments: ": ""},"func16": {"source file: ": "test_c_parser_only1.py","line number: ": "434","func name: ": "test_float_precision_round_trip_with_text","func arg: ": "(c_parser_only)","comments: ": ""},"func17": {"source file: ": "test_c_parser_only1.py","line number: ": "441","func name: ": "test_large_difference_in_columns","func arg: ": "(c_parser_only)","comments: ": ""},"func18": {"source file: ": "test_c_parser_only1.py","line number: ": "457","func name: ": "test_data_after_quote","func arg: ": "(c_parser_only)","comments: ": ""},"func19": {"source file: ": "test_c_parser_only1.py","line number: ": "468","func name: ": "test_comment_whitespace_delimited","func arg: ": "(c_parser_only, capsys)","comments: ": ""},"func20": {"source file: ": "test_c_parser_only1.py","line number: ": "497","func name: ": "test_file_like_no_next","func arg: ": "(c_parser_only)","comments: ": ""},"func21": {"source file: ": "test_c_parser_only1.py","line number: ": "517","func name: ": "test_buffer_rd_bytes_bad_unicode","func arg: ": "(c_parser_only)","comments: ": ""},"func22": {"source file: ": "test_c_parser_only1.py","line number: ": "527","func name: ": "test_read_tarfile","func arg: ": "(c_parser_only, csv_dir_path, tar_suffix)","comments: ": ""},"func23": {"source file: ": "test_c_parser_only1.py","line number: ": "545","func name: ": "test_bytes_exceed_2gb","func arg: ": "(c_parser_only)","comments: ": ""},"func24": {"source file: ": "test_c_parser_only1.py","line number: ": "559","func name: ": "test_chunk_whitespace_on_boundary","func arg: ": "(c_parser_only)","comments: ": ""},"func25": {"source file: ": "test_c_parser_only1.py","line number: ": "574","func name: ": "test_file_handles_mmap","func arg: ": "(c_parser_only, csv1)","comments: ": ""},"func26": {"source file: ": "test_c_parser_only1.py","line number: ": "588","func name: ": "test_file_binary_mode","func arg: ": "(c_parser_only)","comments: ": ""},"func27": {"source file: ": "test_c_parser_only1.py","line number: ": "602","func name: ": "test_unix_style_breaks","func arg: ": "(c_parser_only)","comments: ": ""}}{"func1": {"source file: ": "test_calendar1.py","line number: ": "22","func name: ": "test_calendar","func arg: ": "(transform)","comments: ": ""},"func2": {"source file: ": "test_calendar1.py","line number: ": "45","func name: ": "test_calendar_caching","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_calendar1.py","line number: ": "60","func name: ": "test_calendar_observance_dates","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_calendar1.py","line number: ": "82","func name: ": "test_rule_from_name","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_calendar1.py","line number: ": "87","func name: ": "test_calendar_2031","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_callable2.py","line number: ": "5","func name: ": "test_getitem_callable","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_callable2.py","line number: ": "18","func name: ": "test_setitem_callable","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_callable2.py","line number: ": "25","func name: ": "test_setitem_other_callable","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_categorical3.py","line number: ": "28","func name: ": "make_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_categorical3.py","line number: ": "40","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_categorical3.py","line number: ": "45","func name: ": "data","func arg: ": "()","comments: ": "Length-100 array for this type.\n\n* data[0] and data[1] should both be non missing * data[0] and data[1] should not gbe equal\n"},"func4": {"source file: ": "test_categorical3.py","line number: ": "55","func name: ": "data_missing","func arg: ": "()","comments: ": "Length 2 array with [NA, Valid]\n\n\n"},"func5": {"source file: ": "test_categorical3.py","line number: ": "61","func name: ": "data_for_sorting","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_categorical3.py","line number: ": "66","func name: ": "data_missing_for_sorting","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_categorical3.py","line number: ": "71","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_categorical3.py","line number: ": "76","func name: ": "data_for_grouping","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_categorical4.py","line number: ": "21","func name: ": "cartesian_product_for_groupers","func arg: ": "(result, args, names)","comments: ": "Reindex to a cartesian production for the groupers, preserving the nature (Categorical) of each grouper\n\n\n"},"func2": {"source file: ": "test_categorical4.py","line number: ": "37","func name: ": "test_apply_use_categorical_name","func arg: ": "(df)","comments: ": ""},"func3": {"source file: ": "test_categorical4.py","line number: ": "52","func name: ": "test_basic","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_categorical4.py","line number: ": "183","func name: ": "test_level_get_group","func arg: ": "(observed)","comments: ": ""},"func5": {"source file: ": "test_categorical4.py","line number: ": "214","func name: ": "test_apply","func arg: ": "(ordered)","comments: ": ""},"func6": {"source file: ": "test_categorical4.py","line number: ": "250","func name: ": "test_observed","func arg: ": "(observed)","comments: ": ""},"func7": {"source file: ": "test_categorical4.py","line number: ": "356","func name: ": "test_observed_codes_remap","func arg: ": "(observed)","comments: ": ""},"func8": {"source file: ": "test_categorical4.py","line number: ": "374","func name: ": "test_observed_perf","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_categorical4.py","line number: ": "395","func name: ": "test_observed_groups","func arg: ": "(observed)","comments: ": ""},"func10": {"source file: ": "test_categorical4.py","line number: ": "416","func name: ": "test_observed_groups_with_nan","func arg: ": "(observed)","comments: ": ""},"func11": {"source file: ": "test_categorical4.py","line number: ": "437","func name: ": "test_observed_nth","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_categorical4.py","line number: ": "452","func name: ": "test_dataframe_categorical_with_nan","func arg: ": "(observed)","comments: ": ""},"func13": {"source file: ": "test_categorical4.py","line number: ": "475","func name: ": "test_dataframe_categorical_ordered_observed_sort","func arg: ": "(ordered, observed, sort)","comments: ": ""},"func14": {"source file: ": "test_categorical4.py","line number: ": "507","func name: ": "test_datetime","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_categorical4.py","line number: ": "546","func name: ": "test_categorical_index","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_categorical4.py","line number: ": "572","func name: ": "test_describe_categorical_columns","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_categorical4.py","line number: ": "586","func name: ": "test_unstack_categorical","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_categorical4.py","line number: ": "605","func name: ": "test_bins_unequal_len","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_categorical4.py","line number: ": "615","func name: ": "test_as_index","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_categorical4.py","line number: ": "671","func name: ": "test_preserve_categories","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_categorical4.py","line number: ": "697","func name: ": "test_preserve_categorical_dtype","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_categorical4.py","line number: ": "733","func name: ": "test_preserve_on_ordered_ops","func arg: ": "(func, values)","comments: ": ""},"func23": {"source file: ": "test_categorical4.py","line number: ": "746","func name: ": "test_categorical_no_compress","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_categorical4.py","line number: ": "783","func name: ": "test_groupby_empty_with_category","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_categorical4.py","line number: ": "799","func name: ": "test_sort","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_categorical4.py","line number: ": "822","func name: ": "test_sort2","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_categorical4.py","line number: ": "880","func name: ": "test_sort_datetimelike","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_categorical4.py","line number: ": "971","func name: ": "test_empty_sum","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_categorical4.py","line number: ": "999","func name: ": "test_empty_prod","func arg: ": "()","comments: ": ""},"func30": {"source file: ": "test_categorical4.py","line number: ": "1023","func name: ": "test_groupby_multiindex_categorical_datetime","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_categorical4.py","line number: ": "1073","func name: ": "test_groupby_agg_observed_true_single_column","func arg: ": "(as_index, expected)","comments: ": ""},"func32": {"source file: ": "test_categorical4.py","line number: ": "1085","func name: ": "test_shift","func arg: ": "(fill_value)","comments: ": ""},"func33": {"source file: ": "test_categorical4.py","line number: ": "1097","func name: ": "df_cat","func arg: ": "(df)","comments: ": "DataFrame with multiple categorical columns and a column of integers. Shortened so as not to contain all possible combinations of categories. Useful for testing `observed` kwarg functionality on GroupBy objects.\n\nParameters ---------- df: DataFrame Non-categorical, longer DataFrame from another fixture, used to derive this one\n##### Returns\n* **df_cat**: DataFrame\n\n"},"func34": {"source file: ": "test_categorical4.py","line number: ": "1124","func name: ": "test_seriesgroupby_observed_true","func arg: ": "(df_cat, operation, kwargs)","comments: ": ""},"func35": {"source file: ": "test_categorical4.py","line number: ": "1140","func name: ": "test_seriesgroupby_observed_false_or_none","func arg: ": "(df_cat, observed, operation)","comments: ": ""},"func36": {"source file: ": "test_categorical4.py","line number: ": "1202","func name: ": "test_seriesgroupby_observed_apply_dict","func arg: ": "(df_cat, observed, index, data)","comments: ": ""},"func37": {"source file: ": "test_categorical4.py","line number: ": "1211","func name: ": "test_groupby_categorical_series_dataframe_consistent","func arg: ": "(df_cat)","comments: ": ""},"func38": {"source file: ": "test_categorical4.py","line number: ": "1219","func name: ": "test_groupby_categorical_axis_1","func arg: ": "(code)","comments: ": ""},"func39": {"source file: ": "test_categorical4.py","line number: ": "1228","func name: ": "test_groupby_cat_preserves_structure","func arg: ": "(observed, ordered_fixture)","comments: ": ""},"func40": {"source file: ": "test_categorical4.py","line number: ": "1245","func name: ": "test_get_nonexistent_category","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_categorical4.py","line number: ": "1256","func name: ": "test_series_groupby_on_2_categoricals_unobserved","func arg: ": "(reduction_func, observed)","comments: ": ""},"func42": {"source file: ": "test_categorical4.py","line number: ": "1309","func name: ": "test_series_groupby_on_2_categoricals_unobserved_zeroes_or_nans","func arg: ": "(func, zero_or_nan)","comments: ": ""},"func43": {"source file: ": "test_categorical4.py","line number: ": "1335","func name: ": "test_series_groupby_categorical_aggregation_getitem","func arg: ": "()","comments: ": ""},"func44": {"source file: ": "test_categorical4.py","line number: ": "1351","func name: ": "test_groupby_agg_categorical_columns","func arg: ": "(func, expected_values)","comments: ": ""},"func45": {"source file: ": "test_categorical4.py","line number: ": "1368","func name: ": "test_groupby_agg_non_numeric","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_ccalendar1.py","line number: ": "18","func name: ": "test_get_day_of_year_numeric","func arg: ": "(date_tuple, expected)","comments: ": ""},"func2": {"source file: ": "test_ccalendar1.py","line number: ": "22","func name: ": "test_get_day_of_year_dt","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_chaining_and_caching1.py","line number: ": "9","func name: ": "test_detect_chained_assignment","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_chaining_and_caching1.py","line number: ": "30","func name: ": "test_cache_updating","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_chaining_and_caching1.py","line number: ": "51","func name: ": "test_indexer_caching","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_check_indexer1.py","line number: ": "28","func name: ": "test_valid_input","func arg: ": "(indexer, expected)","comments: ": ""},"func2": {"source file: ": "test_check_indexer1.py","line number: ": "37","func name: ": "test_boolean_na_returns_indexer","func arg: ": "(indexer)","comments: ": ""},"func3": {"source file: ": "test_check_indexer1.py","line number: ": "55","func name: ": "test_bool_raise_length","func arg: ": "(indexer)","comments: ": ""},"func4": {"source file: ": "test_check_indexer1.py","line number: ": "66","func name: ": "test_int_raise_missing_values","func arg: ": "(indexer)","comments: ": ""},"func5": {"source file: ": "test_check_indexer1.py","line number: ": "84","func name: ": "test_raise_invalid_array_dtypes","func arg: ": "(indexer)","comments: ": ""},"func6": {"source file: ": "test_check_indexer1.py","line number: ": "95","func name: ": "test_pass_through_non_array_likes","func arg: ": "(indexer)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_clipboard1.py","line number: ": "14","func name: ": "build_kwargs","func arg: ": "(sep, excel)","comments: ": ""},"func2": {"source file: ": "test_clipboard1.py","line number: ": "37","func name: ": "df","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_clipboard1.py","line number: ": "105","func name: ": "mock_clipboard","func arg: ": "(monkeypatch, request)","comments: ": "Fixture mocking clipboard IO.\n\nThis mocks pandas.io.clipboard.clipboard_get and pandas.io.clipboard.clipboard_set.\n\nThis uses a local dict for storing data. The dictionary key used is the test ID, available with ``request.node.name``.\n\nThis returns the local dictionary, for direct manipulation by tests.\n"},"func4": {"source file: ": "test_clipboard1.py","line number: ": "134","func name: ": "test_mock_clipboard","func arg: ": "(mock_clipboard)","comments: ": ""},"func5": {"source file: ": "test_clipboard1.py","line number: ": "253","func name: ": "test_raw_roundtrip","func arg: ": "(data)","comments: ": ""}}{"func1": {"source file: ": "test_coercion1.py","line number: ": "18","func name: ": "check_comprehensiveness","func arg: ": "(request)","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_comment1.py","line number: ": "15","func name: ": "test_comment","func arg: ": "(all_parsers, na_values)","comments: ": ""},"func2": {"source file: ": "test_comment1.py","line number: ": "31","func name: ": "test_line_comment","func arg: ": "(all_parsers, read_kwargs)","comments: ": ""},"func3": {"source file: ": "test_comment1.py","line number: ": "56","func name: ": "test_comment_skiprows","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_comment1.py","line number: ": "74","func name: ": "test_comment_header","func arg: ": "(all_parsers)","comments: ": ""},"func5": {"source file: ": "test_comment1.py","line number: ": "91","func name: ": "test_comment_skiprows_header","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_comment1.py","line number: ": "113","func name: ": "test_custom_comment_char","func arg: ": "(all_parsers, comment_char)","comments: ": ""},"func7": {"source file: ": "test_comment1.py","line number: ": "125","func name: ": "test_comment_first_line","func arg: ": "(all_parsers, header)","comments: ": ""}}{"func1": {"source file: ": "test_common1.py","line number: ": "26","func name: ": "test_override_set_noconvert_columns","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_common1.py","line number: ": "72","func name: ": "test_empty_decimal_marker","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_common1.py","line number: ": "85","func name: ": "test_bad_stream_exception","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func4": {"source file: ": "test_common1.py","line number: ": "106","func name: ": "test_read_csv_local","func arg: ": "(all_parsers, csv1)","comments: ": ""},"func5": {"source file: ": "test_common1.py","line number: ": "140","func name: ": "test_1000_sep","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_common1.py","line number: ": "152","func name: ": "test_squeeze","func arg: ": "(all_parsers)","comments: ": ""},"func7": {"source file: ": "test_common1.py","line number: ": "171","func name: ": "test_malformed","func arg: ": "(all_parsers)","comments: ": ""},"func8": {"source file: ": "test_common1.py","line number: ": "186","func name: ": "test_malformed_chunks","func arg: ": "(all_parsers, nrows)","comments: ": ""},"func9": {"source file: ": "test_common1.py","line number: ": "205","func name: ": "test_unnamed_columns","func arg: ": "(all_parsers)","comments: ": ""},"func10": {"source file: ": "test_common1.py","line number: ": "221","func name: ": "test_csv_mixed_type","func arg: ": "(all_parsers)","comments: ": ""},"func11": {"source file: ": "test_common1.py","line number: ": "233","func name: ": "test_read_csv_low_memory_no_rows_with_index","func arg: ": "(all_parsers)","comments: ": ""},"func12": {"source file: ": "test_common1.py","line number: ": "250","func name: ": "test_read_csv_dataframe","func arg: ": "(all_parsers, csv1)","comments: ": ""},"func13": {"source file: ": "test_common1.py","line number: ": "281","func name: ": "test_read_csv_no_index_name","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func14": {"source file: ": "test_common1.py","line number: ": "308","func name: ": "test_read_csv_wrong_num_columns","func arg: ": "(all_parsers)","comments: ": ""},"func15": {"source file: ": "test_common1.py","line number: ": "322","func name: ": "test_read_duplicate_index_explicit","func arg: ": "(all_parsers)","comments: ": ""},"func16": {"source file: ": "test_common1.py","line number: ": "349","func name: ": "test_read_duplicate_index_implicit","func arg: ": "(all_parsers)","comments: ": ""},"func17": {"source file: ": "test_common1.py","line number: ": "404","func name: ": "test_parse_bool","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func18": {"source file: ": "test_common1.py","line number: ": "410","func name: ": "test_int_conversion","func arg: ": "(all_parsers)","comments: ": ""},"func19": {"source file: ": "test_common1.py","line number: ": "424","func name: ": "test_read_nrows","func arg: ": "(all_parsers, nrows)","comments: ": ""},"func20": {"source file: ": "test_common1.py","line number: ": "445","func name: ": "test_read_nrows_bad","func arg: ": "(all_parsers, nrows)","comments: ": ""},"func21": {"source file: ": "test_common1.py","line number: ": "462","func name: ": "test_read_chunksize_with_index","func arg: ": "(all_parsers, index_col)","comments: ": ""},"func22": {"source file: ": "test_common1.py","line number: ": "494","func name: ": "test_read_chunksize_bad","func arg: ": "(all_parsers, chunksize)","comments: ": ""},"func23": {"source file: ": "test_common1.py","line number: ": "511","func name: ": "test_read_chunksize_and_nrows","func arg: ": "(all_parsers, chunksize)","comments: ": ""},"func24": {"source file: ": "test_common1.py","line number: ": "529","func name: ": "test_read_chunksize_and_nrows_changing_size","func arg: ": "(all_parsers)","comments: ": ""},"func25": {"source file: ": "test_common1.py","line number: ": "551","func name: ": "test_get_chunk_passed_chunksize","func arg: ": "(all_parsers)","comments: ": ""},"func26": {"source file: ": "test_common1.py","line number: ": "567","func name: ": "test_read_chunksize_compat","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func27": {"source file: ": "test_common1.py","line number: ": "584","func name: ": "test_read_chunksize_jagged_names","func arg: ": "(all_parsers)","comments: ": ""},"func28": {"source file: ": "test_common1.py","line number: ": "596","func name: ": "test_read_data_list","func arg: ": "(all_parsers)","comments: ": ""},"func29": {"source file: ": "test_common1.py","line number: ": "610","func name: ": "test_iterator","func arg: ": "(all_parsers)","comments: ": ""},"func30": {"source file: ": "test_common1.py","line number: ": "633","func name: ": "test_iterator2","func arg: ": "(all_parsers)","comments: ": ""},"func31": {"source file: ": "test_common1.py","line number: ": "652","func name: ": "test_reader_list","func arg: ": "(all_parsers)","comments: ": ""},"func32": {"source file: ": "test_common1.py","line number: ": "675","func name: ": "test_reader_list_skiprows","func arg: ": "(all_parsers)","comments: ": ""},"func33": {"source file: ": "test_common1.py","line number: ": "696","func name: ": "test_iterator_stop_on_chunksize","func arg: ": "(all_parsers)","comments: ": ""},"func34": {"source file: ": "test_common1.py","line number: ": "720","func name: ": "test_iterator_skipfooter_errors","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func35": {"source file: ": "test_common1.py","line number: ": "729","func name: ": "test_nrows_skipfooter_errors","func arg: ": "(all_parsers)","comments: ": ""},"func36": {"source file: ": "test_common1.py","line number: ": "794","func name: ": "test_pass_names_with_index","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func37": {"source file: ": "test_common1.py","line number: ": "801","func name: ": "test_multi_index_no_level_names","func arg: ": "(all_parsers, index_col)","comments: ": ""},"func38": {"source file: ": "test_common1.py","line number: ": "824","func name: ": "test_multi_index_no_level_names_implicit","func arg: ": "(all_parsers)","comments: ": ""},"func39": {"source file: ": "test_common1.py","line number: ": "869","func name: ": "test_multi_index_blank_df","func arg: ": "(all_parsers, data, expected, header, round_trip)","comments: ": ""},"func40": {"source file: ": "test_common1.py","line number: ": "878","func name: ": "test_no_unnamed_index","func arg: ": "(all_parsers)","comments: ": ""},"func41": {"source file: ": "test_common1.py","line number: ": "893","func name: ": "test_read_csv_parse_simple_list","func arg: ": "(all_parsers)","comments: ": ""},"func42": {"source file: ": "test_common1.py","line number: ": "907","func name: ": "test_url","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func43": {"source file: ": "test_common1.py","line number: ": "924","func name: ": "test_local_file","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func44": {"source file: ": "test_common1.py","line number: ": "940","func name: ": "test_path_path_lib","func arg: ": "(all_parsers)","comments: ": ""},"func45": {"source file: ": "test_common1.py","line number: ": "947","func name: ": "test_path_local_path","func arg: ": "(all_parsers)","comments: ": ""},"func46": {"source file: ": "test_common1.py","line number: ": "956","func name: ": "test_nonexistent_path","func arg: ": "(all_parsers)","comments: ": ""},"func47": {"source file: ": "test_common1.py","line number: ": "972","func name: ": "test_missing_trailing_delimiters","func arg: ": "(all_parsers)","comments: ": ""},"func48": {"source file: ": "test_common1.py","line number: ": "987","func name: ": "test_skip_initial_space","func arg: ": "(all_parsers)","comments: ": ""},"func49": {"source file: ": "test_common1.py","line number: ": "1047","func name: ": "test_trailing_delimiters","func arg: ": "(all_parsers)","comments: ": ""},"func50": {"source file: ": "test_common1.py","line number: ": "1060","func name: ": "test_escapechar","func arg: ": "(all_parsers)","comments: ": ""},"func51": {"source file: ": "test_common1.py","line number: ": "1078","func name: ": "test_int64_min_issues","func arg: ": "(all_parsers)","comments: ": ""},"func52": {"source file: ": "test_common1.py","line number: ": "1088","func name: ": "test_parse_integers_above_fp_precision","func arg: ": "(all_parsers)","comments: ": ""},"func53": {"source file: ": "test_common1.py","line number: ": "1121","func name: ": "test_chunks_have_consistent_numerical_type","func arg: ": "(all_parsers)","comments: ": ""},"func54": {"source file: ": "test_common1.py","line number: ": "1134","func name: ": "test_warn_if_chunks_have_mismatched_type","func arg: ": "(all_parsers)","comments: ": ""},"func55": {"source file: ": "test_common1.py","line number: ": "1151","func name: ": "test_integer_overflow_bug","func arg: ": "(all_parsers, sep)","comments: ": ""},"func56": {"source file: ": "test_common1.py","line number: ": "1161","func name: ": "test_catch_too_many_names","func arg: ": "(all_parsers)","comments: ": ""},"func57": {"source file: ": "test_common1.py","line number: ": "1180","func name: ": "test_ignore_leading_whitespace","func arg: ": "(all_parsers)","comments: ": ""},"func58": {"source file: ": "test_common1.py","line number: ": "1190","func name: ": "test_chunk_begins_with_newline_whitespace","func arg: ": "(all_parsers)","comments: ": ""},"func59": {"source file: ": "test_common1.py","line number: ": "1200","func name: ": "test_empty_with_index","func arg: ": "(all_parsers)","comments: ": ""},"func60": {"source file: ": "test_common1.py","line number: ": "1210","func name: ": "test_empty_with_multi_index","func arg: ": "(all_parsers)","comments: ": ""},"func61": {"source file: ": "test_common1.py","line number: ": "1222","func name: ": "test_empty_with_reversed_multi_index","func arg: ": "(all_parsers)","comments: ": ""},"func62": {"source file: ": "test_common1.py","line number: ": "1233","func name: ": "test_float_parser","func arg: ": "(all_parsers)","comments: ": ""},"func63": {"source file: ": "test_common1.py","line number: ": "1243","func name: ": "test_scientific_no_exponent","func arg: ": "(all_parsers)","comments: ": ""},"func64": {"source file: ": "test_common1.py","line number: ": "1255","func name: ": "test_int64_overflow","func arg: ": "(all_parsers, conv)","comments: ": ""},"func65": {"source file: ": "test_common1.py","line number: ": "1300","func name: ": "test_int64_uint64_range","func arg: ": "(all_parsers, val)","comments: ": ""},"func66": {"source file: ": "test_common1.py","line number: ": "1313","func name: ": "test_outside_int64_uint64_range","func arg: ": "(all_parsers, val)","comments: ": ""},"func67": {"source file: ": "test_common1.py","line number: ": "1324","func name: ": "test_numeric_range_too_wide","func arg: ": "(all_parsers, exp_data)","comments: ": ""},"func68": {"source file: ": "test_common1.py","line number: ": "1336","func name: ": "test_empty_with_nrows_chunksize","func arg: ": "(all_parsers, iterator)","comments: ": ""},"func69": {"source file: ": "test_common1.py","line number: ": "1447","func name: ": "test_eof_states","func arg: ": "(all_parsers, data, kwargs, expected, msg)","comments: ": ""},"func70": {"source file: ": "test_common1.py","line number: ": "1460","func name: ": "test_uneven_lines_with_usecols","func arg: ": "(all_parsers, usecols)","comments: ": ""},"func71": {"source file: ": "test_common1.py","line number: ": "1500","func name: ": "test_read_empty_with_usecols","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func72": {"source file: ": "test_common1.py","line number: ": "1536","func name: ": "test_trailing_spaces","func arg: ": "(all_parsers, kwargs, expected)","comments: ": ""},"func73": {"source file: ": "test_common1.py","line number: ": "1544","func name: ": "test_raise_on_sep_with_delim_whitespace","func arg: ": "(all_parsers)","comments: ": ""},"func74": {"source file: ": "test_common1.py","line number: ": "1554","func name: ": "test_single_char_leading_whitespace","func arg: ": "(all_parsers, delim_whitespace)","comments: ": ""},"func75": {"source file: ": "test_common1.py","line number: ": "1590","func name: ": "test_empty_lines","func arg: ": "(all_parsers, sep, skip_blank_lines, exp_data)","comments: ": ""},"func76": {"source file: ": "test_common1.py","line number: ": "1610","func name: ": "test_whitespace_lines","func arg: ": "(all_parsers)","comments: ": ""},"func77": {"source file: ": "test_common1.py","line number: ": "1646","func name: ": "test_whitespace_regex_separator","func arg: ": "(all_parsers, data, expected)","comments: ": ""},"func78": {"source file: ": "test_common1.py","line number: ": "1653","func name: ": "test_verbose_read","func arg: ": "(all_parsers, capsys)","comments: ": ""},"func79": {"source file: ": "test_common1.py","line number: ": "1676","func name: ": "test_verbose_read2","func arg: ": "(all_parsers, capsys)","comments: ": ""},"func80": {"source file: ": "test_common1.py","line number: ": "1699","func name: ": "test_iteration_open_handle","func arg: ": "(all_parsers)","comments: ": ""},"func81": {"source file: ": "test_common1.py","line number: ": "1738","func name: ": "test_1000_sep_with_decimal","func arg: ": "(all_parsers, data, thousands, decimal)","comments: ": ""},"func82": {"source file: ": "test_common1.py","line number: ": "1748","func name: ": "test_euro_decimal_format","func arg: ": "(all_parsers)","comments: ": ""},"func83": {"source file: ": "test_common1.py","line number: ": "1768","func name: ": "test_inf_parsing","func arg: ": "(all_parsers, na_filter)","comments: ": ""},"func84": {"source file: ": "test_common1.py","line number: ": "1791","func name: ": "test_infinity_parsing","func arg: ": "(all_parsers, na_filter)","comments: ": ""},"func85": {"source file: ": "test_common1.py","line number: ": "1808","func name: ": "test_raise_on_no_columns","func arg: ": "(all_parsers, nrows)","comments: ": ""},"func86": {"source file: ": "test_common1.py","line number: ": "1817","func name: ": "test_memory_map","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func87": {"source file: ": "test_common1.py","line number: ": "1829","func name: ": "test_null_byte_char","func arg: ": "(all_parsers)","comments: ": ""},"func88": {"source file: ": "test_common1.py","line number: ": "1845","func name: ": "test_temporary_file","func arg: ": "(all_parsers)","comments: ": ""},"func89": {"source file: ": "test_common1.py","line number: ": "1862","func name: ": "test_internal_eof_byte","func arg: ": "(all_parsers)","comments: ": ""},"func90": {"source file: ": "test_common1.py","line number: ": "1872","func name: ": "test_internal_eof_byte_to_file","func arg: ": "(all_parsers)","comments: ": ""},"func91": {"source file: ": "test_common1.py","line number: ": "1887","func name: ": "test_sub_character","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func92": {"source file: ": "test_common1.py","line number: ": "1897","func name: ": "test_file_handle_string_io","func arg: ": "(all_parsers)","comments: ": ""},"func93": {"source file: ": "test_common1.py","line number: ": "1909","func name: ": "test_file_handles_with_open","func arg: ": "(all_parsers, csv1)","comments: ": ""},"func94": {"source file: ": "test_common1.py","line number: ": "1921","func name: ": "test_invalid_file_buffer_class","func arg: ": "(all_parsers)","comments: ": ""},"func95": {"source file: ": "test_common1.py","line number: ": "1933","func name: ": "test_invalid_file_buffer_mock","func arg: ": "(all_parsers)","comments: ": ""},"func96": {"source file: ": "test_common1.py","line number: ": "1945","func name: ": "test_valid_file_buffer_seems_invalid","func arg: ": "(all_parsers)","comments: ": ""},"func97": {"source file: ": "test_common1.py","line number: ": "1974","func name: ": "test_error_bad_lines","func arg: ": "(all_parsers, kwargs, warn_kwargs)","comments: ": ""},"func98": {"source file: ": "test_common1.py","line number: ": "1985","func name: ": "test_warn_bad_lines","func arg: ": "(all_parsers, capsys)","comments: ": ""},"func99": {"source file: ": "test_common1.py","line number: ": "1999","func name: ": "test_suppress_error_output","func arg: ": "(all_parsers, capsys)","comments: ": ""},"func100": {"source file: ": "test_common1.py","line number: ": "2015","func name: ": "test_filename_with_special_chars","func arg: ": "(all_parsers, filename)","comments: ": ""},"func101": {"source file: ": "test_common1.py","line number: ": "2027","func name: ": "test_read_csv_memory_growth_chunksize","func arg: ": "(all_parsers)","comments: ": ""},"func102": {"source file: ": "test_common1.py","line number: ": "2045","func name: ": "test_read_table_equivalency_to_read_csv","func arg: ": "(all_parsers)","comments: ": ""},"func103": {"source file: ": "test_common1.py","line number: ": "2055","func name: ": "test_first_row_bom","func arg: ": "(all_parsers)","comments: ": ""},"func104": {"source file: ": "test_common1.py","line number: ": "2065","func name: ": "test_integer_precision","func arg: ": "(all_parsers)","comments: ": ""}}{"func1": {"source file: ": "test_common2.py","line number: ": "56","func name: ": "test_astype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_common2.py","line number: ": "68","func name: ": "test_astype_no_copy","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_common2.py","line number: ": "79","func name: ": "test_is_extension_array_dtype","func arg: ": "(dtype)","comments: ": ""}}{"func1": {"source file: ": "test_common3.py","line number: ": "302","func name: ": "mmap_file","func arg: ": "(datapath)","comments: ": ""}}{"func1": {"source file: ": "test_common4.py","line number: ": "34","func name: ": "to_ea_dtypes","func arg: ": "(dtypes)","comments: ": "convert list of string dtypes to EA dtype\n\n\n"},"func2": {"source file: ": "test_common4.py","line number: ": "39","func name: ": "to_numpy_dtypes","func arg: ": "(dtypes)","comments: ": "convert list of string dtypes to numpy dtype\n\n\n"},"func3": {"source file: ": "test_common4.py","line number: ": "126","func name: ": "test_dtype_equal","func arg: ": "(name1, dtype1, name2, dtype2)","comments: ": ""},"func4": {"source file: ": "test_common4.py","line number: ": "149","func name: ": "test_dtype_equal_strict","func arg: ": "(dtype1, dtype2)","comments: ": ""},"func5": {"source file: ": "test_common4.py","line number: ": "153","func name: ": "get_is_dtype_funcs","func arg: ": "()","comments: ": "Get all functions in pandas.core.dtypes.common that begin with 'is_' and end with 'dtype'\n\n\n"},"func6": {"source file: ": "test_common4.py","line number: ": "165","func name: ": "test_get_dtype_error_catch","func arg: ": "(func)","comments: ": ""},"func7": {"source file: ": "test_common4.py","line number: ": "173","func name: ": "test_is_object","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_common4.py","line number: ": "185","func name: ": "test_is_sparse","func arg: ": "(check_scipy)","comments: ": ""},"func9": {"source file: ": "test_common4.py","line number: ": "197","func name: ": "test_is_scipy_sparse","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_common4.py","line number: ": "205","func name: ": "test_is_categorical","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_common4.py","line number: ": "214","func name: ": "test_is_datetime64_dtype","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_common4.py","line number: ": "223","func name: ": "test_is_datetime64tz_dtype","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_common4.py","line number: ": "230","func name: ": "test_is_timedelta64_dtype","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_common4.py","line number: ": "245","func name: ": "test_is_period_dtype","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_common4.py","line number: ": "254","func name: ": "test_is_interval_dtype","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_common4.py","line number: ": "265","func name: ": "test_is_categorical_dtype","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_common4.py","line number: ": "274","func name: ": "test_is_string_dtype","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_common4.py","line number: ": "285","func name: ": "test_is_period_arraylike","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_common4.py","line number: ": "291","func name: ": "test_is_datetime_arraylike","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_common4.py","line number: ": "309","func name: ": "test_is_integer_dtype","func arg: ": "(dtype)","comments: ": ""},"func21": {"source file: ": "test_common4.py","line number: ": "325","func name: ": "test_is_not_integer_dtype","func arg: ": "(dtype)","comments: ": ""},"func22": {"source file: ": "test_common4.py","line number: ": "341","func name: ": "test_is_signed_integer_dtype","func arg: ": "(dtype)","comments: ": ""},"func23": {"source file: ": "test_common4.py","line number: ": "361","func name: ": "test_is_not_signed_integer_dtype","func arg: ": "(dtype)","comments: ": ""},"func24": {"source file: ": "test_common4.py","line number: ": "377","func name: ": "test_is_unsigned_integer_dtype","func arg: ": "(dtype)","comments: ": ""},"func25": {"source file: ": "test_common4.py","line number: ": "397","func name: ": "test_is_not_unsigned_integer_dtype","func arg: ": "(dtype)","comments: ": ""},"func26": {"source file: ": "test_common4.py","line number: ": "404","func name: ": "test_is_int64_dtype","func arg: ": "(dtype)","comments: ": ""},"func27": {"source file: ": "test_common4.py","line number: ": "423","func name: ": "test_is_not_int64_dtype","func arg: ": "(dtype)","comments: ": ""},"func28": {"source file: ": "test_common4.py","line number: ": "427","func name: ": "test_is_datetime64_any_dtype","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_common4.py","line number: ": "441","func name: ": "test_is_datetime64_ns_dtype","func arg: ": "()","comments: ": ""},"func30": {"source file: ": "test_common4.py","line number: ": "458","func name: ": "test_is_timedelta64_ns_dtype","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_common4.py","line number: ": "466","func name: ": "test_is_datetime_or_timedelta_dtype","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_common4.py","line number: ": "481","func name: ": "test_is_numeric_v_string_like","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_common4.py","line number: ": "494","func name: ": "test_is_datetimelike_v_numeric","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_common4.py","line number: ": "509","func name: ": "test_needs_i8_conversion","func arg: ": "()","comments: ": ""},"func35": {"source file: ": "test_common4.py","line number: ": "520","func name: ": "test_is_numeric_dtype","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_common4.py","line number: ": "534","func name: ": "test_is_string_like_dtype","func arg: ": "()","comments: ": ""},"func37": {"source file: ": "test_common4.py","line number: ": "542","func name: ": "test_is_float_dtype","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_common4.py","line number: ": "552","func name: ": "test_is_bool_dtype","func arg: ": "()","comments: ": ""},"func39": {"source file: ": "test_common4.py","line number: ": "572","func name: ": "test_is_extension_type","func arg: ": "(check_scipy)","comments: ": ""},"func40": {"source file: ": "test_common4.py","line number: ": "593","func name: ": "test_is_extension_type_deprecation","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_common4.py","line number: ": "601","func name: ": "test_is_extension_array_dtype","func arg: ": "(check_scipy)","comments: ": ""},"func42": {"source file: ": "test_common4.py","line number: ": "622","func name: ": "test_is_complex_dtype","func arg: ": "()","comments: ": ""},"func43": {"source file: ": "test_common4.py","line number: ": "661","func name: ": "test__get_dtype","func arg: ": "(input_param, result)","comments: ": ""},"func44": {"source file: ": "test_common4.py","line number: ": "676","func name: ": "test__get_dtype_fails","func arg: ": "(input_param, expected_error_message)","comments: ": ""},"func45": {"source file: ": "test_common4.py","line number: ": "717","func name: ": "test__is_dtype_type","func arg: ": "(input_param, result)","comments: ": ""},"func46": {"source file: ": "test_common4.py","line number: ": "723","func name: ": "test_astype_nansafe","func arg: ": "(val, typ)","comments: ": ""},"func47": {"source file: ": "test_common4.py","line number: ": "745","func name: ": "test_astype_datetime64_bad_dtype_raises","func arg: ": "(from_type, to_type)","comments: ": ""},"func48": {"source file: ": "test_common4.py","line number: ": "753","func name: ": "test_astype_object_preserves_datetime_na","func arg: ": "(from_type)","comments: ": ""}}{}{"func1": {"source file: ": "test_common6.py","line number: ": "15","func name: ": "test_get_callable_name","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_common6.py","line number: ": "37","func name: ": "test_any_none","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_common6.py","line number: ": "42","func name: ": "test_all_not_none","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_common6.py","line number: ": "48","func name: ": "test_random_state","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_common6.py","line number: ": "81","func name: ": "test_maybe_match_name","func arg: ": "(left, right, expected)","comments: ": ""},"func6": {"source file: ": "test_common6.py","line number: ": "85","func name: ": "test_dict_compat","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_common6.py","line number: ": "94","func name: ": "test_standardize_mapping","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_common6.py","line number: ": "117","func name: ": "test_git_version","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_common6.py","line number: ": "124","func name: ": "test_version_tag","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_comparisons1.py","line number: ": "165","func name: ": "test_rich_comparison_with_unsupported_type","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_compat1.py","line number: ": "11","func name: ": "pytables_hdf5_file","func arg: ": "()","comments: ": "Use PyTables to create a simple HDF5 file.\n\n\n"}}{"func1": {"source file: ": "test_compat2.py","line number: ": "8","func name: ": "test_numeric_compat","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_compat2.py","line number: ": "31","func name: ": "test_logical_compat","func arg: ": "(idx, method)","comments: ": ""},"func3": {"source file: ": "test_compat2.py","line number: ": "38","func name: ": "test_boolean_context_compat","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_compat2.py","line number: ": "44","func name: ": "test_boolean_context_compat2","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_compat2.py","line number: ": "56","func name: ": "test_inplace_mutation_resets_values","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_compat2.py","line number: ": "102","func name: ": "test_ndarray_compat_properties","func arg: ": "(idx, compat_props)","comments: ": ""},"func7": {"source file: ": "test_compat2.py","line number: ": "115","func name: ": "test_compat","func arg: ": "(indices)","comments: ": ""},"func8": {"source file: ": "test_compat2.py","line number: ": "119","func name: ": "test_pickle_compat_construction","func arg: ": "(holder)","comments: ": ""}}{"func1": {"source file: ": "test_compat3.py","line number: ": "12","func name: ": "test_compat","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_compat3.py","line number: ": "31","func name: ": "test_invalid_numexpr_version","func arg: ": "(engine, parser)","comments: ": ""}}{}{"func1": {"source file: ": "test_complex1.py","line number: ": "18","func name: ": "test_complex_fixed","func arg: ": "(setup_path)","comments: ": ""},"func2": {"source file: ": "test_complex1.py","line number: ": "41","func name: ": "test_complex_table","func arg: ": "(setup_path)","comments: ": ""},"func3": {"source file: ": "test_complex1.py","line number: ": "66","func name: ": "test_complex_mixed_fixed","func arg: ": "(setup_path)","comments: ": ""},"func4": {"source file: ": "test_complex1.py","line number: ": "89","func name: ": "test_complex_mixed_table","func arg: ": "(setup_path)","comments: ": ""},"func5": {"source file: ": "test_complex1.py","line number: ": "118","func name: ": "test_complex_across_dimensions_fixed","func arg: ": "(setup_path)","comments: ": ""},"func6": {"source file: ": "test_complex1.py","line number: ": "133","func name: ": "test_complex_across_dimensions","func arg: ": "(setup_path)","comments: ": ""},"func7": {"source file: ": "test_complex1.py","line number: ": "149","func name: ": "test_complex_indexing_error","func arg: ": "(setup_path)","comments: ": ""},"func8": {"source file: ": "test_complex1.py","line number: ": "162","func name: ": "test_complex_series_error","func arg: ": "(setup_path)","comments: ": ""},"func9": {"source file: ": "test_complex1.py","line number: ": "176","func name: ": "test_complex_append","func arg: ": "(setup_path)","comments: ": ""}}{"func1": {"source file: ": "test_compression1.py","line number: ": "16","func name: ": "buffer","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_compression1.py","line number: ": "21","func name: ": "parser_and_data","func arg: ": "(all_parsers, csv1)","comments: ": ""},"func3": {"source file: ": "test_compression1.py","line number: ": "32","func name: ": "test_zip","func arg: ": "(parser_and_data, compression)","comments: ": ""},"func4": {"source file: ": "test_compression1.py","line number: ": "49","func name: ": "test_zip_error_multiple_files","func arg: ": "(parser_and_data, compression)","comments: ": ""},"func5": {"source file: ": "test_compression1.py","line number: ": "63","func name: ": "test_zip_error_no_files","func arg: ": "(parser_and_data)","comments: ": ""},"func6": {"source file: ": "test_compression1.py","line number: ": "74","func name: ": "test_zip_error_invalid_zip","func arg: ": "(parser_and_data)","comments: ": ""},"func7": {"source file: ": "test_compression1.py","line number: ": "84","func name: ": "test_compression","func arg: ": "(parser_and_data, compression_only, buffer, filename)","comments: ": ""},"func8": {"source file: ": "test_compression1.py","line number: ": "108","func name: ": "test_infer_compression","func arg: ": "(all_parsers, csv1, buffer, ext)","comments: ": ""},"func9": {"source file: ": "test_compression1.py","line number: ": "126","func name: ": "test_compression_utf_encoding","func arg: ": "(all_parsers, csv_dir_path, utf_value, encoding_fmt)","comments: ": ""},"func10": {"source file: ": "test_compression1.py","line number: ": "144","func name: ": "test_invalid_compression","func arg: ": "(all_parsers, invalid_compression)","comments: ": ""}}{"func1": {"source file: ": "test_compression2.py","line number: ": "9","func name: ": "test_compression_roundtrip","func arg: ": "(compression)","comments: ": ""},"func2": {"source file: ": "test_compression2.py","line number: ": "26","func name: ": "test_read_zipped_json","func arg: ": "(datapath)","comments: ": ""},"func3": {"source file: ": "test_compression2.py","line number: ": "37","func name: ": "test_with_s3_url","func arg: ": "(compression, s3_resource)","comments: ": ""},"func4": {"source file: ": "test_compression2.py","line number: ": "51","func name: ": "test_lines_with_compression","func arg: ": "(compression)","comments: ": ""},"func5": {"source file: ": "test_compression2.py","line number: ": "60","func name: ": "test_chunksize_with_compression","func arg: ": "(compression)","comments: ": ""},"func6": {"source file: ": "test_compression2.py","line number: ": "71","func name: ": "test_write_unsupported_compression_type","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_compression2.py","line number: ": "79","func name: ": "test_read_unsupported_compression_type","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_compression2.py","line number: ": "88","func name: ": "test_to_json_compression","func arg: ": "(compression_only, read_infer, to_infer)","comments: ": ""}}{"func1": {"source file: ": "test_compression3.py","line number: ": "25","func name: ": "test_compression_size","func arg: ": "(obj, method, compression_only)","comments: ": ""},"func2": {"source file: ": "test_compression3.py","line number: ": "45","func name: ": "test_compression_size_fh","func arg: ": "(obj, method, compression_only)","comments: ": ""},"func3": {"source file: ": "test_compression3.py","line number: ": "71","func name: ": "test_dataframe_compression_defaults_to_infer","func arg: ": "(write_method, write_kwargs, read_method, compression_only)","comments: ": ""},"func4": {"source file: ": "test_compression3.py","line number: ": "91","func name: ": "test_series_compression_defaults_to_infer","func arg: ": "(write_method, write_kwargs, read_method, read_kwargs, compression_only)","comments: ": ""},"func5": {"source file: ": "test_compression3.py","line number: ": "103","func name: ": "test_compression_warning","func arg: ": "(compression_only)","comments: ": ""},"func6": {"source file: ": "test_compression3.py","line number: ": "117","func name: ": "test_with_missing_lzma","func arg: ": "()","comments: ": "Tests if import pandas works when lzma is not present.\n\n\n"},"func7": {"source file: ": "test_compression3.py","line number: ": "130","func name: ": "test_with_missing_lzma_runtime","func arg: ": "()","comments: ": "Tests if RuntimeError is hit when calling lzma without having the module available.\n\n\n"}}{"func1": {"source file: ": "test_concat1.py","line number: ": "43","func name: ": "test_get_dtype_kinds","func arg: ": "(index_or_series, to_concat, expected)","comments: ": ""},"func2": {"source file: ": "test_concat1.py","line number: ": "76","func name: ": "test_get_dtype_kinds_period","func arg: ": "(to_concat, expected)","comments: ": ""}}{"func1": {"source file: ": "test_concat2.py","line number: ": "37","func name: ": "sort","func arg: ": "(request)","comments: ": "Boolean sort keyword for concat and DataFrame.append.\n\n\n"},"func2": {"source file: ": "test_concat2.py","line number: ": "2555","func name: ": "test_concat_no_unnecessary_upcast","func arg: ": "(dt, pdt)","comments: ": ""},"func3": {"source file: ": "test_concat2.py","line number: ": "2570","func name: ": "test_concat_will_upcast","func arg: ": "(dt, pdt)","comments: ": ""},"func4": {"source file: ": "test_concat2.py","line number: ": "2582","func name: ": "test_concat_empty_and_non_empty_frame_regression","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_concat2.py","line number: ": "2591","func name: ": "test_concat_empty_and_non_empty_series_regression","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_concat2.py","line number: ": "2601","func name: ": "test_concat_sorts_columns","func arg: ": "(sort)","comments: ": ""},"func7": {"source file: ": "test_concat2.py","line number: ": "2621","func name: ": "test_concat_sorts_index","func arg: ": "(sort)","comments: ": ""},"func8": {"source file: ": "test_concat2.py","line number: ": "2638","func name: ": "test_concat_inner_sort","func arg: ": "(sort)","comments: ": ""},"func9": {"source file: ": "test_concat2.py","line number: ": "2654","func name: ": "test_concat_aligned_sort","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_concat2.py","line number: ": "2669","func name: ": "test_concat_aligned_sort_does_not_raise","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_concat2.py","line number: ": "2679","func name: ": "test_concat_series_name_npscalar_tuple","func arg: ": "(s1name, s2name)","comments: ": ""},"func12": {"source file: ": "test_concat2.py","line number: ": "2688","func name: ": "test_concat_categorical_tz","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_concat2.py","line number: ": "2704","func name: ": "test_concat_categorical_unchanged","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_concat2.py","line number: ": "2720","func name: ": "test_concat_datetimeindex_freq","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_concat2.py","line number: ": "2736","func name: ": "test_concat_empty_df_object_dtype","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_concat2.py","line number: ": "2745","func name: ": "test_concat_sparse","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_console1.py","line number: ": "32","func name: ": "test_detect_console_encoding_from_stdout_stdin","func arg: ": "(monkeypatch, empty, filled)","comments: ": ""},"func2": {"source file: ": "test_console1.py","line number: ": "43","func name: ": "test_detect_console_encoding_fallback_to_locale","func arg: ": "(monkeypatch, encoding)","comments: ": ""},"func3": {"source file: ": "test_console1.py","line number: ": "62","func name: ": "test_detect_console_encoding_fallback_to_default","func arg: ": "(monkeypatch, std, locale)","comments: ": ""}}{"func1": {"source file: ": "test_construct_from_scalar1.py","line number: ": "8","func name: ": "test_cast_1d_array_like_from_scalar_categorical","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_construct_ndarray1.py","line number: ": "19","func name: ": "test_construct_1d_ndarray_preserving_na","func arg: ": "(values, dtype, expected)","comments: ": ""}}{"func1": {"source file: ": "test_construct_object_arr1.py","line number: ": "8","func name: ": "test_cast_1d_array","func arg: ": "(datum1, datum2)","comments: ": ""},"func2": {"source file: ": "test_construct_object_arr1.py","line number: ": "18","func name: ": "test_cast_1d_array_invalid_scalar","func arg: ": "(val)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_constructors3.py","line number: ": "9","func name: ": "test_construction","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_constructors3.py","line number: ": "145","func name: ": "test_td_construction_with_np_dtypes","func arg: ": "(npdtype, item)","comments: ": ""},"func3": {"source file: ": "test_constructors3.py","line number: ": "168","func name: ": "test_td_from_repr_roundtrip","func arg: ": "(val)","comments: ": ""},"func4": {"source file: ": "test_constructors3.py","line number: ": "179","func name: ": "test_overflow_on_construction","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_constructors3.py","line number: ": "226","func name: ": "test_iso_constructor","func arg: ": "(fmt, exp)","comments: ": ""},"func6": {"source file: ": "test_constructors3.py","line number: ": "241","func name: ": "test_iso_constructor_raises","func arg: ": "(fmt)","comments: ": ""},"func7": {"source file: ": "test_constructors3.py","line number: ": "269","func name: ": "test_td_constructor_on_nanoseconds","func arg: ": "(constructed_td, conversion)","comments: ": ""},"func8": {"source file: ": "test_constructors3.py","line number: ": "274","func name: ": "test_td_constructor_value_error","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_constructors4.py","line number: ": "13","func name: ": "test_constructor_single_level","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_constructors4.py","line number: ": "23","func name: ": "test_constructor_no_levels","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_constructors4.py","line number: ": "35","func name: ": "test_constructor_nonhashable_names","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_constructors4.py","line number: ": "59","func name: ": "test_constructor_mismatched_codes_levels","func arg: ": "(idx)","comments: ": ""},"func5": {"source file: ": "test_constructors4.py","line number: ": "97","func name: ": "test_na_levels","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_constructors4.py","line number: ": "129","func name: ": "test_copy_in_constructor","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_constructors4.py","line number: ": "145","func name: ": "test_from_arrays","func arg: ": "(idx)","comments: ": ""},"func8": {"source file: ": "test_constructors4.py","line number: ": "161","func name: ": "test_from_arrays_iterator","func arg: ": "(idx)","comments: ": ""},"func9": {"source file: ": "test_constructors4.py","line number: ": "178","func name: ": "test_from_arrays_tuples","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_constructors4.py","line number: ": "189","func name: ": "test_from_arrays_index_series_datetimetz","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_constructors4.py","line number: ": "203","func name: ": "test_from_arrays_index_series_timedelta","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_constructors4.py","line number: ": "217","func name: ": "test_from_arrays_index_series_period","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_constructors4.py","line number: ": "231","func name: ": "test_from_arrays_index_datetimelike_mixed","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_constructors4.py","line number: ": "254","func name: ": "test_from_arrays_index_series_categorical","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_constructors4.py","line number: ": "272","func name: ": "test_from_arrays_empty","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_constructors4.py","line number: ": "322","func name: ": "test_from_arrays_invalid_input","func arg: ": "(invalid_sequence_of_arrays)","comments: ": ""},"func17": {"source file: ": "test_constructors4.py","line number: ": "331","func name: ": "test_from_arrays_different_lengths","func arg: ": "(idx1, idx2)","comments: ": ""},"func18": {"source file: ": "test_constructors4.py","line number: ": "338","func name: ": "test_from_arrays_respects_none_names","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_constructors4.py","line number: ": "354","func name: ": "test_from_tuples","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_constructors4.py","line number: ": "368","func name: ": "test_from_tuples_iterator","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_constructors4.py","line number: ": "384","func name: ": "test_from_tuples_empty","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_constructors4.py","line number: ": "391","func name: ": "test_from_tuples_index_values","func arg: ": "(idx)","comments: ": ""},"func23": {"source file: ": "test_constructors4.py","line number: ": "396","func name: ": "test_tuples_with_name_string","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_constructors4.py","line number: ": "407","func name: ": "test_from_tuples_with_tuple_label","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_constructors4.py","line number: ": "420","func name: ": "test_from_product_empty_zero_levels","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_constructors4.py","line number: ": "427","func name: ": "test_from_product_empty_one_level","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_constructors4.py","line number: ": "437","func name: ": "test_from_product_empty_two_levels","func arg: ": "(first, second)","comments: ": ""},"func28": {"source file: ": "test_constructors4.py","line number: ": "445","func name: ": "test_from_product_empty_three_levels","func arg: ": "(N)","comments: ": ""},"func29": {"source file: ": "test_constructors4.py","line number: ": "457","func name: ": "test_from_product_invalid_input","func arg: ": "(invalid_input)","comments: ": ""},"func30": {"source file: ": "test_constructors4.py","line number: ": "463","func name: ": "test_from_product_datetimeindex","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_constructors4.py","line number: ": "479","func name: ": "test_from_product_index_series_categorical","func arg: ": "(ordered, f)","comments: ": ""},"func32": {"source file: ": "test_constructors4.py","line number: ": "492","func name: ": "test_from_product","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_constructors4.py","line number: ": "515","func name: ": "test_from_product_iterator","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_constructors4.py","line number: ": "555","func name: ": "test_from_product_infer_names","func arg: ": "(a, b, expected_names)","comments: ": ""},"func35": {"source file: ": "test_constructors4.py","line number: ": "566","func name: ": "test_from_product_respects_none_names","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_constructors4.py","line number: ": "580","func name: ": "test_from_product_readonly","func arg: ": "()","comments: ": ""},"func37": {"source file: ": "test_constructors4.py","line number: ": "591","func name: ": "test_create_index_existing_name","func arg: ": "(idx)","comments: ": ""},"func38": {"source file: ": "test_constructors4.py","line number: ": "634","func name: ": "test_from_frame","func arg: ": "()","comments: ": ""},"func39": {"source file: ": "test_constructors4.py","line number: ": "657","func name: ": "test_from_frame_error","func arg: ": "(non_frame)","comments: ": ""},"func40": {"source file: ": "test_constructors4.py","line number: ": "663","func name: ": "test_from_frame_dtype_fidelity","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_constructors4.py","line number: ": "694","func name: ": "test_from_frame_valid_names","func arg: ": "(names_in, names_out)","comments: ": ""},"func42": {"source file: ": "test_constructors4.py","line number: ": "711","func name: ": "test_from_frame_invalid_names","func arg: ": "(names, expected_error_msg)","comments: ": ""},"func43": {"source file: ": "test_constructors4.py","line number: ": "721","func name: ": "test_index_equal_empty_iterable","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_constructors6.py","line number: ": "28","func name: ": "name","func arg: ": "(request)","comments: ": ""}}{}{}{}{}{}{}{"func1": {"source file: ": "test_contains1.py","line number: ": "11","func name: ": "test_contains_top_level","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_contains1.py","line number: ": "17","func name: ": "test_contains_with_nat","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_contains1.py","line number: ": "29","func name: ": "test_contains","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_contains1.py","line number: ": "36","func name: ": "test_isin_nan_pypy","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_contains1.py","line number: ": "44","func name: ": "test_isin","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_contains1.py","line number: ": "60","func name: ": "test_isin_nan_not_pypy","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_contains1.py","line number: ": "68","func name: ": "test_isin_level_kwarg","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_contains1.py","line number: ": "103","func name: ": "test_contains_with_missing_value","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_contains1.py","line number: ": "121","func name: ": "test_isin_multi_index_with_missing_value","func arg: ": "(labels, expected, level)","comments: ": ""}}{"func1": {"source file: ": "test_conversion1.py","line number: ": "214","func name: ": "test_values_consistent","func arg: ": "(array, expected_type, dtype)","comments: ": ""},"func2": {"source file: ": "test_conversion1.py","line number: ": "244","func name: ": "test_ndarray_values","func arg: ": "(array, expected)","comments: ": ""},"func3": {"source file: ": "test_conversion1.py","line number: ": "252","func name: ": "test_numpy_array","func arg: ": "(arr)","comments: ": ""},"func4": {"source file: ": "test_conversion1.py","line number: ": "259","func name: ": "test_numpy_array_all_dtypes","func arg: ": "(any_numpy_dtype)","comments: ": ""},"func5": {"source file: ": "test_conversion1.py","line number: ": "291","func name: ": "test_array","func arg: ": "(array, attr, index_or_series)","comments: ": ""},"func6": {"source file: ": "test_conversion1.py","line number: ": "304","func name: ": "test_array_multiindex_raises","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_conversion1.py","line number: ": "355","func name: ": "test_to_numpy","func arg: ": "(array, expected, index_or_series)","comments: ": ""},"func8": {"source file: ": "test_conversion1.py","line number: ": "370","func name: ": "test_to_numpy_copy","func arg: ": "(arr, as_series)","comments: ": ""},"func9": {"source file: ": "test_conversion1.py","line number: ": "388","func name: ": "test_to_numpy_dtype","func arg: ": "(as_series)","comments: ": ""},"func10": {"source file: ": "test_conversion1.py","line number: ": "422","func name: ": "test_to_numpy_na_value_numpy_dtype","func arg: ": "(container, values, dtype, na_value, expected)","comments: ": ""},"func11": {"source file: ": "test_conversion1.py","line number: ": "429","func name: ": "test_to_numpy_kwargs_raises","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_conversion2.py","line number: ": "14","func name: ": "_compare_utc_to_local","func arg: ": "(tz_didx)","comments: ": ""},"func2": {"source file: ": "test_conversion2.py","line number: ": "24","func name: ": "_compare_local_to_utc","func arg: ": "(tz_didx, utc_didx)","comments: ": ""},"func3": {"source file: ": "test_conversion2.py","line number: ": "34","func name: ": "test_tz_convert_single_matches_tz_convert_hourly","func arg: ": "(tz_aware_fixture)","comments: ": ""},"func4": {"source file: ": "test_conversion2.py","line number: ": "44","func name: ": "test_tz_convert_single_matches_tz_convert","func arg: ": "(tz_aware_fixture, freq)","comments: ": ""},"func5": {"source file: ": "test_conversion2.py","line number: ": "60","func name: ": "test_tz_convert_corner","func arg: ": "(arr)","comments: ": ""},"func6": {"source file: ": "test_conversion2.py","line number: ": "69","func name: ": "test_length_zero_copy","func arg: ": "(dtype, copy)","comments: ": ""},"func7": {"source file: ": "test_conversion2.py","line number: ": "95","func name: ": "test_localize_pydatetime_dt_types","func arg: ": "(dt, expected)","comments: ": ""}}{"func1": {"source file: ": "test_conversion3.py","line number: ": "9","func name: ": "test_tolist","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_conversion3.py","line number: ": "15","func name: ": "test_to_numpy","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_conversion3.py","line number: ": "21","func name: ": "test_to_frame","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_conversion3.py","line number: ": "94","func name: ": "test_to_frame_dtype_fidelity","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_conversion3.py","line number: ": "122","func name: ": "test_to_frame_resulting_column_order","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_conversion3.py","line number: ": "132","func name: ": "test_roundtrip_pickle_with_tz","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_conversion3.py","line number: ": "145","func name: ": "test_pickle","func arg: ": "(indices)","comments: ": ""},"func8": {"source file: ": "test_conversion3.py","line number: ": "156","func name: ": "test_to_series","func arg: ": "(idx)","comments: ": ""},"func9": {"source file: ": "test_conversion3.py","line number: ": "165","func name: ": "test_to_series_with_arguments","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_conversion3.py","line number: ": "184","func name: ": "test_to_flat_index","func arg: ": "(idx)","comments: ": ""}}{}{"func1": {"source file: ": "test_convert_objects1.py","line number: ": "8","func name: ": "test_maybe_convert_objects_copy","func arg: ": "(data)","comments: ": ""}}{"func1": {"source file: ": "test_converter1.py","line number: ": "32","func name: ": "test_registry_mpl_resets","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_converter1.py","line number: ": "47","func name: ": "test_timtetonum_accepts_unicode","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_converters1.py","line number: ": "16","func name: ": "test_converters_type_must_be_dict","func arg: ": "(all_parsers)","comments: ": ""},"func2": {"source file: ": "test_converters1.py","line number: ": "30","func name: ": "test_converters","func arg: ": "(all_parsers, column, converter)","comments: ": ""},"func3": {"source file: ": "test_converters1.py","line number: ": "45","func name: ": "test_converters_no_implicit_conv","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_converters1.py","line number: ": "58","func name: ": "test_converters_euro_decimal_format","func arg: ": "(all_parsers)","comments: ": ""},"func5": {"source file: ": "test_converters1.py","line number: ": "83","func name: ": "test_converters_corner_with_nans","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_converters1.py","line number: ": "150","func name: ": "test_converter_index_col_bug","func arg: ": "(all_parsers)","comments: ": ""}}{"func1": {"source file: ": "test_copy1.py","line number: ": "9","func name: ": "assert_multiindex_copied","func arg: ": "(copy, original)","comments: ": ""},"func2": {"source file: ": "test_copy1.py","line number: ": "26","func name: ": "test_copy","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_copy1.py","line number: ": "32","func name: ": "test_shallow_copy","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_copy1.py","line number: ": "38","func name: ": "test_view","func arg: ": "(idx)","comments: ": ""},"func5": {"source file: ": "test_copy1.py","line number: ": "44","func name: ": "test_copy_and_deepcopy","func arg: ": "(func)","comments: ": ""},"func6": {"source file: ": "test_copy1.py","line number: ": "57","func name: ": "test_copy_method","func arg: ": "(deep)","comments: ": ""},"func7": {"source file: ": "test_copy1.py","line number: ": "76","func name: ": "test_copy_method_kwargs","func arg: ": "(deep, kwarg, value)","comments: ": ""}}{}{}{}{}{}{"func1": {"source file: ": "test_css1.py","line number: ": "8","func name: ": "assert_resolves","func arg: ": "(css, props, inherited)","comments: ": ""},"func2": {"source file: ": "test_css1.py","line number: ": "14","func name: ": "assert_same_resolution","func arg: ": "(css1, css2, inherited)","comments: ": ""},"func3": {"source file: ": "test_css1.py","line number: ": "34","func name: ": "test_css_parse_normalisation","func arg: ": "(name, norm, abnorm)","comments: ": ""},"func4": {"source file: ": "test_css1.py","line number: ": "59","func name: ": "test_css_parse_invalid","func arg: ": "(invalid_css, remainder)","comments: ": ""},"func5": {"source file: ": "test_css1.py","line number: ": "100","func name: ": "test_css_side_shorthands","func arg: ": "(shorthand, expansions)","comments: ": ""},"func6": {"source file: ": "test_css1.py","line number: ": "146","func name: ": "test_css_precedence","func arg: ": "(style, inherited, equiv)","comments: ": ""},"func7": {"source file: ": "test_css1.py","line number: ": "165","func name: ": "test_css_none_absent","func arg: ": "(style, equiv)","comments: ": ""},"func8": {"source file: ": "test_css1.py","line number: ": "189","func name: ": "test_css_absolute_font_size","func arg: ": "(size, relative_to, resolved)","comments: ": ""},"func9": {"source file: ": "test_css1.py","line number: ": "225","func name: ": "test_css_relative_font_size","func arg: ": "(size, relative_to, resolved)","comments: ": ""}}{"func1": {"source file: ": "test_cumulativ1.py","line number: ": "18","func name: ": "_check_accum_op","func arg: ": "(name, series, check_dtype)","comments: ": ""}}{}{"func1": {"source file: ": "test_cut1.py","line number: ": "27","func name: ": "test_simple","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_cut1.py","line number: ": "35","func name: ": "test_bins","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_cut1.py","line number: ": "47","func name: ": "test_right","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_cut1.py","line number: ": "59","func name: ": "test_no_right","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_cut1.py","line number: ": "71","func name: ": "test_array_like","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_cut1.py","line number: ": "83","func name: ": "test_bins_from_interval_index","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_cut1.py","line number: ": "96","func name: ": "test_bins_from_interval_index_doc_example","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_cut1.py","line number: ": "108","func name: ": "test_bins_not_overlapping_from_interval_index","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_cut1.py","line number: ": "117","func name: ": "test_bins_not_monotonic","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_cut1.py","line number: ": "165","func name: ": "test_bins_monotonic_not_overflowing","func arg: ": "(x, bins, expected)","comments: ": ""},"func11": {"source file: ": "test_cut1.py","line number: ": "171","func name: ": "test_wrong_num_labels","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_cut1.py","line number: ": "186","func name: ": "test_cut_corner","func arg: ": "(x, bins, msg)","comments: ": ""},"func13": {"source file: ": "test_cut1.py","line number: ": "193","func name: ": "test_cut_not_1d_arg","func arg: ": "(arg, cut_func)","comments: ": ""},"func14": {"source file: ": "test_cut1.py","line number: ": "207","func name: ": "test_int_bins_with_inf","func arg: ": "(data)","comments: ": ""},"func15": {"source file: ": "test_cut1.py","line number: ": "214","func name: ": "test_cut_out_of_range_more","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_cut1.py","line number: ": "232","func name: ": "test_labels","func arg: ": "(right, breaks, closed)","comments: ": ""},"func17": {"source file: ": "test_cut1.py","line number: ": "240","func name: ": "test_cut_pass_series_name_to_factor","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_cut1.py","line number: ": "248","func name: ": "test_label_precision","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_cut1.py","line number: ": "257","func name: ": "test_na_handling","func arg: ": "(labels)","comments: ": ""},"func20": {"source file: ": "test_cut1.py","line number: ": "268","func name: ": "test_inf_handling","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_cut1.py","line number: ": "285","func name: ": "test_cut_out_of_bounds","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_cut1.py","line number: ": "311","func name: ": "test_cut_pass_labels","func arg: ": "(get_labels, get_expected)","comments: ": ""},"func23": {"source file: ": "test_cut1.py","line number: ": "320","func name: ": "test_cut_pass_labels_compat","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_cut1.py","line number: ": "331","func name: ": "test_round_frac_just_works","func arg: ": "(x)","comments: ": ""},"func25": {"source file: ": "test_cut1.py","line number: ": "345","func name: ": "test_round_frac","func arg: ": "(val, precision, expected)","comments: ": ""},"func26": {"source file: ": "test_cut1.py","line number: ": "351","func name: ": "test_cut_return_intervals","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_cut1.py","line number: ": "366","func name: ": "test_series_ret_bins","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_cut1.py","line number: ": "386","func name: ": "test_cut_duplicates_bin","func arg: ": "(kwargs, msg)","comments: ": ""},"func29": {"source file: ": "test_cut1.py","line number: ": "402","func name: ": "test_single_bin","func arg: ": "(data, length)","comments: ": ""},"func30": {"source file: ": "test_cut1.py","line number: ": "414","func name: ": "test_cut_read_only","func arg: ": "(array_1_writeable, array_2_writeable)","comments: ": ""},"func31": {"source file: ": "test_cut1.py","line number: ": "437","func name: ": "test_datetime_bin","func arg: ": "(conv)","comments: ": ""},"func32": {"source file: ": "test_cut1.py","line number: ": "474","func name: ": "test_datetime_cut","func arg: ": "(data)","comments: ": ""},"func33": {"source file: ": "test_cut1.py","line number: ": "511","func name: ": "test_datetime_tz_cut","func arg: ": "(bins, box)","comments: ": ""},"func34": {"source file: ": "test_cut1.py","line number: ": "541","func name: ": "test_datetime_nan_error","func arg: ": "()","comments: ": ""},"func35": {"source file: ": "test_cut1.py","line number: ": "548","func name: ": "test_datetime_nan_mask","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_cut1.py","line number: ": "561","func name: ": "test_datetime_cut_roundtrip","func arg: ": "(tz)","comments: ": ""},"func37": {"source file: ": "test_cut1.py","line number: ": "576","func name: ": "test_timedelta_cut_roundtrip","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_cut1.py","line number: ": "599","func name: ": "test_cut_bool_coercion_to_int","func arg: ": "(bins, box, compare)","comments: ": ""},"func39": {"source file: ": "test_cut1.py","line number: ": "609","func name: ": "test_cut_incorrect_labels","func arg: ": "(labels)","comments: ": ""},"func40": {"source file: ": "test_cut1.py","line number: ": "620","func name: ": "test_cut_nullable_integer","func arg: ": "(bins, right, include_lowest)","comments: ": ""}}{"func1": {"source file: ": "test_cython1.py","line number: ": "34","func name: ": "test_cythonized_aggers","func arg: ": "(op_name)","comments: ": ""},"func2": {"source file: ": "test_cython1.py","line number: ": "67","func name: ": "test_cython_agg_boolean","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_cython1.py","line number: ": "80","func name: ": "test_cython_agg_nothing_to_agg","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_cython1.py","line number: ": "92","func name: ": "test_cython_agg_nothing_to_agg_with_dates","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_cython1.py","line number: ": "105","func name: ": "test_cython_agg_frame_columns","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_cython1.py","line number: ": "115","func name: ": "test_cython_agg_return_dict","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_cython1.py","line number: ": "135","func name: ": "test_cython_fail_agg","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_cython1.py","line number: ": "159","func name: ": "test__cython_agg_general","func arg: ": "(op, targop)","comments: ": ""},"func9": {"source file: ": "test_cython1.py","line number: ": "178","func name: ": "test_cython_agg_empty_buckets","func arg: ": "(op, targop, observed)","comments: ": ""},"func10": {"source file: ": "test_cython1.py","line number: ": "192","func name: ": "test_cython_agg_empty_buckets_nanops","func arg: ": "(observed)","comments: ": ""},"func11": {"source file: ": "test_cython1.py","line number: ": "229","func name: ": "test_cython_with_timestamp_and_nat","func arg: ": "(op, data)","comments: ": ""}}{"func1": {"source file: ": "test_date_converters1.py","line number: ": "10","func name: ": "test_parse_date_time","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_date_converters1.py","line number: ": "19","func name: ": "test_parse_date_fields","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_date_converters1.py","line number: ": "29","func name: ": "test_parse_all_fields","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_date_range1.py","line number: ": "950","func name: ": "test_date_range_with_custom_holidays","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_datetime_index1.py","line number: ": "24","func name: ": "_index_factory","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_datetime_index1.py","line number: ": "29","func name: ": "_index_freq","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_datetime_index1.py","line number: ": "34","func name: ": "_static_values","func arg: ": "(index)","comments: ": ""},"func4": {"source file: ": "test_datetime_index1.py","line number: ": "38","func name: ": "test_custom_grouper","func arg: ": "(index)","comments: ": ""},"func5": {"source file: ": "test_datetime_index1.py","line number: ": "103","func name: ": "test_resample_basic","func arg: ": "(series, closed, expected)","comments: ": ""},"func6": {"source file: ": "test_datetime_index1.py","line number: ": "110","func name: ": "test_resample_integerarray","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_datetime_index1.py","line number: ": "130","func name: ": "test_resample_basic_grouper","func arg: ": "(series)","comments: ": ""},"func8": {"source file: ": "test_datetime_index1.py","line number: ": "146","func name: ": "test_resample_string_kwargs","func arg: ": "(series, keyword, value)","comments: ": ""},"func9": {"source file: ": "test_datetime_index1.py","line number: ": "158","func name: ": "test_resample_how","func arg: ": "(series, downsample_method)","comments: ": ""},"func10": {"source file: ": "test_datetime_index1.py","line number: ": "181","func name: ": "test_resample_how_ohlc","func arg: ": "(series)","comments: ": ""},"func11": {"source file: ": "test_datetime_index1.py","line number: ": "205","func name: ": "test_numpy_compat","func arg: ": "(func)","comments: ": ""},"func12": {"source file: ": "test_datetime_index1.py","line number: ": "218","func name: ": "test_resample_how_callables","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_datetime_index1.py","line number: ": "243","func name: ": "test_resample_rounding","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_datetime_index1.py","line number: ": "305","func name: ": "test_resample_basic_from_daily","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_datetime_index1.py","line number: ": "363","func name: ": "test_resample_upsampling_picked_but_not_correct","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_datetime_index1.py","line number: ": "392","func name: ": "test_resample_frame_basic","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_datetime_index1.py","line number: ": "416","func name: ": "test_resample_loffset","func arg: ": "(loffset)","comments: ": ""},"func18": {"source file: ": "test_datetime_index1.py","line number: ": "441","func name: ": "test_resample_loffset_upsample","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_datetime_index1.py","line number: ": "455","func name: ": "test_resample_loffset_count","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_datetime_index1.py","line number: ": "477","func name: ": "test_resample_upsample","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_datetime_index1.py","line number: ": "494","func name: ": "test_resample_how_method","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_datetime_index1.py","line number: ": "518","func name: ": "test_resample_extra_index_point","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_datetime_index1.py","line number: ": "529","func name: ": "test_upsample_with_limit","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_datetime_index1.py","line number: ": "538","func name: ": "test_nearest_upsample_with_limit","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_datetime_index1.py","line number: ": "547","func name: ": "test_resample_ohlc","func arg: ": "(series)","comments: ": ""},"func26": {"source file: ": "test_datetime_index1.py","line number: ": "570","func name: ": "test_resample_ohlc_result","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_datetime_index1.py","line number: ": "600","func name: ": "test_resample_ohlc_dataframe","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_datetime_index1.py","line number: ": "645","func name: ": "test_resample_dup_index","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_datetime_index1.py","line number: ": "661","func name: ": "test_resample_reresample","func arg: ": "()","comments: ": ""},"func30": {"source file: ": "test_datetime_index1.py","line number: ": "671","func name: ": "test_resample_timestamp_to_period","func arg: ": "(simple_date_range_series)","comments: ": ""},"func31": {"source file: ": "test_datetime_index1.py","line number: ": "695","func name: ": "test_ohlc_5min","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_datetime_index1.py","line number: ": "715","func name: ": "test_downsample_non_unique","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_datetime_index1.py","line number: ": "728","func name: ": "test_asfreq_non_unique","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_datetime_index1.py","line number: ": "739","func name: ": "test_resample_axis1","func arg: ": "()","comments: ": ""},"func35": {"source file: ": "test_datetime_index1.py","line number: ": "748","func name: ": "test_resample_anchored_ticks","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_datetime_index1.py","line number: ": "765","func name: ": "test_resample_single_group","func arg: ": "()","comments: ": ""},"func37": {"source file: ": "test_datetime_index1.py","line number: ": "786","func name: ": "test_resample_base","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_datetime_index1.py","line number: ": "795","func name: ": "test_resample_float_base","func arg: ": "()","comments: ": ""},"func39": {"source file: ": "test_datetime_index1.py","line number: ": "808","func name: ": "test_resample_daily_anchored","func arg: ": "()","comments: ": ""},"func40": {"source file: ": "test_datetime_index1.py","line number: ": "818","func name: ": "test_resample_to_period_monthly_buglet","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_datetime_index1.py","line number: ": "829","func name: ": "test_period_with_agg","func arg: ": "()","comments: ": ""},"func42": {"source file: ": "test_datetime_index1.py","line number: ": "843","func name: ": "test_resample_segfault","func arg: ": "()","comments: ": ""},"func43": {"source file: ": "test_datetime_index1.py","line number: ": "861","func name: ": "test_resample_dtype_preservation","func arg: ": "()","comments: ": ""},"func44": {"source file: ": "test_datetime_index1.py","line number: ": "881","func name: ": "test_resample_dtype_coercion","func arg: ": "()","comments: ": ""},"func45": {"source file: ": "test_datetime_index1.py","line number: ": "898","func name: ": "test_weekly_resample_buglet","func arg: ": "()","comments: ": ""},"func46": {"source file: ": "test_datetime_index1.py","line number: ": "908","func name: ": "test_monthly_resample_error","func arg: ": "()","comments: ": ""},"func47": {"source file: ": "test_datetime_index1.py","line number: ": "916","func name: ": "test_nanosecond_resample_error","func arg: ": "()","comments: ": ""},"func48": {"source file: ": "test_datetime_index1.py","line number: ": "932","func name: ": "test_resample_anchored_intraday","func arg: ": "(simple_date_range_series)","comments: ": ""},"func49": {"source file: ": "test_datetime_index1.py","line number: ": "969","func name: ": "test_resample_anchored_monthstart","func arg: ": "(simple_date_range_series)","comments: ": ""},"func50": {"source file: ": "test_datetime_index1.py","line number: ": "978","func name: ": "test_resample_anchored_multiday","func arg: ": "()","comments: ": ""},"func51": {"source file: ": "test_datetime_index1.py","line number: ": "1000","func name: ": "test_corner_cases","func arg: ": "(simple_period_range_series, simple_date_range_series)","comments: ": ""},"func52": {"source file: ": "test_datetime_index1.py","line number: ": "1022","func name: ": "test_anchored_lowercase_buglet","func arg: ": "()","comments: ": ""},"func53": {"source file: ": "test_datetime_index1.py","line number: ": "1029","func name: ": "test_upsample_apply_functions","func arg: ": "()","comments: ": ""},"func54": {"source file: ": "test_datetime_index1.py","line number: ": "1039","func name: ": "test_resample_not_monotonic","func arg: ": "()","comments: ": ""},"func55": {"source file: ": "test_datetime_index1.py","line number: ": "1050","func name: ": "test_resample_median_bug_1688","func arg: ": "()","comments: ": ""},"func56": {"source file: ": "test_datetime_index1.py","line number: ": "1068","func name: ": "test_how_lambda_functions","func arg: ": "(simple_date_range_series)","comments: ": ""},"func57": {"source file: ": "test_datetime_index1.py","line number: ": "1095","func name: ": "test_resample_unequal_times","func arg: ": "()","comments: ": ""},"func58": {"source file: ": "test_datetime_index1.py","line number: ": "1107","func name: ": "test_resample_consistency","func arg: ": "()","comments: ": ""},"func59": {"source file: ": "test_datetime_index1.py","line number: ": "1131","func name: ": "test_resample_timegrouper","func arg: ": "()","comments: ": ""},"func60": {"source file: ": "test_datetime_index1.py","line number: ": "1172","func name: ": "test_resample_nunique","func arg: ": "()","comments: ": ""},"func61": {"source file: ": "test_datetime_index1.py","line number: ": "1203","func name: ": "test_resample_nunique_preserves_column_level_names","func arg: ": "()","comments: ": ""},"func62": {"source file: ": "test_datetime_index1.py","line number: ": "1213","func name: ": "test_resample_nunique_with_date_gap","func arg: ": "()","comments: ": ""},"func63": {"source file: ": "test_datetime_index1.py","line number: ": "1231","func name: ": "test_resample_group_info","func arg: ": "(n, k)","comments: ": ""},"func64": {"source file: ": "test_datetime_index1.py","line number: ": "1258","func name: ": "test_resample_size","func arg: ": "()","comments: ": ""},"func65": {"source file: ": "test_datetime_index1.py","line number: ": "1273","func name: ": "test_resample_across_dst","func arg: ": "()","comments: ": ""},"func66": {"source file: ": "test_datetime_index1.py","line number: ": "1304","func name: ": "test_groupby_with_dst_time_change","func arg: ": "()","comments: ": ""},"func67": {"source file: ": "test_datetime_index1.py","line number: ": "1321","func name: ": "test_resample_dst_anchor","func arg: ": "()","comments: ": ""},"func68": {"source file: ": "test_datetime_index1.py","line number: ": "1402","func name: ": "test_downsample_across_dst","func arg: ": "()","comments: ": ""},"func69": {"source file: ": "test_datetime_index1.py","line number: ": "1415","func name: ": "test_downsample_across_dst_weekly","func arg: ": "()","comments: ": ""},"func70": {"source file: ": "test_datetime_index1.py","line number: ": "1441","func name: ": "test_resample_with_nat","func arg: ": "()","comments: ": ""},"func71": {"source file: ": "test_datetime_index1.py","line number: ": "1471","func name: ": "test_resample_datetime_values","func arg: ": "()","comments: ": ""},"func72": {"source file: ": "test_datetime_index1.py","line number: ": "1491","func name: ": "test_resample_apply_with_additional_args","func arg: ": "(series)","comments: ": ""},"func73": {"source file: ": "test_datetime_index1.py","line number: ": "1529","func name: ": "test_resample_equivalent_offsets","func arg: ": "(n1, freq1, n2, freq2, k)","comments: ": ""},"func74": {"source file: ": "test_datetime_index1.py","line number: ": "1554","func name: ": "test_get_timestamp_range_edges","func arg: ": "(first, last, offset, exp_first, exp_last)","comments: ": ""},"func75": {"source file: ": "test_datetime_index1.py","line number: ": "1569","func name: ": "test_resample_apply_product","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_datetime1.py","line number: ": "8","func name: ": "test_multiindex_period_datetime","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_datetime2.py","line number: ": "19","func name: ": "test_fancy_getitem","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_datetime2.py","line number: ": "38","func name: ": "test_fancy_setitem","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_datetime2.py","line number: ": "55","func name: ": "test_dti_snap","func arg: ": "(name, tz)","comments: ": ""},"func4": {"source file: ": "test_datetime2.py","line number: ": "85","func name: ": "test_dti_reset_index_round_trip","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_datetime2.py","line number: ": "102","func name: ": "test_series_set_value","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_datetime2.py","line number: ": "122","func name: ": "test_slice_locs_indexerror","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_datetime2.py","line number: ": "128","func name: ": "test_slicing_datetimes","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_datetime2.py","line number: ": "169","func name: ": "test_frame_datetime64_duplicated","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_datetime2.py","line number: ": "181","func name: ": "test_getitem_setitem_datetime_tz_pytz","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_datetime2.py","line number: ": "216","func name: ": "test_getitem_setitem_datetime_tz_dateutil","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_datetime2.py","line number: ": "255","func name: ": "test_getitem_setitem_datetimeindex","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_datetime2.py","line number: ": "349","func name: ": "test_getitem_setitem_periodindex","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_datetime2.py","line number: ": "397","func name: ": "test_getitem_median_slice_bug","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_datetime2.py","line number: ": "407","func name: ": "test_datetime_indexing","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_datetime2.py","line number: ": "437","func name: ": "dups","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_datetime2.py","line number: ": "454","func name: ": "test_constructor","func arg: ": "(dups)","comments: ": ""},"func17": {"source file: ": "test_datetime2.py","line number: ": "459","func name: ": "test_is_unique_monotonic","func arg: ": "(dups)","comments: ": ""},"func18": {"source file: ": "test_datetime2.py","line number: ": "463","func name: ": "test_index_unique","func arg: ": "(dups)","comments: ": ""},"func19": {"source file: ": "test_datetime2.py","line number: ": "505","func name: ": "test_index_dupes_contains","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_datetime2.py","line number: ": "511","func name: ": "test_duplicate_dates_indexing","func arg: ": "(dups)","comments: ": ""},"func21": {"source file: ": "test_datetime2.py","line number: ": "539","func name: ": "test_range_slice","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_datetime2.py","line number: ": "553","func name: ": "test_groupby_average_dup_values","func arg: ": "(dups)","comments: ": ""},"func23": {"source file: ": "test_datetime2.py","line number: ": "559","func name: ": "test_indexing_over_size_cutoff","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_datetime2.py","line number: ": "601","func name: ": "test_indexing_over_size_cutoff_period_index","func arg: ": "(monkeypatch)","comments: ": ""},"func25": {"source file: ": "test_datetime2.py","line number: ": "621","func name: ": "test_indexing_unordered","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_datetime2.py","line number: ": "666","func name: ": "test_indexing","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_datetime2.py","line number: ": "730","func name: ": "test_set_none_nan","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_datetime2.py","line number: ": "745","func name: ": "test_nat_operations","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_datetime2.py","line number: ": "756","func name: ": "test_round_nat","func arg: ": "(method, freq)","comments: ": ""},"func30": {"source file: ": "test_datetime2.py","line number: ": "764","func name: ": "test_setitem_tuple_with_datetimetz","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_datetime5.py","line number: ": "12","func name: ": "dtype","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_datetime5.py","line number: ": "17","func name: ": "data","func arg: ": "(dtype)","comments: ": ""},"func3": {"source file: ": "test_datetime5.py","line number: ": "23","func name: ": "data_missing","func arg: ": "(dtype)","comments: ": ""},"func4": {"source file: ": "test_datetime5.py","line number: ": "30","func name: ": "data_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func5": {"source file: ": "test_datetime5.py","line number: ": "38","func name: ": "data_missing_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func6": {"source file: ": "test_datetime5.py","line number: ": "45","func name: ": "data_for_grouping","func arg: ": "(dtype)","comments: ": "Expected to be like [B, B, NA, NA, A, A, B, C]\n\nWhere A < B < C and NA is missing\n"},"func7": {"source file: ": "test_datetime5.py","line number: ": "61","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_datetime5.py","line number: ": "69","func name: ": "na_value","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_datetime6.py","line number: ": "2383","func name: ": "test_shift_months","func arg: ": "(years, months)","comments: ": ""}}{}{"func1": {"source file: ": "test_datetimelike1.py","line number: ": "19","func name: ": "period_index","func arg: ": "(request)","comments: ": "A fixture to provide PeriodIndex objects with different frequencies.\n\nMost PeriodArray behavior is already tested in PeriodIndex tests, so here we just test that the PeriodArray behavior matches the PeriodIndex behavior.\n"},"func2": {"source file: ": "test_datetimelike1.py","line number: ": "34","func name: ": "datetime_index","func arg: ": "(request)","comments: ": "A fixture to provide DatetimeIndex objects with different frequencies.\n\nMost DatetimeArray behavior is already tested in DatetimeIndex tests, so here we just test that the DatetimeArray behavior matches the DatetimeIndex behavior.\n"},"func3": {"source file: ": "test_datetimelike1.py","line number: ": "49","func name: ": "timedelta_index","func arg: ": "(request)","comments: ": "A fixture to provide TimedeltaIndex objects with different frequencies. Most TimedeltaArray behavior is already tested in TimedeltaIndex tests, so here we just test that the TimedeltaArray behavior matches the TimedeltaIndex behavior.\n\n\n"},"func4": {"source file: ": "test_datetimelike1.py","line number: ": "748","func name: ": "test_casting_nat_setitem_array","func arg: ": "(array, casting_nats)","comments: ": ""},"func5": {"source file: ": "test_datetimelike1.py","line number: ": "775","func name: ": "test_invalid_nat_setitem_array","func arg: ": "(array, non_casting_nats)","comments: ": ""},"func6": {"source file: ": "test_datetimelike1.py","line number: ": "788","func name: ": "test_to_numpy_extra","func arg: ": "(array)","comments: ": ""}}{"func1": {"source file: ": "test_datetimelike2.py","line number: ": "1475","func name: ": "_check_plot_works","func arg: ": "(f, freq, series, **kwargs)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_decimal1.py","line number: ": "16","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_decimal1.py","line number: ": "21","func name: ": "data","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_decimal1.py","line number: ": "26","func name: ": "data_for_twos","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_decimal1.py","line number: ": "31","func name: ": "data_missing","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_decimal1.py","line number: ": "36","func name: ": "data_for_sorting","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_decimal1.py","line number: ": "43","func name: ": "data_missing_for_sorting","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_decimal1.py","line number: ": "50","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_decimal1.py","line number: ": "55","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_decimal1.py","line number: ": "60","func name: ": "data_for_grouping","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_decimal1.py","line number: ": "213","func name: ": "test_series_constructor_coerce_data_to_extension_dtype_raises","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_decimal1.py","line number: ": "222","func name: ": "test_series_constructor_with_dtype","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_decimal1.py","line number: ": "233","func name: ": "test_dataframe_constructor_with_dtype","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_decimal1.py","line number: ": "247","func name: ": "test_astype_dispatches","func arg: ": "(frame)","comments: ": ""},"func14": {"source file: ": "test_decimal1.py","line number: ": "339","func name: ": "test_combine_from_sequence_raises","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_decimal1.py","line number: ": "358","func name: ": "test_scalar_ops_from_sequence_raises","func arg: ": "(class_)","comments: ": ""},"func16": {"source file: ": "test_decimal1.py","line number: ": "373","func name: ": "test_divmod_array","func arg: ": "(reverse, expected_div, expected_mod)","comments: ": ""},"func17": {"source file: ": "test_decimal1.py","line number: ": "387","func name: ": "test_ufunc_fallback","func arg: ": "(data)","comments: ": ""},"func18": {"source file: ": "test_decimal1.py","line number: ": "395","func name: ": "test_array_ufunc","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_decimal1.py","line number: ": "402","func name: ": "test_array_ufunc_series","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_decimal1.py","line number: ": "410","func name: ": "test_array_ufunc_series_scalar_other","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_decimal1.py","line number: ": "419","func name: ": "test_array_ufunc_series_defer","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_decimal1.py","line number: ": "431","func name: ": "test_groupby_agg","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_decimal1.py","line number: ": "463","func name: ": "test_groupby_agg_ea_method","func arg: ": "(monkeypatch)","comments: ": ""},"func24": {"source file: ": "test_decimal1.py","line number: ": "483","func name: ": "test_indexing_no_materialize","func arg: ": "(monkeypatch)","comments: ": ""},"func25": {"source file: ": "test_decimal1.py","line number: ": "504","func name: ": "test_to_numpy_keyword","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "9","func name: ": "_f1","func arg: ": "(new)","comments: ": ""},"func2": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "17","func name: ": "_f2","func arg: ": "(new)","comments: ": ""},"func3": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "21","func name: ": "_f3_mapping","func arg: ": "(x)","comments: ": ""},"func4": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "26","func name: ": "_f3","func arg: ": "(new)","comments: ": ""},"func5": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "31","func name: ": "test_deprecate_kwarg","func arg: ": "(key, klass)","comments: ": ""},"func6": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "39","func name: ": "test_dict_deprecate_kwarg","func arg: ": "(key)","comments: ": ""},"func7": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "45","func name: ": "test_missing_deprecate_kwarg","func arg: ": "(key)","comments: ": ""},"func8": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "51","func name: ": "test_callable_deprecate_kwarg","func arg: ": "(x)","comments: ": ""},"func9": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "56","func name: ": "test_callable_deprecate_kwarg_fail","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "63","func name: ": "test_bad_deprecate_kwarg","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "74","func name: ": "_f4","func arg: ": "(old, unchanged)","comments: ": ""},"func12": {"source file: ": "test_deprecate_kwarg1.py","line number: ": "79","func name: ": "test_deprecate_keyword","func arg: ": "(key)","comments: ": ""}}{"func1": {"source file: ": "test_deprecate1.py","line number: ": "10","func name: ": "new_func","func arg: ": "()","comments: ": "This is the summary. The deprecate directive goes next.\n\nThis is the extended summary. The deprecate directive goes before this.\n"},"func2": {"source file: ": "test_deprecate1.py","line number: ": "19","func name: ": "new_func_no_docstring","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_deprecate1.py","line number: ": "23","func name: ": "new_func_wrong_docstring","func arg: ": "()","comments: ": "Summary should be in the next line.\n\n\n"},"func4": {"source file: ": "test_deprecate1.py","line number: ": "28","func name: ": "new_func_with_deprecation","func arg: ": "()","comments: ": "This is the summary. The deprecate directive goes next.\n\n.. deprecated:: 1.0 Use new_func instead.\n\nThis is the extended summary. The deprecate directive goes before this.\n"},"func5": {"source file: ": "test_deprecate1.py","line number: ": "40","func name: ": "test_deprecate_ok","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_deprecate1.py","line number: ": "50","func name: ": "test_deprecate_no_docstring","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_deprecate1.py","line number: ": "59","func name: ": "test_deprecate_wrong_docstring","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_dialect1.py","line number: ": "18","func name: ": "custom_dialect","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_dialect1.py","line number: ": "31","func name: ": "test_dialect","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_dialect1.py","line number: ": "53","func name: ": "test_dialect_str","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_dialect1.py","line number: ": "68","func name: ": "test_invalid_dialect","func arg: ": "(all_parsers)","comments: ": ""},"func5": {"source file: ": "test_dialect1.py","line number: ": "85","func name: ": "test_dialect_conflict_except_delimiter","func arg: ": "(all_parsers, custom_dialect, arg, value)","comments: ": ""},"func6": {"source file: ": "test_dialect1.py","line number: ": "133","func name: ": "test_dialect_conflict_delimiter","func arg: ": "(all_parsers, custom_dialect, kwargs, warning_klass)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_downcast1.py","line number: ": "39","func name: ": "test_downcast","func arg: ": "(arr, expected, dtype)","comments: ": ""},"func2": {"source file: ": "test_downcast1.py","line number: ": "44","func name: ": "test_downcast_booleans","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_downcast1.py","line number: ": "53","func name: ": "test_downcast_conversion_no_nan","func arg: ": "(any_real_dtype)","comments: ": ""},"func4": {"source file: ": "test_downcast1.py","line number: ": "62","func name: ": "test_downcast_conversion_nan","func arg: ": "(float_dtype)","comments: ": ""},"func5": {"source file: ": "test_downcast1.py","line number: ": "73","func name: ": "test_downcast_conversion_empty","func arg: ": "(any_real_dtype)","comments: ": ""},"func6": {"source file: ": "test_downcast1.py","line number: ": "81","func name: ": "test_datetime_likes_nan","func arg: ": "(klass)","comments: ": ""},"func7": {"source file: ": "test_downcast1.py","line number: ": "91","func name: ": "test_datetime_with_timezone","func arg: ": "(as_asi)","comments: ": ""}}{"func1": {"source file: ": "test_downstream1.py","line number: ": "17","func name: ": "import_module","func arg: ": "(name)","comments: ": ""},"func2": {"source file: ": "test_downstream1.py","line number: ": "28","func name: ": "df","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_downstream1.py","line number: ": "32","func name: ": "test_dask","func arg: ": "(df)","comments: ": ""},"func4": {"source file: ": "test_downstream1.py","line number: ": "45","func name: ": "test_xarray","func arg: ": "(df)","comments: ": ""},"func5": {"source file: ": "test_downstream1.py","line number: ": "54","func name: ": "test_xarray_cftimeindex_nearest","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_downstream1.py","line number: ": "65","func name: ": "test_oo_optimizable","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_downstream1.py","line number: ": "77","func name: ": "test_statsmodels","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_downstream1.py","line number: ": "89","func name: ": "test_scikit_learn","func arg: ": "(df)","comments: ": ""},"func9": {"source file: ": "test_downstream1.py","line number: ": "103","func name: ": "test_seaborn","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_downstream1.py","line number: ": "110","func name: ": "test_pandas_gbq","func arg: ": "(df)","comments: ": ""},"func11": {"source file: ": "test_downstream1.py","line number: ": "117","func name: ": "test_pandas_datareader","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_downstream1.py","line number: ": "126","func name: ": "test_geopandas","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_downstream1.py","line number: ": "133","func name: ": "test_geopandas_coordinate_indexer","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_downstream1.py","line number: ": "156","func name: ": "test_pyarrow","func arg: ": "(df)","comments: ": ""},"func15": {"source file: ": "test_downstream1.py","line number: ": "165","func name: ": "test_missing_required_dependency","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_drop_duplicates1.py","line number: ": "16","func name: ": "test_drop_duplicates","func arg: ": "(any_numpy_dtype, keep, expected)","comments: ": ""},"func2": {"source file: ": "test_drop_duplicates1.py","line number: ": "37","func name: ": "test_drop_duplicates_bool","func arg: ": "(keep, expected)","comments: ": ""}}{"func1": {"source file: ": "test_drop_duplicates2.py","line number: ": "11","func name: ": "test_drop_duplicates_with_misspelled_column_name","func arg: ": "(subset)","comments: ": ""},"func2": {"source file: ": "test_drop_duplicates2.py","line number: ": "20","func name: ": "test_drop_duplicates","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_drop_duplicates2.py","line number: ": "116","func name: ": "test_drop_duplicates_with_duplicate_column_names","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_drop_duplicates2.py","line number: ": "128","func name: ": "test_drop_duplicates_for_take_all","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_drop_duplicates2.py","line number: ": "164","func name: ": "test_drop_duplicates_tuple","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_drop_duplicates2.py","line number: ": "203","func name: ": "test_drop_duplicates_empty","func arg: ": "(df)","comments: ": ""},"func7": {"source file: ": "test_drop_duplicates2.py","line number: ": "213","func name: ": "test_drop_duplicates_NA","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_drop_duplicates2.py","line number: ": "287","func name: ": "test_drop_duplicates_NA_for_take_all","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_drop_duplicates2.py","line number: ": "325","func name: ": "test_drop_duplicates_inplace","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_drop_duplicates2.py","line number: ": "406","func name: ": "test_drop_duplicates_ignore_index","func arg: ": "(inplace, origin_dict, output_dict, ignore_index, output_index)","comments: ": ""}}{"func1": {"source file: ": "test_drop1.py","line number: ": "11","func name: ": "test_drop","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_drop1.py","line number: ": "69","func name: ": "test_droplevel_with_names","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_drop1.py","line number: ": "91","func name: ": "test_droplevel_list","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_drop1.py","line number: ": "121","func name: ": "test_drop_not_lexsorted","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_drop1.py","line number: ": "151","func name: ": "test_drop_raise_exception_if_labels_not_in_level","func arg: ": "(msg, labels, level)","comments: ": ""},"func6": {"source file: ": "test_drop1.py","line number: ": "164","func name: ": "test_drop_errors_ignore","func arg: ": "(labels, level)","comments: ": ""},"func7": {"source file: ": "test_drop1.py","line number: ": "177","func name: ": "test_drop_with_non_unique_datetime_index_and_invalid_keys","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_dtype1.py","line number: ": "21","func name: ": "test_inferred_dtype","func arg: ": "(dtype, fill_value)","comments: ": ""},"func2": {"source file: ": "test_dtype1.py","line number: ": "30","func name: ": "test_from_sparse_dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_dtype1.py","line number: ": "36","func name: ": "test_from_sparse_dtype_fill_value","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_dtype1.py","line number: ": "56","func name: ": "test_equal","func arg: ": "(dtype, fill_value)","comments: ": ""},"func5": {"source file: ": "test_dtype1.py","line number: ": "63","func name: ": "test_nans_equal","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_dtype1.py","line number: ": "80","func name: ": "test_not_equal","func arg: ": "(a, b)","comments: ": ""},"func7": {"source file: ": "test_dtype1.py","line number: ": "84","func name: ": "test_construct_from_string_raises","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_dtype1.py","line number: ": "101","func name: ": "test_is_numeric","func arg: ": "(dtype, expected)","comments: ": ""},"func9": {"source file: ": "test_dtype1.py","line number: ": "105","func name: ": "test_str_uses_object","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_dtype1.py","line number: ": "121","func name: ": "test_construct_from_string","func arg: ": "(string, expected)","comments: ": ""},"func11": {"source file: ": "test_dtype1.py","line number: ": "136","func name: ": "test_hash_equal","func arg: ": "(a, b, expected)","comments: ": ""},"func12": {"source file: ": "test_dtype1.py","line number: ": "154","func name: ": "test_parse_subtype","func arg: ": "(string, expected)","comments: ": ""},"func13": {"source file: ": "test_dtype1.py","line number: ": "162","func name: ": "test_construct_from_string_fill_value_raises","func arg: ": "(string)","comments: ": ""},"func14": {"source file: ": "test_dtype1.py","line number: ": "176","func name: ": "test_update_dtype","func arg: ": "(original, dtype, expected)","comments: ": ""},"func15": {"source file: ": "test_dtype1.py","line number: ": "196","func name: ": "test_update_dtype_raises","func arg: ": "(original, dtype, expected_error_msg)","comments: ": ""}}{"func1": {"source file: ": "test_dtypes1.py","line number: ": "22","func name: ": "test_dtype_all_columns","func arg: ": "(all_parsers, dtype, check_orig)","comments: ": ""},"func2": {"source file: ": "test_dtypes1.py","line number: ": "46","func name: ": "test_dtype_all_columns_empty","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_dtypes1.py","line number: ": "55","func name: ": "test_dtype_per_column","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_dtypes1.py","line number: ": "73","func name: ": "test_invalid_dtype_per_column","func arg: ": "(all_parsers)","comments: ": ""},"func5": {"source file: ": "test_dtypes1.py","line number: ": "94","func name: ": "test_categorical_dtype","func arg: ": "(all_parsers, dtype)","comments: ": ""},"func6": {"source file: ": "test_dtypes1.py","line number: ": "113","func name: ": "test_categorical_dtype_single","func arg: ": "(all_parsers, dtype)","comments: ": ""},"func7": {"source file: ": "test_dtypes1.py","line number: ": "127","func name: ": "test_categorical_dtype_unsorted","func arg: ": "(all_parsers)","comments: ": ""},"func8": {"source file: ": "test_dtypes1.py","line number: ": "145","func name: ": "test_categorical_dtype_missing","func arg: ": "(all_parsers)","comments: ": ""},"func9": {"source file: ": "test_dtypes1.py","line number: ": "164","func name: ": "test_categorical_dtype_high_cardinality_numeric","func arg: ": "(all_parsers)","comments: ": ""},"func10": {"source file: ": "test_dtypes1.py","line number: ": "177","func name: ": "test_categorical_dtype_latin1","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func11": {"source file: ": "test_dtypes1.py","line number: ": "190","func name: ": "test_categorical_dtype_utf16","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func12": {"source file: ": "test_dtypes1.py","line number: ": "204","func name: ": "test_categorical_dtype_chunksize_infer_categories","func arg: ": "(all_parsers)","comments: ": ""},"func13": {"source file: ": "test_dtypes1.py","line number: ": "222","func name: ": "test_categorical_dtype_chunksize_explicit_categories","func arg: ": "(all_parsers)","comments: ": ""},"func14": {"source file: ": "test_dtypes1.py","line number: ": "249","func name: ": "test_categorical_category_dtype","func arg: ": "(all_parsers, categories, ordered)","comments: ": ""},"func15": {"source file: ": "test_dtypes1.py","line number: ": "270","func name: ": "test_categorical_category_dtype_unsorted","func arg: ": "(all_parsers)","comments: ": ""},"func16": {"source file: ": "test_dtypes1.py","line number: ": "289","func name: ": "test_categorical_coerces_numeric","func arg: ": "(all_parsers)","comments: ": ""},"func17": {"source file: ": "test_dtypes1.py","line number: ": "300","func name: ": "test_categorical_coerces_datetime","func arg: ": "(all_parsers)","comments: ": ""},"func18": {"source file: ": "test_dtypes1.py","line number: ": "311","func name: ": "test_categorical_coerces_timestamp","func arg: ": "(all_parsers)","comments: ": ""},"func19": {"source file: ": "test_dtypes1.py","line number: ": "322","func name: ": "test_categorical_coerces_timedelta","func arg: ": "(all_parsers)","comments: ": ""},"func20": {"source file: ": "test_dtypes1.py","line number: ": "342","func name: ": "test_categorical_dtype_coerces_boolean","func arg: ": "(all_parsers, data)","comments: ": ""},"func21": {"source file: ": "test_dtypes1.py","line number: ": "352","func name: ": "test_categorical_unexpected_categories","func arg: ": "(all_parsers)","comments: ": ""},"func22": {"source file: ": "test_dtypes1.py","line number: ": "363","func name: ": "test_empty_pass_dtype","func arg: ": "(all_parsers)","comments: ": ""},"func23": {"source file: ": "test_dtypes1.py","line number: ": "376","func name: ": "test_empty_with_index_pass_dtype","func arg: ": "(all_parsers)","comments: ": ""},"func24": {"source file: ": "test_dtypes1.py","line number: ": "390","func name: ": "test_empty_with_multi_index_pass_dtype","func arg: ": "(all_parsers)","comments: ": ""},"func25": {"source file: ": "test_dtypes1.py","line number: ": "405","func name: ": "test_empty_with_mangled_column_pass_dtype_by_names","func arg: ": "(all_parsers)","comments: ": ""},"func26": {"source file: ": "test_dtypes1.py","line number: ": "418","func name: ": "test_empty_with_mangled_column_pass_dtype_by_indexes","func arg: ": "(all_parsers)","comments: ": ""},"func27": {"source file: ": "test_dtypes1.py","line number: ": "431","func name: ": "test_empty_with_dup_column_pass_dtype_by_indexes","func arg: ": "(all_parsers)","comments: ": ""},"func28": {"source file: ": "test_dtypes1.py","line number: ": "445","func name: ": "test_empty_with_dup_column_pass_dtype_by_indexes_raises","func arg: ": "(all_parsers)","comments: ": ""},"func29": {"source file: ": "test_dtypes1.py","line number: ": "459","func name: ": "test_raise_on_passed_int_dtype_with_nas","func arg: ": "(all_parsers)","comments: ": ""},"func30": {"source file: ": "test_dtypes1.py","line number: ": "476","func name: ": "test_dtype_with_converters","func arg: ": "(all_parsers)","comments: ": ""},"func31": {"source file: ": "test_dtypes1.py","line number: ": "534","func name: ": "test_empty_dtype","func arg: ": "(all_parsers, dtype, expected)","comments: ": ""},"func32": {"source file: ": "test_dtypes1.py","line number: ": "546","func name: ": "test_numeric_dtype","func arg: ": "(all_parsers, dtype)","comments: ": ""},"func33": {"source file: ": "test_dtypes1.py","line number: ": "555","func name: ": "test_boolean_dtype","func arg: ": "(all_parsers)","comments: ": ""}}{"func1": {"source file: ": "test_dtypes2.py","line number: ": "25","func name: ": "_check_cast","func arg: ": "(df, v)","comments: ": "Check if all dtypes of df are equal to v\n\n\n"}}{}{}{}{"func1": {"source file: ": "test_dtypes6.py","line number: ": "891","func name: ": "test_registry","func arg: ": "(dtype)","comments: ": ""},"func2": {"source file: ": "test_dtypes6.py","line number: ": "907","func name: ": "test_registry_find","func arg: ": "(dtype, expected)","comments: ": ""},"func3": {"source file: ": "test_dtypes6.py","line number: ": "926","func name: ": "test_is_bool_dtype","func arg: ": "(dtype, expected)","comments: ": ""},"func4": {"source file: ": "test_dtypes6.py","line number: ": "931","func name: ": "test_is_bool_dtype_sparse","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_dtypes6.py","line number: ": "950","func name: ": "test_is_dtype_no_warning","func arg: ": "(check)","comments: ": ""}}{"func1": {"source file: ": "test_duplicated1.py","line number: ": "16","func name: ": "test_duplicated_keep","func arg: ": "(keep, expected)","comments: ": ""},"func2": {"source file: ": "test_duplicated1.py","line number: ": "31","func name: ": "test_duplicated_nan_none","func arg: ": "(keep, expected)","comments: ": ""}}{"func1": {"source file: ": "test_duplicated2.py","line number: ": "11","func name: ": "test_duplicated_with_misspelled_column_name","func arg: ": "(subset)","comments: ": ""},"func2": {"source file: ": "test_duplicated2.py","line number: ": "21","func name: ": "test_duplicated_do_not_fail_on_wide_dataframes","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_duplicated2.py","line number: ": "46","func name: ": "test_duplicated_keep","func arg: ": "(keep, expected)","comments: ": ""},"func4": {"source file: ": "test_duplicated2.py","line number: ": "62","func name: ": "test_duplicated_nan_none","func arg: ": "(keep, expected)","comments: ": ""},"func5": {"source file: ": "test_duplicated2.py","line number: ": "71","func name: ": "test_duplicated_subset","func arg: ": "(subset, keep)","comments: ": ""},"func6": {"source file: ": "test_duplicated2.py","line number: ": "92","func name: ": "test_duplicated_on_empty_frame","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_duplicates1.py","line number: ": "9","func name: ": "test_nunique","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_duplicates1.py","line number: ": "24","func name: ": "test_unique","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_duplicates1.py","line number: ": "55","func name: ": "test_unique_data_ownership","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_duplicates1.py","line number: ": "72","func name: ": "test_is_unique","func arg: ": "(data, expected)","comments: ": ""},"func5": {"source file: ": "test_duplicates1.py","line number: ": "78","func name: ": "test_is_unique_class_ne","func arg: ": "(capsys)","comments: ": ""}}{"func1": {"source file: ": "test_duplicates2.py","line number: ": "13","func name: ": "test_unique","func arg: ": "(names)","comments: ": ""},"func2": {"source file: ": "test_duplicates2.py","line number: ": "36","func name: ": "test_unique_datetimelike","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_duplicates2.py","line number: ": "55","func name: ": "test_unique_level","func arg: ": "(idx, level)","comments: ": ""},"func4": {"source file: ": "test_duplicates2.py","line number: ": "74","func name: ": "test_get_unique_index","func arg: ": "(idx, dropna)","comments: ": ""},"func5": {"source file: ": "test_duplicates2.py","line number: ": "83","func name: ": "test_duplicate_multiindex_codes","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_duplicates2.py","line number: ": "96","func name: ": "test_duplicate_level_names","func arg: ": "(names)","comments: ": ""},"func7": {"source file: ": "test_duplicates2.py","line number: ": "112","func name: ": "test_duplicate_meta_data","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_duplicates2.py","line number: ": "128","func name: ": "test_has_duplicates","func arg: ": "(idx, idx_dup)","comments: ": ""},"func9": {"source file: ": "test_duplicates2.py","line number: ": "156","func name: ": "test_has_duplicates_from_tuples","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_duplicates2.py","line number: ": "183","func name: ": "test_has_duplicates_overflow","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_duplicates2.py","line number: ": "236","func name: ": "test_duplicated","func arg: ": "(idx_dup, keep, expected)","comments: ": ""},"func12": {"source file: ": "test_duplicates2.py","line number: ": "242","func name: ": "test_duplicated_large","func arg: ": "(keep)","comments: ": ""},"func13": {"source file: ": "test_duplicates2.py","line number: ": "254","func name: ": "test_duplicated2","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_encoding1.py","line number: ": "17","func name: ": "test_bytes_io_input","func arg: ": "(all_parsers)","comments: ": ""},"func2": {"source file: ": "test_encoding1.py","line number: ": "28","func name: ": "test_read_csv_unicode","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_encoding1.py","line number: ": "39","func name: ": "test_utf16_bom_skiprows","func arg: ": "(all_parsers, sep, encoding)","comments: ": ""},"func4": {"source file: ": "test_encoding1.py","line number: ": "71","func name: ": "test_utf16_example","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func5": {"source file: ": "test_encoding1.py","line number: ": "78","func name: ": "test_unicode_encoding","func arg: ": "(all_parsers, csv_dir_path)","comments: ": ""},"func6": {"source file: ": "test_encoding1.py","line number: ": "109","func name: ": "test_utf8_bom","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func7": {"source file: ": "test_encoding1.py","line number: ": "123","func name: ": "test_read_csv_utf_aliases","func arg: ": "(all_parsers, utf_value, encoding_fmt)","comments: ": ""},"func8": {"source file: ": "test_encoding1.py","line number: ": "143","func name: ": "test_binary_mode_file_buffers","func arg: ": "(all_parsers, csv_dir_path, fname, encoding)","comments: ": ""},"func9": {"source file: ": "test_encoding1.py","line number: ": "165","func name: ": "test_encoding_temp_file","func arg: ": "(all_parsers, utf_value, encoding_fmt, pass_encoding)","comments: ": ""},"func10": {"source file: ": "test_encoding1.py","line number: ": "180","func name: ": "test_encoding_named_temp_file","func arg: ": "(all_parsers)","comments: ": ""}}{}{"func1": {"source file: ": "test_equivalence1.py","line number: ": "9","func name: ": "test_equals","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_equivalence1.py","line number: ": "26","func name: ": "test_equals_op","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_equivalence1.py","line number: ": "87","func name: ": "test_equals_multi","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_equivalence1.py","line number: ": "136","func name: ": "test_identical","func arg: ": "(idx)","comments: ": ""},"func5": {"source file: ": "test_equivalence1.py","line number: ": "158","func name: ": "test_equals_operator","func arg: ": "(idx)","comments: ": ""},"func6": {"source file: ": "test_equivalence1.py","line number: ": "163","func name: ": "test_equals_missing_values","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_equivalence1.py","line number: ": "172","func name: ": "test_is_","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_equivalence1.py","line number: ": "202","func name: ": "test_is_all_dates","func arg: ": "(idx)","comments: ": ""},"func9": {"source file: ": "test_equivalence1.py","line number: ": "206","func name: ": "test_is_numeric","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_equivalence1.py","line number: ": "211","func name: ": "test_multiindex_compare","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_errors1.py","line number: ": "22","func name: ": "test_exception_importable","func arg: ": "(exc)","comments: ": ""},"func2": {"source file: ": "test_errors1.py","line number: ": "33","func name: ": "test_catch_oob","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_errors1.py","line number: ": "55","func name: ": "test_AbstractMethodError_classmethod","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_eval1.py","line number: ": "52","func name: ": "engine","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_eval1.py","line number: ": "57","func name: ": "parser","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_eval1.py","line number: ": "62","func name: ": "ne_lt_2_6_9","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_eval1.py","line number: ": "69","func name: ": "unary_fns_for_ne","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_eval1.py","line number: ": "79","func name: ": "engine_has_neg_frac","func arg: ": "(engine)","comments: ": ""},"func6": {"source file: ": "test_eval1.py","line number: ": "83","func name: ": "_eval_single_bin","func arg: ": "(lhs, cmp1, rhs, engine)","comments: ": ""},"func7": {"source file: ": "test_eval1.py","line number: ": "97","func name: ": "_series_and_2d_ndarray","func arg: ": "(lhs, rhs)","comments: ": ""},"func8": {"source file: ": "test_eval1.py","line number: ": "103","func name: ": "_series_and_frame","func arg: ": "(lhs, rhs)","comments: ": ""},"func9": {"source file: ": "test_eval1.py","line number: ": "109","func name: ": "_bool_and_frame","func arg: ": "(lhs, rhs)","comments: ": ""},"func10": {"source file: ": "test_eval1.py","line number: ": "113","func name: ": "_is_py3_complex_incompat","func arg: ": "(result, expected)","comments: ": ""},"func11": {"source file: ": "test_eval1.py","line number: ": "856","func name: ": "_is_datetime","func arg: ": "(x)","comments: ": ""},"func12": {"source file: ": "test_eval1.py","line number: ": "860","func name: ": "should_warn","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_eval1.py","line number: ": "1883","func name: ": "test_invalid_engine","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_eval1.py","line number: ": "1890","func name: ": "test_invalid_parser","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_eval1.py","line number: ": "1905","func name: ": "test_disallowed_nodes","func arg: ": "(engine, parser)","comments: ": ""},"func16": {"source file: ": "test_eval1.py","line number: ": "1915","func name: ": "test_syntax_error_exprs","func arg: ": "(engine, parser)","comments: ": ""},"func17": {"source file: ": "test_eval1.py","line number: ": "1921","func name: ": "test_name_error_exprs","func arg: ": "(engine, parser)","comments: ": ""},"func18": {"source file: ": "test_eval1.py","line number: ": "1927","func name: ": "test_invalid_local_variable_reference","func arg: ": "(engine, parser)","comments: ": ""},"func19": {"source file: ": "test_eval1.py","line number: ": "1940","func name: ": "test_numexpr_builtin_raises","func arg: ": "(engine, parser)","comments: ": ""},"func20": {"source file: ": "test_eval1.py","line number: ": "1951","func name: ": "test_bad_resolver_raises","func arg: ": "(engine, parser)","comments: ": ""},"func21": {"source file: ": "test_eval1.py","line number: ": "1957","func name: ": "test_empty_string_raises","func arg: ": "(engine, parser)","comments: ": ""},"func22": {"source file: ": "test_eval1.py","line number: ": "1963","func name: ": "test_more_than_one_expression_raises","func arg: ": "(engine, parser)","comments: ": ""},"func23": {"source file: ": "test_eval1.py","line number: ": "1971","func name: ": "test_bool_ops_fails_on_scalars","func arg: ": "(lhs, cmp, rhs, engine, parser)","comments: ": ""},"func24": {"source file: ": "test_eval1.py","line number: ": "1995","func name: ": "test_equals_various","func arg: ": "(other)","comments: ": ""},"func25": {"source file: ": "test_eval1.py","line number: ": "2006","func name: ": "test_inf","func arg: ": "(engine, parser)","comments: ": ""},"func26": {"source file: ": "test_eval1.py","line number: ": "2013","func name: ": "test_truediv_deprecated","func arg: ": "(engine, parser)","comments: ": ""},"func27": {"source file: ": "test_eval1.py","line number: ": "2030","func name: ": "test_negate_lt_eq_le","func arg: ": "(engine, parser)","comments: ": ""}}{}{"func1": {"source file: ": "test_expanding1.py","line number: ": "119","func name: ": "test_expanding_count_with_min_periods","func arg: ": "(constructor)","comments: ": ""},"func2": {"source file: ": "test_expanding1.py","line number: ": "127","func name: ": "test_expanding_count_default_min_periods_with_null_values","func arg: ": "(constructor)","comments: ": ""}}{"func1": {"source file: ": "test_explode1.py","line number: ": "8","func name: ": "test_basic","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_explode1.py","line number: ": "17","func name: ": "test_mixed_type","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_explode1.py","line number: ": "31","func name: ": "test_empty","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_explode1.py","line number: ": "38","func name: ": "test_nested_lists","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_explode1.py","line number: ": "45","func name: ": "test_multi_index","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_explode1.py","line number: ": "62","func name: ": "test_large","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_explode1.py","line number: ": "68","func name: ": "test_invert_array","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_explode1.py","line number: ": "79","func name: ": "non_object_dtype","func arg: ": "(s)","comments: ": ""},"func9": {"source file: ": "test_explode1.py","line number: ": "84","func name: ": "test_typical_usecase","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_explode1.py","line number: ": "101","func name: ": "test_nested_EA","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_explode1.py","line number: ": "116","func name: ": "test_duplicate_index","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_explode2.py","line number: ": "8","func name: ": "test_error","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_explode2.py","line number: ": "20","func name: ": "test_basic","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_explode2.py","line number: ": "36","func name: ": "test_multi_index_rows","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_explode2.py","line number: ": "66","func name: ": "test_multi_index_columns","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_explode2.py","line number: ": "85","func name: ": "test_usecase","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_explode2.py","line number: ": "159","func name: ": "test_duplicate_index","func arg: ": "(input_dict, input_index, expected_dict, expected_index)","comments: ": ""}}{}{"func1": {"source file: ": "test_external_block1.py","line number: ": "25","func name: ": "df","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_external_block1.py","line number: ": "35","func name: ": "test_concat_series","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_external_block1.py","line number: ": "45","func name: ": "test_concat_dataframe","func arg: ": "(df)","comments: ": ""},"func4": {"source file: ": "test_external_block1.py","line number: ": "51","func name: ": "test_concat_axis1","func arg: ": "(df)","comments: ": ""}}{}{"func1": {"source file: ": "test_federal1.py","line number: ": "10","func name: ": "test_no_mlk_before_1986","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_federal1.py","line number: ": "21","func name: ": "test_memorial_day","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_fields1.py","line number: ": "8","func name: ": "test_fields_readonly","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_filters1.py","line number: ": "9","func name: ": "test_filter_series","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_filters1.py","line number: ": "28","func name: ": "test_filter_single_column_df","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_filters1.py","line number: ": "47","func name: ": "test_filter_multi_column_df","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_filters1.py","line number: ": "57","func name: ": "test_filter_mixed_df","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_filters1.py","line number: ": "65","func name: ": "test_filter_out_all_groups","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_filters1.py","line number: ": "76","func name: ": "test_filter_out_no_groups","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_filters1.py","line number: ": "89","func name: ": "test_filter_out_all_groups_in_df","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_filters1.py","line number: ": "104","func name: ": "test_filter_condition_raises","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_filters1.py","line number: ": "119","func name: ": "test_filter_with_axis_in_groupby","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_filters1.py","line number: ": "128","func name: ": "test_filter_bad_shapes","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_filters1.py","line number: ": "159","func name: ": "test_filter_nan_is_false","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_filters1.py","line number: ": "170","func name: ": "test_filter_against_workaround","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_filters1.py","line number: ": "225","func name: ": "test_filter_using_len","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_filters1.py","line number: ": "252","func name: ": "test_filter_maintains_ordering","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_filters1.py","line number: ": "296","func name: ": "test_filter_multiple_timestamp","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_filters1.py","line number: ": "327","func name: ": "test_filter_and_transform_with_non_unique_int_index","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_filters1.py","line number: ": "370","func name: ": "test_filter_and_transform_with_multiple_non_unique_int_index","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_filters1.py","line number: ": "413","func name: ": "test_filter_and_transform_with_non_unique_float_index","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_filters1.py","line number: ": "456","func name: ": "test_filter_and_transform_with_non_unique_timestamp_index","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_filters1.py","line number: ": "502","func name: ": "test_filter_and_transform_with_non_unique_string_index","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_filters1.py","line number: ": "545","func name: ": "test_filter_has_access_to_grouped_cols","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_filters1.py","line number: ": "553","func name: ": "test_filter_enforces_scalarness","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_filters1.py","line number: ": "570","func name: ": "test_filter_non_bool_raises","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_filters1.py","line number: ": "587","func name: ": "test_filter_dropna_with_empty_groups","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_find_common_type1.py","line number: ": "62","func name: ": "test_numpy_dtypes","func arg: ": "(source_dtypes, expected_common_dtype)","comments: ": ""},"func2": {"source file: ": "test_find_common_type1.py","line number: ": "66","func name: ": "test_raises_empty_input","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_find_common_type1.py","line number: ": "79","func name: ": "test_categorical_dtype","func arg: ": "(dtypes, exp_type)","comments: ": ""},"func4": {"source file: ": "test_find_common_type1.py","line number: ": "83","func name: ": "test_datetimetz_dtype_match","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_find_common_type1.py","line number: ": "97","func name: ": "test_datetimetz_dtype_mismatch","func arg: ": "(dtype2)","comments: ": ""},"func6": {"source file: ": "test_find_common_type1.py","line number: ": "103","func name: ": "test_period_dtype_match","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_find_common_type1.py","line number: ": "119","func name: ": "test_period_dtype_mismatch","func arg: ": "(dtype2)","comments: ": ""}}{"func1": {"source file: ": "test_fiscal1.py","line number: ": "21","func name: ": "makeFY5253LastOfMonthQuarter","func arg: ": "(**kwds)","comments: ": ""},"func2": {"source file: ": "test_fiscal1.py","line number: ": "25","func name: ": "makeFY5253NearestEndMonthQuarter","func arg: ": "(**kwds)","comments: ": ""},"func3": {"source file: ": "test_fiscal1.py","line number: ": "29","func name: ": "makeFY5253NearestEndMonth","func arg: ": "(**kwds)","comments: ": ""},"func4": {"source file: ": "test_fiscal1.py","line number: ": "33","func name: ": "makeFY5253LastOfMonth","func arg: ": "(**kwds)","comments: ": ""},"func5": {"source file: ": "test_fiscal1.py","line number: ": "37","func name: ": "test_get_offset_name","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_fiscal1.py","line number: ": "52","func name: ": "test_get_offset","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_fiscal1.py","line number: ": "635","func name: ": "test_bunched_yearends","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_fiscal1.py","line number: ": "655","func name: ": "test_fy5253_last_onoffset","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_fiscal1.py","line number: ": "664","func name: ": "test_fy5253_nearest_onoffset","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_fiscal1.py","line number: ": "673","func name: ": "test_fy5253qtr_onoffset_nearest","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_fiscal1.py","line number: ": "684","func name: ": "test_fy5253qtr_onoffset_last","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_format1.py","line number: ": "47","func name: ": "filepath_or_buffer_id","func arg: ": "(request)","comments: ": "A fixture yielding test ids for filepath_or_buffer testing.\n\n\n"},"func2": {"source file: ": "test_format1.py","line number: ": "55","func name: ": "filepath_or_buffer","func arg: ": "(filepath_or_buffer_id, tmp_path)","comments: ": "A fixture yielding a string representing a filepath, a path-like object and a StringIO buffer. Also checks that buffer is not closed.\n\n\n"},"func3": {"source file: ": "test_format1.py","line number: ": "73","func name: ": "assert_filepath_or_buffer_equals","func arg: ": "(filepath_or_buffer, filepath_or_buffer_id, encoding)","comments: ": "Assertion helper for checking filepath_or_buffer.\n\n\n"},"func4": {"source file: ": "test_format1.py","line number: ": "93","func name: ": "curpath","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_format1.py","line number: ": "98","func name: ": "has_info_repr","func arg: ": "(df)","comments: ": ""},"func6": {"source file: ": "test_format1.py","line number: ": "105","func name: ": "has_non_verbose_info_repr","func arg: ": "(df)","comments: ": ""},"func7": {"source file: ": "test_format1.py","line number: ": "119","func name: ": "has_horizontally_truncated_repr","func arg: ": "(df)","comments: ": ""},"func8": {"source file: ": "test_format1.py","line number: ": "133","func name: ": "has_vertically_truncated_repr","func arg: ": "(df)","comments: ": ""},"func9": {"source file: ": "test_format1.py","line number: ": "142","func name: ": "has_truncated_repr","func arg: ": "(df)","comments: ": ""},"func10": {"source file: ": "test_format1.py","line number: ": "146","func name: ": "has_doubly_truncated_repr","func arg: ": "(df)","comments: ": ""},"func11": {"source file: ": "test_format1.py","line number: ": "150","func name: ": "has_expanded_repr","func arg: ": "(df)","comments: ": ""},"func12": {"source file: ": "test_format1.py","line number: ": "2140","func name: ": "gen_series_formatting","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_format1.py","line number: ": "2812","func name: ": "_three_digit_exp","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_format1.py","line number: ": "3199","func name: ": "test_format_percentiles","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_format1.py","line number: ": "3219","func name: ": "test_format_percentiles_integer_idx","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_format1.py","line number: ": "3238","func name: ": "test_repr_html_ipython_config","func arg: ": "(ip)","comments: ": ""},"func17": {"source file: ": "test_format1.py","line number: ": "3259","func name: ": "test_filepath_or_buffer_arg","func arg: ": "(method, filepath_or_buffer, assert_filepath_or_buffer_equals, encoding, data, filepath_or_buffer_id)","comments: ": ""},"func18": {"source file: ": "test_format1.py","line number: ": "3285","func name: ": "test_filepath_or_buffer_bad_arg_raises","func arg: ": "(float_frame, method)","comments: ": ""}}{"func1": {"source file: ": "test_format2.py","line number: ": "10","func name: ": "test_format","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_format2.py","line number: ": "15","func name: ": "test_format_integer_names","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_format2.py","line number: ": "22","func name: ": "test_format_sparse_config","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_format2.py","line number: ": "36","func name: ": "test_format_sparse_display","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_format2.py","line number: ": "51","func name: ": "test_repr_with_unicode_data","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_format2.py","line number: ": "58","func name: ": "test_repr_roundtrip_raises","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_format2.py","line number: ": "64","func name: ": "test_unicode_string_with_unicode","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_format2.py","line number: ": "70","func name: ": "test_repr_max_seq_item_setting","func arg: ": "(idx)","comments: ": ""}}{"func1": {"source file: ": "test_formats1.py","line number: ": "15","func name: ": "test_repr","func arg: ": "(td, expected_repr)","comments: ": ""},"func2": {"source file: ": "test_formats1.py","line number: ": "43","func name: ": "test_isoformat","func arg: ": "(td, expected_iso)","comments: ": ""}}{"func1": {"source file: ": "test_formats2.py","line number: ": "9","func name: ": "test_to_native_types","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_formats3.py","line number: ": "13","func name: ": "test_to_native_types","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_frame1.py","line number: ": "3303","func name: ": "_generate_4_axes_via_gridspec","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_freq_code1.py","line number: ": "15","func name: ": "period_code_item","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_freq_code1.py","line number: ": "33","func name: ": "test_freq_code","func arg: ": "(freqstr, expected)","comments: ": ""},"func3": {"source file: ": "test_freq_code1.py","line number: ": "37","func name: ": "test_freq_code_match","func arg: ": "(period_code_item)","comments: ": ""},"func4": {"source file: ": "test_freq_code1.py","line number: ": "67","func name: ": "test_freq_group","func arg: ": "(freqstr, expected)","comments: ": ""},"func5": {"source file: ": "test_freq_code1.py","line number: ": "71","func name: ": "test_freq_group_match","func arg: ": "(period_code_item)","comments: ": ""},"func6": {"source file: ": "test_freq_code1.py","line number: ": "84","func name: ": "test_get_to_timestamp_base","func arg: ": "(freqstr, exp_freqstr)","comments: ": ""},"func7": {"source file: ": "test_freq_code1.py","line number: ": "108","func name: ": "test_get_str_from_freq","func arg: ": "(freqstr, expected)","comments: ": ""},"func8": {"source file: ": "test_freq_code1.py","line number: ": "113","func name: ": "test_get_freq_roundtrip","func arg: ": "(freq)","comments: ": ""},"func9": {"source file: ": "test_freq_code1.py","line number: ": "119","func name: ": "test_get_freq_roundtrip2","func arg: ": "(freq)","comments: ": ""},"func10": {"source file: ": "test_freq_code1.py","line number: ": "135","func name: ": "test_resolution_bumping","func arg: ": "(args, expected)","comments: ": ""},"func11": {"source file: ": "test_freq_code1.py","line number: ": "148","func name: ": "test_cat","func arg: ": "(args)","comments: ": ""},"func12": {"source file: ": "test_freq_code1.py","line number: ": "186","func name: ": "test_get_freq_code","func arg: ": "(freq_input, expected)","comments: ": ""},"func13": {"source file: ": "test_freq_code1.py","line number: ": "190","func name: ": "test_get_code_invalid","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_function1.py","line number: ": "49","func name: ": "test_groupby_bool_aggs","func arg: ": "(agg_func, skipna, vals)","comments: ": ""},"func2": {"source file: ": "test_function1.py","line number: ": "64","func name: ": "test_max_min_non_numeric","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_function1.py","line number: ": "81","func name: ": "test_intercept_builtin_sum","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_function1.py","line number: ": "98","func name: ": "test_builtins_apply","func arg: ": "(keys, f)","comments: ": ""},"func5": {"source file: ": "test_function1.py","line number: ": "123","func name: ": "test_arg_passthru","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_function1.py","line number: ": "266","func name: ": "test_non_cython_api","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_function1.py","line number: ": "329","func name: ": "test_cython_api2","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_function1.py","line number: ": "352","func name: ": "test_cython_median","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_function1.py","line number: ": "369","func name: ": "test_median_empty_bins","func arg: ": "(observed)","comments: ": ""},"func10": {"source file: ": "test_function1.py","line number: ": "394","func name: ": "test_groupby_non_arithmetic_agg_types","func arg: ": "(dtype, method, data)","comments: ": ""},"func11": {"source file: ": "test_function1.py","line number: ": "431","func name: ": "test_groupby_non_arithmetic_agg_int_like_precision","func arg: ": "(i)","comments: ": ""},"func12": {"source file: ": "test_function1.py","line number: ": "461","func name: ": "test_idxmin_idxmax_returns_int_types","func arg: ": "(func, values)","comments: ": ""},"func13": {"source file: ": "test_function1.py","line number: ": "480","func name: ": "test_fill_consistency","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_function1.py","line number: ": "525","func name: ": "test_groupby_cumprod","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_function1.py","line number: ": "544","func name: ": "scipy_sem","func arg: ": "(**kwargs)","comments: ": ""},"func16": {"source file: ": "test_function1.py","line number: ": "567","func name: ": "test_ops_general","func arg: ": "(op, targop)","comments: ": ""},"func17": {"source file: ": "test_function1.py","line number: ": "576","func name: ": "test_max_nan_bug","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_function1.py","line number: ": "590","func name: ": "test_nlargest","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_function1.py","line number: ": "610","func name: ": "test_nlargest_mi_grouper","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_function1.py","line number: ": "655","func name: ": "test_nsmallest","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_function1.py","line number: ": "676","func name: ": "test_numpy_compat","func arg: ": "(func)","comments: ": ""},"func22": {"source file: ": "test_function1.py","line number: ": "694","func name: ": "test_cummin_cummax","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_function1.py","line number: ": "811","func name: ": "test_is_monotonic_increasing","func arg: ": "(in_vals, out_vals)","comments: ": ""},"func24": {"source file: ": "test_function1.py","line number: ": "847","func name: ": "test_is_monotonic_decreasing","func arg: ": "(in_vals, out_vals)","comments: ": ""},"func25": {"source file: ": "test_function1.py","line number: ": "866","func name: ": "test_apply_describe_bug","func arg: ": "(mframe)","comments: ": ""},"func26": {"source file: ": "test_function1.py","line number: ": "871","func name: ": "test_series_describe_multikey","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_function1.py","line number: ": "880","func name: ": "test_series_describe_single","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_function1.py","line number: ": "888","func name: ": "test_series_index_name","func arg: ": "(df)","comments: ": ""},"func29": {"source file: ": "test_function1.py","line number: ": "894","func name: ": "test_frame_describe_multikey","func arg: ": "(tsframe)","comments: ": ""},"func30": {"source file: ": "test_function1.py","line number: ": "920","func name: ": "test_frame_describe_tupleindex","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_function1.py","line number: ": "939","func name: ": "test_frame_describe_unstacked_format","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_function1.py","line number: ": "973","func name: ": "test_series_groupby_nunique","func arg: ": "(n, m, sort, dropna)","comments: ": ""},"func33": {"source file: ": "test_function1.py","line number: ": "1012","func name: ": "test_nunique","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_function1.py","line number: ": "1036","func name: ": "test_nunique_with_object","func arg: ": "()","comments: ": ""},"func35": {"source file: ": "test_function1.py","line number: ": "1055","func name: ": "test_nunique_with_empty_series","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_function1.py","line number: ": "1063","func name: ": "test_nunique_with_timegrouper","func arg: ": "()","comments: ": ""},"func37": {"source file: ": "test_function1.py","line number: ": "1109","func name: ": "test_nunique_with_NaT","func arg: ": "(key, data, dropna, expected)","comments: ": ""},"func38": {"source file: ": "test_function1.py","line number: ": "1116","func name: ": "test_nunique_preserves_column_level_names","func arg: ": "()","comments: ": ""},"func39": {"source file: ": "test_function1.py","line number: ": "1128","func name: ": "test_groupby_timedelta_cython_count","func arg: ": "()","comments: ": ""},"func40": {"source file: ": "test_function1.py","line number: ": "1137","func name: ": "test_count","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_function1.py","line number: ": "1166","func name: ": "test_count_non_nulls","func arg: ": "()","comments: ": ""},"func42": {"source file: ": "test_function1.py","line number: ": "1186","func name: ": "test_count_object","func arg: ": "()","comments: ": ""},"func43": {"source file: ": "test_function1.py","line number: ": "1198","func name: ": "test_count_cross_type","func arg: ": "()","comments: ": ""},"func44": {"source file: ": "test_function1.py","line number: ": "1215","func name: ": "test_lower_int_prec_count","func arg: ": "()","comments: ": ""},"func45": {"source file: ": "test_function1.py","line number: ": "1231","func name: ": "test_count_uses_size_on_exception","func arg: ": "()","comments: ": ""},"func46": {"source file: ": "test_function1.py","line number: ": "1254","func name: ": "test_size","func arg: ": "(df)","comments: ": ""},"func47": {"source file: ": "test_function1.py","line number: ": "1282","func name: ": "test_size_groupby_all_null","func arg: ": "()","comments: ": ""},"func48": {"source file: ": "test_function1.py","line number: ": "1291","func name: ": "test_size_period_index","func arg: ": "()","comments: ": ""},"func49": {"source file: ": "test_function1.py","line number: ": "1326","func name: ": "test_quantile","func arg: ": "(interpolation, a_vals, b_vals, q)","comments: ": ""},"func50": {"source file: ": "test_function1.py","line number: ": "1347","func name: ": "test_quantile_array","func arg: ": "()","comments: ": ""},"func51": {"source file: ": "test_function1.py","line number: ": "1366","func name: ": "test_quantile_array2","func arg: ": "()","comments: ": ""},"func52": {"source file: ": "test_function1.py","line number: ": "1384","func name: ": "test_quantile_array_no_sort","func arg: ": "()","comments: ": ""},"func53": {"source file: ": "test_function1.py","line number: ": "1401","func name: ": "test_quantile_array_multiple_levels","func arg: ": "()","comments: ": ""},"func54": {"source file: ": "test_function1.py","line number: ": "1419","func name: ": "test_groupby_quantile_with_arraylike_q_and_int_columns","func arg: ": "(frame_size, groupby, q)","comments: ": ""},"func55": {"source file: ": "test_function1.py","line number: ": "1445","func name: ": "test_quantile_raises","func arg: ": "()","comments: ": ""},"func56": {"source file: ": "test_function1.py","line number: ": "1454","func name: ": "test_quantile_out_of_bounds_q_raises","func arg: ": "()","comments: ": ""},"func57": {"source file: ": "test_function1.py","line number: ": "1465","func name: ": "test_quantile_missing_group_values_no_segfaults","func arg: ": "()","comments: ": ""},"func58": {"source file: ": "test_function1.py","line number: ": "1486","func name: ": "test_quantile_missing_group_values_correct_results","func arg: ": "(key, val, expected_key, expected_val)","comments: ": ""},"func59": {"source file: ": "test_function1.py","line number: ": "1509","func name: ": "test_pipe","func arg: ": "()","comments: ": ""},"func60": {"source file: ": "test_function1.py","line number: ": "1542","func name: ": "test_pipe_args","func arg: ": "()","comments: ": ""},"func61": {"source file: ": "test_function1.py","line number: ": "1582","func name: ": "test_groupby_mean_no_overflow","func arg: ": "()","comments: ": ""},"func62": {"source file: ": "test_function1.py","line number: ": "1604","func name: ": "test_apply_to_nullable_integer_returns_float","func arg: ": "(values, function)","comments: ": ""}}{"func1": {"source file: ": "test_gbq1.py","line number: ": "27","func name: ": "_skip_if_no_project_id","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_gbq1.py","line number: ": "32","func name: ": "_skip_if_no_private_key_path","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_gbq1.py","line number: ": "37","func name: ": "_in_travis_environment","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_gbq1.py","line number: ": "41","func name: ": "_get_project_id","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_gbq1.py","line number: ": "47","func name: ": "_get_private_key_path","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_gbq1.py","line number: ": "59","func name: ": "_get_credentials","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_gbq1.py","line number: ": "65","func name: ": "_get_client","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_gbq1.py","line number: ": "71","func name: ": "generate_rand_str","func arg: ": "(length)","comments: ": ""},"func9": {"source file: ": "test_gbq1.py","line number: ": "75","func name: ": "make_mixed_dataframe_v2","func arg: ": "(test_size)","comments: ": ""},"func10": {"source file: ": "test_gbq1.py","line number: ": "94","func name: ": "test_read_gbq_without_deprecated_kwargs","func arg: ": "(monkeypatch)","comments: ": ""},"func11": {"source file: ": "test_gbq1.py","line number: ": "108","func name: ": "test_read_gbq_with_new_kwargs","func arg: ": "(monkeypatch)","comments: ": ""},"func12": {"source file: ": "test_gbq1.py","line number: ": "121","func name: ": "test_read_gbq_without_new_kwargs","func arg: ": "(monkeypatch)","comments: ": ""},"func13": {"source file: ": "test_gbq1.py","line number: ": "135","func name: ": "test_read_gbq_progress_bar_type_kwarg","func arg: ": "(monkeypatch, progress_bar)","comments: ": ""}}{"func1": {"source file: ": "test_gcs1.py","line number: ": "14","func name: ": "test_is_gcs_url","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_gcs1.py","line number: ": "21","func name: ": "test_read_csv_gcs","func arg: ": "(monkeypatch)","comments: ": ""},"func3": {"source file: ": "test_gcs1.py","line number: ": "42","func name: ": "test_to_csv_gcs","func arg: ": "(monkeypatch)","comments: ": ""},"func4": {"source file: ": "test_gcs1.py","line number: ": "74","func name: ": "test_to_parquet_gcs_new_file","func arg: ": "(monkeypatch, tmpdir)","comments: ": "Regression test for writing to a not-yet-existent GCS Parquet file.\n\n\n"},"func5": {"source file: ": "test_gcs1.py","line number: ": "98","func name: ": "test_gcs_not_present_exception","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_generic2.py","line number: ": "55","func name: ": "test_setattr_warnings","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_get_set1.py","line number: ": "9","func name: ": "assert_matching","func arg: ": "(actual, expected, check_dtype)","comments: ": ""},"func2": {"source file: ": "test_get_set1.py","line number: ": "19","func name: ": "test_get_level_number_integer","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_get_set1.py","line number: ": "30","func name: ": "test_get_level_values","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_get_set1.py","line number: ": "52","func name: ": "test_get_value_duplicates","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_get_set1.py","line number: ": "64","func name: ": "test_get_level_values_all_na","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_get_set1.py","line number: ": "77","func name: ": "test_get_level_values_int_with_na","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_get_set1.py","line number: ": "92","func name: ": "test_get_level_values_na","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_get_set1.py","line number: ": "116","func name: ": "test_set_name_methods","func arg: ": "(idx, index_names)","comments: ": ""},"func9": {"source file: ": "test_get_set1.py","line number: ": "150","func name: ": "test_set_levels_codes_directly","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_get_set1.py","line number: ": "169","func name: ": "test_set_levels","func arg: ": "(idx)","comments: ": ""},"func11": {"source file: ": "test_get_set1.py","line number: ": "241","func name: ": "test_set_codes","func arg: ": "(idx)","comments: ": ""},"func12": {"source file: ": "test_get_set1.py","line number: ": "310","func name: ": "test_set_levels_codes_names_bad_input","func arg: ": "(idx)","comments: ": ""},"func13": {"source file: ": "test_get_set1.py","line number: ": "358","func name: ": "test_set_names_with_nlevel_1","func arg: ": "(inplace)","comments: ": ""},"func14": {"source file: ": "test_get_set1.py","line number: ": "373","func name: ": "test_set_levels_categorical","func arg: ": "(ordered)","comments: ": ""},"func15": {"source file: ": "test_get_set1.py","line number: ": "389","func name: ": "test_set_value_keeps_names","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_get_set1.py","line number: ": "405","func name: ": "test_set_levels_with_iterable","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_getitem1.py","line number: ": "21","func name: ": "test_series_getitem_multiindex","func arg: ": "(access_method, level1_value, expected)","comments: ": ""},"func2": {"source file: ": "test_getitem1.py","line number: ": "33","func name: ": "test_series_getitem_duplicates_multiindex","func arg: ": "(level0_value)","comments: ": ""},"func3": {"source file: ": "test_getitem1.py","line number: ": "61","func name: ": "test_series_getitem","func arg: ": "(multiindex_year_month_day_dataframe_random_data, indexer)","comments: ": ""},"func4": {"source file: ": "test_getitem1.py","line number: ": "73","func name: ": "test_series_getitem_returns_scalar","func arg: ": "(multiindex_year_month_day_dataframe_random_data, indexer)","comments: ": ""},"func5": {"source file: ": "test_getitem1.py","line number: ": "99","func name: ": "test_series_getitem_indexing_errors","func arg: ": "(multiindex_year_month_day_dataframe_random_data, indexer, expected_error, expected_error_msg)","comments: ": ""},"func6": {"source file: ": "test_getitem1.py","line number: ": "110","func name: ": "test_series_getitem_corner_generator","func arg: ": "(multiindex_year_month_day_dataframe_random_data)","comments: ": ""},"func7": {"source file: ": "test_getitem1.py","line number: ": "124","func name: ": "test_getitem_simple","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func8": {"source file: ": "test_getitem1.py","line number: ": "138","func name: ": "test_frame_getitem_simple_key_error","func arg: ": "(multiindex_dataframe_random_data, indexer, expected_error_msg)","comments: ": ""},"func9": {"source file: ": "test_getitem1.py","line number: ": "146","func name: ": "test_frame_getitem_multicolumn_empty_level","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_getitem1.py","line number: ": "169","func name: ": "test_frame_getitem_toplevel","func arg: ": "(multiindex_dataframe_random_data, indexer, expected_slice)","comments: ": ""},"func11": {"source file: ": "test_getitem1.py","line number: ": "179","func name: ": "test_frame_mixed_depth_get","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_getitem1.py","line number: ": "206","func name: ": "dataframe_with_duplicate_index","func arg: ": "()","comments: ": "Fixture for DataFrame used in tests for gh-4145 and gh-4146\n\n\n"},"func13": {"source file: ": "test_getitem1.py","line number: ": "221","func name: ": "test_frame_mi_access","func arg: ": "(dataframe_with_duplicate_index, indexer)","comments: ": ""},"func14": {"source file: ": "test_getitem1.py","line number: ": "232","func name: ": "test_frame_mi_access_returns_series","func arg: ": "(dataframe_with_duplicate_index)","comments: ": ""},"func15": {"source file: ": "test_getitem1.py","line number: ": "243","func name: ": "test_frame_mi_access_returns_frame","func arg: ": "(dataframe_with_duplicate_index)","comments: ": ""}}{}{"func1": {"source file: ": "test_groupby2.py","line number: ": "17","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_groupby2.py","line number: ": "25","func name: ": "test_basic","func arg: ": "(dtype)","comments: ": ""},"func3": {"source file: ": "test_groupby2.py","line number: ": "73","func name: ": "test_groupby_nonobject_dtype","func arg: ": "(mframe, df_mixed_floats)","comments: ": ""},"func4": {"source file: ": "test_groupby2.py","line number: ": "97","func name: ": "test_groupby_return_type","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_groupby2.py","line number: ": "136","func name: ": "test_inconsistent_return_type","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_groupby2.py","line number: ": "198","func name: ": "test_pass_args_kwargs","func arg: ": "(ts, tsframe)","comments: ": ""},"func7": {"source file: ": "test_groupby2.py","line number: ": "238","func name: ": "test_len","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_groupby2.py","line number: ": "254","func name: ": "test_basic_regression","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_groupby2.py","line number: ": "268","func name: ": "test_with_na_groups","func arg: ": "(dtype)","comments: ": ""},"func10": {"source file: ": "test_groupby2.py","line number: ": "296","func name: ": "test_indices_concatenation_order","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_groupby2.py","line number: ": "352","func name: ": "test_attr_wrapper","func arg: ": "(ts)","comments: ": ""},"func12": {"source file: ": "test_groupby2.py","line number: ": "375","func name: ": "test_frame_groupby","func arg: ": "(tsframe)","comments: ": ""},"func13": {"source file: ": "test_groupby2.py","line number: ": "415","func name: ": "test_frame_groupby_columns","func arg: ": "(tsframe)","comments: ": ""},"func14": {"source file: ": "test_groupby2.py","line number: ": "434","func name: ": "test_frame_set_name_single","func arg: ": "(df)","comments: ": ""},"func15": {"source file: ": "test_groupby2.py","line number: ": "461","func name: ": "test_multi_func","func arg: ": "(df)","comments: ": ""},"func16": {"source file: ": "test_groupby2.py","line number: ": "489","func name: ": "test_multi_key_multiple_functions","func arg: ": "(df)","comments: ": ""},"func17": {"source file: ": "test_groupby2.py","line number: ": "497","func name: ": "test_frame_multi_key_function_list","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_groupby2.py","line number: ": "559","func name: ": "test_groupby_multiple_columns","func arg: ": "(df, op)","comments: ": ""},"func19": {"source file: ": "test_groupby2.py","line number: ": "591","func name: ": "test_as_index_select_column","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_groupby2.py","line number: ": "605","func name: ": "test_groupby_as_index_agg","func arg: ": "(df)","comments: ": ""},"func21": {"source file: ": "test_groupby2.py","line number: ": "661","func name: ": "test_as_index_series_return_frame","func arg: ": "(df)","comments: ": ""},"func22": {"source file: ": "test_groupby2.py","line number: ": "686","func name: ": "test_as_index_series_column_slice_raises","func arg: ": "(df)","comments: ": ""},"func23": {"source file: ": "test_groupby2.py","line number: ": "695","func name: ": "test_groupby_as_index_cython","func arg: ": "(df)","comments: ": ""},"func24": {"source file: ": "test_groupby2.py","line number: ": "718","func name: ": "test_groupby_as_index_series_scalar","func arg: ": "(df)","comments: ": ""},"func25": {"source file: ": "test_groupby2.py","line number: ": "728","func name: ": "test_groupby_as_index_corner","func arg: ": "(df, ts)","comments: ": ""},"func26": {"source file: ": "test_groupby2.py","line number: ": "738","func name: ": "test_groupby_multiple_key","func arg: ": "(df)","comments: ": ""},"func27": {"source file: ": "test_groupby2.py","line number: ": "756","func name: ": "test_groupby_multi_corner","func arg: ": "(df)","comments: ": ""},"func28": {"source file: ": "test_groupby2.py","line number: ": "768","func name: ": "test_omit_nuisance","func arg: ": "(df)","comments: ": ""},"func29": {"source file: ": "test_groupby2.py","line number: ": "793","func name: ": "test_omit_nuisance_python_multiple","func arg: ": "(three_group)","comments: ": ""},"func30": {"source file: ": "test_groupby2.py","line number: ": "801","func name: ": "test_empty_groups_corner","func arg: ": "(mframe)","comments: ": ""},"func31": {"source file: ": "test_groupby2.py","line number: ": "825","func name: ": "test_nonsense_func","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_groupby2.py","line number: ": "832","func name: ": "test_wrap_aggregated_output_multindex","func arg: ": "(mframe)","comments: ": ""},"func33": {"source file: ": "test_groupby2.py","line number: ": "850","func name: ": "test_groupby_level_apply","func arg: ": "(mframe)","comments: ": ""},"func34": {"source file: ": "test_groupby2.py","line number: ": "861","func name: ": "test_groupby_level_mapper","func arg: ": "(mframe)","comments: ": ""},"func35": {"source file: ": "test_groupby2.py","line number: ": "880","func name: ": "test_groupby_level_nonmulti","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_groupby2.py","line number: ": "912","func name: ": "test_groupby_complex","func arg: ": "()","comments: ": ""},"func37": {"source file: ": "test_groupby2.py","line number: ": "924","func name: ": "test_mutate_groups","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_groupby2.py","line number: ": "957","func name: ": "test_no_mutate_but_looks_like","func arg: ": "()","comments: ": ""},"func39": {"source file: ": "test_groupby2.py","line number: ": "969","func name: ": "test_groupby_series_indexed_differently","func arg: ": "()","comments: ": ""},"func40": {"source file: ": "test_groupby2.py","line number: ": "984","func name: ": "test_groupby_with_hier_columns","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_groupby2.py","line number: ": "1022","func name: ": "test_grouping_ndarray","func arg: ": "(df)","comments: ": ""},"func42": {"source file: ": "test_groupby2.py","line number: ": "1032","func name: ": "test_groupby_wrong_multi_labels","func arg: ": "()","comments: ": ""},"func43": {"source file: ": "test_groupby2.py","line number: ": "1049","func name: ": "test_groupby_series_with_name","func arg: ": "(df)","comments: ": ""},"func44": {"source file: ": "test_groupby2.py","line number: ": "1062","func name: ": "test_seriesgroupby_name_attr","func arg: ": "(df)","comments: ": ""},"func45": {"source file: ": "test_groupby2.py","line number: ": "1072","func name: ": "test_consistency_name","func arg: ": "()","comments: ": ""},"func46": {"source file: ": "test_groupby2.py","line number: ": "1089","func name: ": "test_groupby_name_propagation","func arg: ": "(df)","comments: ": ""},"func47": {"source file: ": "test_groupby2.py","line number: ": "1108","func name: ": "test_groupby_nonstring_columns","func arg: ": "()","comments: ": ""},"func48": {"source file: ": "test_groupby2.py","line number: ": "1116","func name: ": "test_groupby_mixed_type_columns","func arg: ": "()","comments: ": ""},"func49": {"source file: ": "test_groupby2.py","line number: ": "1130","func name: ": "test_cython_grouper_series_bug_noncontig","func arg: ": "()","comments: ": ""},"func50": {"source file: ": "test_groupby2.py","line number: ": "1140","func name: ": "test_series_grouper_noncontig_index","func arg: ": "()","comments: ": ""},"func51": {"source file: ": "test_groupby2.py","line number: ": "1154","func name: ": "test_convert_objects_leave_decimal_alone","func arg: ": "()","comments: ": ""},"func52": {"source file: ": "test_groupby2.py","line number: ": "1178","func name: ": "test_groupby_dtype_inference_empty","func arg: ": "()","comments: ": ""},"func53": {"source file: ": "test_groupby2.py","line number: ": "1189","func name: ": "test_groupby_list_infer_array_like","func arg: ": "(df)","comments: ": ""},"func54": {"source file: ": "test_groupby2.py","line number: ": "1204","func name: ": "test_groupby_keys_same_size_as_index","func arg: ": "()","comments: ": ""},"func55": {"source file: ": "test_groupby2.py","line number: ": "1217","func name: ": "test_groupby_one_row","func arg: ": "()","comments: ": ""},"func56": {"source file: ": "test_groupby2.py","line number: ": "1228","func name: ": "test_groupby_nat_exclude","func arg: ": "()","comments: ": ""},"func57": {"source file: ": "test_groupby2.py","line number: ": "1291","func name: ": "test_groupby_2d_malformed","func arg: ": "()","comments: ": ""},"func58": {"source file: ": "test_groupby2.py","line number: ": "1303","func name: ": "test_int32_overflow","func arg: ": "()","comments: ": ""},"func59": {"source file: ": "test_groupby2.py","line number: ": "1313","func name: ": "test_groupby_sort_multi","func arg: ": "()","comments: ": ""},"func60": {"source file: ": "test_groupby2.py","line number: ": "1354","func name: ": "test_dont_clobber_name_column","func arg: ": "()","comments: ": ""},"func61": {"source file: ": "test_groupby2.py","line number: ": "1363","func name: ": "test_skip_group_keys","func arg: ": "()","comments: ": ""},"func62": {"source file: ": "test_groupby2.py","line number: ": "1384","func name: ": "test_no_nonsense_name","func arg: ": "(float_frame)","comments: ": ""},"func63": {"source file: ": "test_groupby2.py","line number: ": "1393","func name: ": "test_multifunc_sum_bug","func arg: ": "()","comments: ": ""},"func64": {"source file: ": "test_groupby2.py","line number: ": "1404","func name: ": "test_handle_dict_return_value","func arg: ": "(df)","comments: ": ""},"func65": {"source file: ": "test_groupby2.py","line number: ": "1419","func name: ": "test_set_group_name","func arg: ": "(df, grouper)","comments: ": ""},"func66": {"source file: ": "test_groupby2.py","line number: ": "1445","func name: ": "test_group_name_available_in_inference_pass","func arg: ": "()","comments: ": ""},"func67": {"source file: ": "test_groupby2.py","line number: ": "1461","func name: ": "test_no_dummy_key_names","func arg: ": "(df)","comments: ": ""},"func68": {"source file: ": "test_groupby2.py","line number: ": "1470","func name: ": "test_groupby_sort_multiindex_series","func arg: ": "()","comments: ": ""},"func69": {"source file: ": "test_groupby2.py","line number: ": "1491","func name: ": "test_groupby_reindex_inside_function","func arg: ": "()","comments: ": ""},"func70": {"source file: ": "test_groupby2.py","line number: ": "1523","func name: ": "test_groupby_multiindex_missing_pair","func arg: ": "()","comments: ": ""},"func71": {"source file: ": "test_groupby2.py","line number: ": "1544","func name: ": "test_groupby_multiindex_not_lexsorted","func arg: ": "()","comments: ": ""},"func72": {"source file: ": "test_groupby2.py","line number: ": "1594","func name: ": "test_index_label_overlaps_location","func arg: ": "()","comments: ": ""},"func73": {"source file: ": "test_groupby2.py","line number: ": "1623","func name: ": "test_transform_doesnt_clobber_ints","func arg: ": "()","comments: ": ""},"func74": {"source file: ": "test_groupby2.py","line number: ": "1645","func name: ": "test_groupby_preserves_sort","func arg: ": "(sort_column, group_column)","comments: ": ""},"func75": {"source file: ": "test_groupby2.py","line number: ": "1670","func name: ": "test_group_shift_with_null_key","func arg: ": "()","comments: ": ""},"func76": {"source file: ": "test_groupby2.py","line number: ": "1697","func name: ": "test_group_shift_with_fill_value","func arg: ": "()","comments: ": ""},"func77": {"source file: ": "test_groupby2.py","line number: ": "1719","func name: ": "test_group_shift_lose_timezone","func arg: ": "()","comments: ": ""},"func78": {"source file: ": "test_groupby2.py","line number: ": "1728","func name: ": "test_pivot_table_values_key_error","func arg: ": "()","comments: ": ""},"func79": {"source file: ": "test_groupby2.py","line number: ": "1746","func name: ": "test_empty_dataframe_groupby","func arg: ": "()","comments: ": ""},"func80": {"source file: ": "test_groupby2.py","line number: ": "1757","func name: ": "test_tuple_as_grouping","func arg: ": "()","comments: ": ""},"func81": {"source file: ": "test_groupby2.py","line number: ": "1776","func name: ": "test_tuple_correct_keyerror","func arg: ": "()","comments: ": ""},"func82": {"source file: ": "test_groupby2.py","line number: ": "1785","func name: ": "test_groupby_agg_ohlc_non_first","func arg: ": "()","comments: ": ""},"func83": {"source file: ": "test_groupby2.py","line number: ": "1812","func name: ": "test_groupby_multiindex_nat","func arg: ": "()","comments: ": ""},"func84": {"source file: ": "test_groupby2.py","line number: ": "1828","func name: ": "test_groupby_empty_list_raises","func arg: ": "()","comments: ": ""},"func85": {"source file: ": "test_groupby2.py","line number: ": "1837","func name: ": "test_groupby_multiindex_series_keys_len_equal_group_axis","func arg: ": "()","comments: ": ""},"func86": {"source file: ": "test_groupby2.py","line number: ": "1853","func name: ": "test_groupby_groups_in_BaseGrouper","func arg: ": "()","comments: ": ""},"func87": {"source file: ": "test_groupby2.py","line number: ": "1868","func name: ": "test_groupby_axis_1","func arg: ": "(group_name)","comments: ": ""},"func88": {"source file: ": "test_groupby2.py","line number: ": "1933","func name: ": "test_shift_bfill_ffill_tz","func arg: ": "(tz_naive_fixture, op, expected)","comments: ": ""},"func89": {"source file: ": "test_groupby2.py","line number: ": "1955","func name: ": "test_groupby_only_none_group","func arg: ": "()","comments: ": ""},"func90": {"source file: ": "test_groupby2.py","line number: ": "1965","func name: ": "test_groupby_duplicate_index","func arg: ": "()","comments: ": ""},"func91": {"source file: ": "test_groupby2.py","line number: ": "1976","func name: ": "test_bool_aggs_dup_column_labels","func arg: ": "(bool_agg_func)","comments: ": ""},"func92": {"source file: ": "test_groupby2.py","line number: ": "1989","func name: ": "test_dup_labels_output_shape","func arg: ": "(groupby_func, idx)","comments: ": ""},"func93": {"source file: ": "test_groupby2.py","line number: ": "2011","func name: ": "test_groupby_crash_on_nunique","func arg: ": "(axis)","comments: ": ""},"func94": {"source file: ": "test_groupby2.py","line number: ": "2028","func name: ": "test_groupby_list_level","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_hashing.py","line number: ": "25","func name: ": "series","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_hashing.py","line number: ": "30","func name: ": "index","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_hashing.py","line number: ": "34","func name: ": "_check_equal","func arg: ": "(obj, **kwargs)","comments: ": "Check that hashing an objects produces the same value each time.\n\nParameters ---------- obj : object The object to hash. kwargs : kwargs Keyword arguments to pass to the hashing function.\n"},"func4": {"source file: ": "test_hashing.py","line number: ": "50","func name: ": "_check_not_equal_with_index","func arg: ": "(obj)","comments: ": "Check the hash of an object with and without its index is not the same.\n\nParameters ---------- obj : object The object to hash.\n"},"func5": {"source file: ": "test_hashing.py","line number: ": "67","func name: ": "test_consistency","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_hashing.py","line number: ": "81","func name: ": "test_hash_array","func arg: ": "(series)","comments: ": ""},"func7": {"source file: ": "test_hashing.py","line number: ": "89","func name: ": "test_hash_array_mixed","func arg: ": "(arr2)","comments: ": ""},"func8": {"source file: ": "test_hashing.py","line number: ": "97","func name: ": "test_hash_array_errors","func arg: ": "(val)","comments: ": ""},"func9": {"source file: ": "test_hashing.py","line number: ": "103","func name: ": "test_hash_tuples","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_hashing.py","line number: ": "118","func name: ": "test_hash_tuple","func arg: ": "(tup)","comments: ": ""},"func11": {"source file: ": "test_hashing.py","line number: ": "147","func name: ": "test_hash_scalar","func arg: ": "(val)","comments: ": ""},"func12": {"source file: ": "test_hashing.py","line number: ": "155","func name: ": "test_hash_tuples_err","func arg: ": "(val)","comments: ": ""},"func13": {"source file: ": "test_hashing.py","line number: ": "161","func name: ": "test_multiindex_unique","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_hashing.py","line number: ": "169","func name: ": "test_multiindex_objects","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_hashing.py","line number: ": "229","func name: ": "test_hash_pandas_object","func arg: ": "(obj, index)","comments: ": ""},"func16": {"source file: ": "test_hashing.py","line number: ": "234","func name: ": "test_hash_pandas_object2","func arg: ": "(series, index)","comments: ": ""},"func17": {"source file: ": "test_hashing.py","line number: ": "242","func name: ": "test_hash_pandas_empty_object","func arg: ": "(obj, index)","comments: ": ""},"func18": {"source file: ": "test_hashing.py","line number: ": "257","func name: ": "test_categorical_consistency","func arg: ": "(s1, categorize)","comments: ": ""},"func19": {"source file: ": "test_hashing.py","line number: ": "274","func name: ": "test_categorical_with_nan_consistency","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_hashing.py","line number: ": "288","func name: ": "test_pandas_errors","func arg: ": "(obj)","comments: ": ""},"func21": {"source file: ": "test_hashing.py","line number: ": "294","func name: ": "test_hash_keys","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_hashing.py","line number: ": "307","func name: ": "test_invalid_key","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_hashing.py","line number: ": "315","func name: ": "test_already_encoded","func arg: ": "(index)","comments: ": ""},"func24": {"source file: ": "test_hashing.py","line number: ": "321","func name: ": "test_alternate_encoding","func arg: ": "(index)","comments: ": ""},"func25": {"source file: ": "test_hashing.py","line number: ": "328","func name: ": "test_same_len_hash_collisions","func arg: ": "(l_exp, l_add)","comments: ": ""},"func26": {"source file: ": "test_hashing.py","line number: ": "336","func name: ": "test_hash_collisions","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_hashing.py","line number: ": "358","func name: ": "test_hash_with_tuple","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_hashing.py","line number: ": "379","func name: ": "test_hash_object_none_key","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_header1.py","line number: ": "18","func name: ": "test_read_with_bad_header","func arg: ": "(all_parsers)","comments: ": ""},"func2": {"source file: ": "test_header1.py","line number: ": "27","func name: ": "test_negative_header","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_header1.py","line number: ": "43","func name: ": "test_negative_multi_index_header","func arg: ": "(all_parsers, header)","comments: ": ""},"func4": {"source file: ": "test_header1.py","line number: ": "57","func name: ": "test_bool_header_arg","func arg: ": "(all_parsers, header)","comments: ": ""},"func5": {"source file: ": "test_header1.py","line number: ": "71","func name: ": "test_no_header_prefix","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_header1.py","line number: ": "85","func name: ": "test_header_with_index_col","func arg: ": "(all_parsers)","comments: ": ""},"func7": {"source file: ": "test_header1.py","line number: ": "102","func name: ": "test_header_not_first_line","func arg: ": "(all_parsers)","comments: ": ""},"func8": {"source file: ": "test_header1.py","line number: ": "122","func name: ": "test_header_multi_index","func arg: ": "(all_parsers)","comments: ": ""},"func9": {"source file: ": "test_header1.py","line number: ": "164","func name: ": "test_header_multi_index_invalid","func arg: ": "(all_parsers, kwargs, msg)","comments: ": ""},"func10": {"source file: ": "test_header1.py","line number: ": "215","func name: ": "test_header_multi_index_common_format1","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func11": {"source file: ": "test_header1.py","line number: ": "262","func name: ": "test_header_multi_index_common_format2","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func12": {"source file: ": "test_header1.py","line number: ": "308","func name: ": "test_header_multi_index_common_format3","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func13": {"source file: ": "test_header1.py","line number: ": "327","func name: ": "test_header_multi_index_common_format_malformed1","func arg: ": "(all_parsers)","comments: ": ""},"func14": {"source file: ": "test_header1.py","line number: ": "347","func name: ": "test_header_multi_index_common_format_malformed2","func arg: ": "(all_parsers)","comments: ": ""},"func15": {"source file: ": "test_header1.py","line number: ": "368","func name: ": "test_header_multi_index_common_format_malformed3","func arg: ": "(all_parsers)","comments: ": ""},"func16": {"source file: ": "test_header1.py","line number: ": "391","func name: ": "test_header_names_backward_compat","func arg: ": "(all_parsers, data, header)","comments: ": ""},"func17": {"source file: ": "test_header1.py","line number: ": "401","func name: ": "test_read_only_header_no_rows","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func18": {"source file: ": "test_header1.py","line number: ": "421","func name: ": "test_no_header","func arg: ": "(all_parsers, kwargs, names)","comments: ": ""},"func19": {"source file: ": "test_header1.py","line number: ": "435","func name: ": "test_non_int_header","func arg: ": "(all_parsers, header)","comments: ": ""},"func20": {"source file: ": "test_header1.py","line number: ": "445","func name: ": "test_singleton_header","func arg: ": "(all_parsers)","comments: ": ""},"func21": {"source file: ": "test_header1.py","line number: ": "493","func name: ": "test_mangles_multi_index","func arg: ": "(all_parsers, data, expected)","comments: ": ""},"func22": {"source file: ": "test_header1.py","line number: ": "505","func name: ": "test_multi_index_unnamed","func arg: ": "(all_parsers, index_col, columns)","comments: ": ""},"func23": {"source file: ": "test_header1.py","line number: ": "545","func name: ": "test_read_csv_multiindex_columns","func arg: ": "(all_parsers)","comments: ": ""}}{}{"func1": {"source file: ": "test_holiday1.py","line number: ": "29","func name: ": "_check_holiday_results","func arg: ": "(holiday, start, end, expected)","comments: ": "Check that the dates for a given holiday match in date and timezone.\n\nParameters ---------- holiday : Holiday The holiday to check. start : datetime-like The start date of range in which to collect dates for a given holiday. end : datetime-like The end date of range in which to collect dates for a given holiday. expected : list The list of dates we expect to get.\n"},"func2": {"source file: ": "test_holiday1.py","line number: ": "143","func name: ": "test_holiday_dates","func arg: ": "(holiday, start_date, end_date, expected)","comments: ": ""},"func3": {"source file: ": "test_holiday1.py","line number: ": "182","func name: ": "test_holidays_within_dates","func arg: ": "(holiday, start, expected)","comments: ": ""},"func4": {"source file: ": "test_holiday1.py","line number: ": "201","func name: ": "test_argument_types","func arg: ": "(transform)","comments: ": ""},"func5": {"source file: ": "test_holiday1.py","line number: ": "226","func name: ": "test_special_holidays","func arg: ": "(name, kwargs)","comments: ": ""},"func6": {"source file: ": "test_holiday1.py","line number: ": "236","func name: ": "test_get_calendar","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_holiday1.py","line number: ": "244","func name: ": "test_factory","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_holiday1.py","line number: ": "258","func name: ": "test_both_offset_observance_raises","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_html1.py","line number: ": "35","func name: ": "html_encoding_file","func arg: ": "(request, datapath)","comments: ": "Parametrized fixture for HTML encoding test filenames.\n\n\n"},"func2": {"source file: ": "test_html1.py","line number: ": "40","func name: ": "assert_framelist_equal","func arg: ": "(list1, list2, **kwargs)","comments: ": ""},"func3": {"source file: ": "test_html1.py","line number: ": "61","func name: ": "test_bs4_version_fails","func arg: ": "(monkeypatch, datapath)","comments: ": ""},"func4": {"source file: ": "test_html1.py","line number: ": "69","func name: ": "test_invalid_flavor","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_html1.py","line number: ": "80","func name: ": "test_same_ordering","func arg: ": "(datapath)","comments: ": ""}}{"func1": {"source file: ": "test_iloc1.py","line number: ": "9","func name: ": "simple_multiindex_dataframe","func arg: ": "()","comments: ": "Factory function to create simple 3 x 3 dataframe with both columns and row MultiIndex using supplied data or random data by default.\n\n\n"},"func2": {"source file: ": "test_iloc1.py","line number: ": "43","func name: ": "test_iloc_returns_series","func arg: ": "(indexer, expected, simple_multiindex_dataframe)","comments: ": ""},"func3": {"source file: ": "test_iloc1.py","line number: ": "51","func name: ": "test_iloc_returns_dataframe","func arg: ": "(simple_multiindex_dataframe)","comments: ": ""},"func4": {"source file: ": "test_iloc1.py","line number: ": "58","func name: ": "test_iloc_returns_scalar","func arg: ": "(simple_multiindex_dataframe)","comments: ": ""},"func5": {"source file: ": "test_iloc1.py","line number: ": "66","func name: ": "test_iloc_getitem_multiple_items","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_iloc1.py","line number: ": "76","func name: ": "test_iloc_getitem_labels","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_iloc1.py","line number: ": "89","func name: ": "test_frame_getitem_slice","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func8": {"source file: ": "test_iloc1.py","line number: ": "96","func name: ": "test_frame_setitem_slice","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func9": {"source file: ": "test_iloc1.py","line number: ": "104","func name: ": "test_indexing_ambiguity_bug_1678","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_iloc1.py","line number: ": "118","func name: ": "test_iloc_integer_locations","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_iloc1.py","line number: ": "153","func name: ": "test_iloc_setitem_int_multiindex_series","func arg: ": "(data, indexes, values, expected_k)","comments: ": ""},"func12": {"source file: ": "test_iloc1.py","line number: ": "167","func name: ": "test_getitem_iloc","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""}}{}{"func1": {"source file: ": "test_iloc3.py","line number: ": "7","func name: ": "test_iloc","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_iloc3.py","line number: ": "30","func name: ": "test_iloc_nonunique","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_index_as_string1.py","line number: ": "9","func name: ": "frame","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_index_as_string1.py","line number: ": "26","func name: ": "series","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_index_as_string1.py","line number: ": "49","func name: ": "test_grouper_index_level_as_string","func arg: ": "(frame, key_strs, groupers)","comments: ": ""},"func4": {"source file: ": "test_index_as_string1.py","line number: ": "70","func name: ": "test_grouper_index_level_as_string_series","func arg: ": "(series, levels)","comments: ": ""}}{"func1": {"source file: ": "test_index_col1.py","line number: ": "16","func name: ": "test_index_col_named","func arg: ": "(all_parsers, with_header)","comments: ": ""},"func2": {"source file: ": "test_index_col1.py","line number: ": "41","func name: ": "test_index_col_named2","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_index_col1.py","line number: ": "59","func name: ": "test_index_col_is_true","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_index_col1.py","line number: ": "69","func name: ": "test_infer_index_col","func arg: ": "(all_parsers)","comments: ": ""},"func5": {"source file: ": "test_index_col1.py","line number: ": "121","func name: ": "test_index_col_empty_data","func arg: ": "(all_parsers, index_col, kwargs)","comments: ": ""},"func6": {"source file: ": "test_index_col1.py","line number: ": "130","func name: ": "test_empty_with_index_col_false","func arg: ": "(all_parsers)","comments: ": ""},"func7": {"source file: ": "test_index_col1.py","line number: ": "150","func name: ": "test_multi_index_naming","func arg: ": "(all_parsers, index_names)","comments: ": ""},"func8": {"source file: ": "test_index_col1.py","line number: ": "164","func name: ": "test_multi_index_naming_not_all_at_beginning","func arg: ": "(all_parsers)","comments: ": ""},"func9": {"source file: ": "test_index_col1.py","line number: ": "178","func name: ": "test_no_multi_index_level_names_empty","func arg: ": "(all_parsers)","comments: ": ""}}{}{"func1": {"source file: ": "test_indexing_slow1.py","line number: ": "13","func name: ": "test_multiindex_get_loc","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_indexing_slow1.py","line number: ": "89","func name: ": "test_large_mi_dataframe_indexing","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_indexing2.py","line number: ": "2310","func name: ": "test_object_casting_indexing_wraps_datetimelike","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_indexing3.py","line number: ": "230","func name: ": "test_mask_with_boolean","func arg: ": "(index)","comments: ": ""},"func2": {"source file: ": "test_indexing3.py","line number: ": "243","func name: ": "test_mask_with_boolean_na_treated_as_false","func arg: ": "(index)","comments: ": ""},"func3": {"source file: ": "test_indexing3.py","line number: ": "257","func name: ": "non_coercible_categorical","func arg: ": "(monkeypatch)","comments: ": "Monkeypatch Categorical.__array__ to ensure no implicit conversion.\n\n\n"},"func4": {"source file: ": "test_indexing3.py","line number: ": "276","func name: ": "test_series_at","func arg: ": "(non_coercible_categorical)","comments: ": ""}}{"func1": {"source file: ": "test_indexing4.py","line number: ": "1063","func name: ": "test_validate_indices_ok","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_indexing4.py","line number: ": "1070","func name: ": "test_validate_indices_low","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_indexing4.py","line number: ": "1076","func name: ": "test_validate_indices_high","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_indexing4.py","line number: ": "1082","func name: ": "test_validate_indices_empty","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_indexing4.py","line number: ": "1087","func name: ": "test_extension_array_cross_section","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_indexing4.py","line number: ": "1106","func name: ": "test_extension_array_cross_section_converts","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_indexing4.py","line number: ": "1135","func name: ": "test_ndframe_indexing_raises","func arg: ": "(idxr, error, error_message)","comments: ": ""},"func8": {"source file: ": "test_indexing4.py","line number: ": "1142","func name: ": "test_readonly_indices","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_indexing4.py","line number: ": "1157","func name: ": "test_1tuple_without_multiindex","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_indexing4.py","line number: ": "1166","func name: ": "test_duplicate_index_mistyped_key_raises_keyerror","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_indexing4.py","line number: ": "1179","func name: ": "test_setitem_with_bool_mask_and_values_matching_n_trues_in_length","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_indexing7.py","line number: ": "19","func name: ": "test_slice_locs_partial","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_indexing7.py","line number: ": "35","func name: ": "test_slice_locs","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_indexing7.py","line number: ": "55","func name: ": "test_slice_locs_with_type_mismatch","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_indexing7.py","line number: ": "73","func name: ": "test_slice_locs_not_sorted","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_indexing7.py","line number: ": "92","func name: ": "test_slice_locs_not_contained","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_indexing7.py","line number: ": "119","func name: ": "test_putmask_with_wrong_mask","func arg: ": "(idx)","comments: ": ""},"func7": {"source file: ": "test_indexing7.py","line number: ": "133","func name: ": "test_get_indexer","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_indexing7.py","line number: ": "186","func name: ": "test_get_indexer_nearest","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_indexing7.py","line number: ": "196","func name: ": "test_getitem","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_indexing7.py","line number: ": "213","func name: ": "test_getitem_group_select","func arg: ": "(idx)","comments: ": ""},"func11": {"source file: ": "test_indexing7.py","line number: ": "219","func name: ": "test_get_indexer_consistency","func arg: ": "(idx)","comments: ": ""},"func12": {"source file: ": "test_indexing7.py","line number: ": "243","func name: ": "test_getitem_bool_index_all","func arg: ": "(ind1, ind2)","comments: ": ""},"func13": {"source file: ": "test_indexing7.py","line number: ": "254","func name: ": "test_getitem_bool_index_single","func arg: ": "(ind1, ind2)","comments: ": ""},"func14": {"source file: ": "test_indexing7.py","line number: ": "266","func name: ": "test_get_loc","func arg: ": "(idx)","comments: ": ""},"func15": {"source file: ": "test_indexing7.py","line number: ": "292","func name: ": "test_get_loc_duplicates","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_indexing7.py","line number: ": "305","func name: ": "test_get_loc_level","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_indexing7.py","line number: ": "346","func name: ": "test_get_loc_multiple_dtypes","func arg: ": "(dtype1, dtype2)","comments: ": ""},"func18": {"source file: ": "test_indexing7.py","line number: ": "355","func name: ": "test_get_loc_implicit_cast","func arg: ": "(level, dtypes)","comments: ": ""},"func19": {"source file: ": "test_indexing7.py","line number: ": "366","func name: ": "test_get_loc_cast_bool","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_indexing7.py","line number: ": "381","func name: ": "test_get_loc_nan","func arg: ": "(level, nulls_fixture)","comments: ": ""},"func21": {"source file: ": "test_indexing7.py","line number: ": "391","func name: ": "test_get_loc_missing_nan","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_indexing7.py","line number: ": "404","func name: ": "test_get_indexer_categorical_time","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_indexing7.py","line number: ": "416","func name: ": "test_timestamp_multiindex_indexer","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_indexing7.py","line number: ": "443","func name: ": "test_get_loc_with_values_including_missing_values","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_indexing7.py","line number: ": "475","func name: ": "test_get_indexer_with_missing_value","func arg: ": "(index_arr, labels, expected)","comments: ": ""},"func26": {"source file: ": "test_indexing7.py","line number: ": "490","func name: ": "test_get_slice_bound_with_missing_value","func arg: ": "(index_arr, expected, target, algo)","comments: ": ""},"func27": {"source file: ": "test_indexing7.py","line number: ": "506","func name: ": "test_slice_indexer_with_missing_value","func arg: ": "(index_arr, expected, start_idx, end_idx)","comments: ": ""},"func28": {"source file: ": "test_indexing7.py","line number: ": "524","func name: ": "test_slice_locs_with_missing_value","func arg: ": "(index_arr, expected, start_idx, end_idx)","comments: ": ""}}{"func1": {"source file: ": "test_indexing8.py","line number: ": "17","func name: ": "test_basic_indexing","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_indexing8.py","line number: ": "40","func name: ": "test_basic_getitem_with_labels","func arg: ": "(datetime_series)","comments: ": ""},"func3": {"source file: ": "test_indexing8.py","line number: ": "75","func name: ": "test_getitem_setitem_ellipsis","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_indexing8.py","line number: ": "87","func name: ": "test_getitem_get","func arg: ": "(datetime_series, string_series, object_series)","comments: ": ""},"func5": {"source file: ": "test_indexing8.py","line number: ": "115","func name: ": "test_getitem_fancy","func arg: ": "(string_series, object_series)","comments: ": ""},"func6": {"source file: ": "test_indexing8.py","line number: ": "124","func name: ": "test_getitem_generator","func arg: ": "(string_series)","comments: ": ""},"func7": {"source file: ": "test_indexing8.py","line number: ": "133","func name: ": "test_type_promotion","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_indexing8.py","line number: ": "158","func name: ": "test_getitem_with_duplicates_indices","func arg: ": "(result_1, duplicate_item, expected_1)","comments: ": ""},"func9": {"source file: ": "test_indexing8.py","line number: ": "166","func name: ": "test_getitem_out_of_bounds","func arg: ": "(datetime_series)","comments: ": ""},"func10": {"source file: ": "test_indexing8.py","line number: ": "178","func name: ": "test_getitem_setitem_integers","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_indexing8.py","line number: ": "187","func name: ": "test_getitem_box_float64","func arg: ": "(datetime_series)","comments: ": ""},"func12": {"source file: ": "test_indexing8.py","line number: ": "196","func name: ": "test_get","func arg: ": "(arr)","comments: ": ""},"func13": {"source file: ": "test_indexing8.py","line number: ": "232","func name: ": "test_series_box_timestamp","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_indexing8.py","line number: ": "245","func name: ": "test_getitem_ambiguous_keyerror","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_indexing8.py","line number: ": "253","func name: ": "test_getitem_unordered_dup","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_indexing8.py","line number: ": "259","func name: ": "test_getitem_dups_with_missing","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_indexing8.py","line number: ": "270","func name: ": "test_getitem_dups","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_indexing8.py","line number: ": "277","func name: ": "test_setitem_ambiguous_keyerror","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_indexing8.py","line number: ": "292","func name: ": "test_getitem_dataframe","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_indexing8.py","line number: ": "304","func name: ": "test_setitem","func arg: ": "(datetime_series, string_series)","comments: ": ""},"func21": {"source file: ": "test_indexing8.py","line number: ": "340","func name: ": "test_setitem_dtypes","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_indexing8.py","line number: ": "366","func name: ": "test_set_value","func arg: ": "(datetime_series, string_series)","comments: ": ""},"func23": {"source file: ": "test_indexing8.py","line number: ": "385","func name: ": "test_setslice","func arg: ": "(datetime_series)","comments: ": ""},"func24": {"source file: ": "test_indexing8.py","line number: ": "391","func name: ": "test_2d_to_1d_assignment_raises","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_indexing8.py","line number: ": "409","func name: ": "test_basic_getitem_setitem_corner","func arg: ": "(datetime_series)","comments: ": ""},"func26": {"source file: ": "test_indexing8.py","line number: ": "431","func name: ": "test_setitem_with_tz","func arg: ": "(tz)","comments: ": ""},"func27": {"source file: ": "test_indexing8.py","line number: ": "481","func name: ": "test_setitem_with_tz_dst","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_indexing8.py","line number: ": "533","func name: ": "test_categorical_assigning_ops","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_indexing8.py","line number: ": "568","func name: ": "test_slice","func arg: ": "(string_series, object_series)","comments: ": ""},"func30": {"source file: ": "test_indexing8.py","line number: ": "589","func name: ": "test_slice_can_reorder_not_uniquely_indexed","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_indexing8.py","line number: ": "594","func name: ": "test_loc_setitem","func arg: ": "(string_series)","comments: ": ""},"func32": {"source file: ": "test_indexing8.py","line number: ": "621","func name: ": "test_setitem_na","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_indexing8.py","line number: ": "640","func name: ": "test_timedelta_assignment","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_indexing8.py","line number: ": "673","func name: ": "test_dt64_series_assign_nat","func arg: ": "(nat_val, should_cast, tz)","comments: ": ""},"func35": {"source file: ": "test_indexing8.py","line number: ": "704","func name: ": "test_td64_series_assign_nat","func arg: ": "(nat_val, should_cast)","comments: ": ""},"func36": {"source file: ": "test_indexing8.py","line number: ": "734","func name: ": "test_append_timedelta_does_not_cast","func arg: ": "(td)","comments: ": ""},"func37": {"source file: ": "test_indexing8.py","line number: ": "749","func name: ": "test_underlying_data_conversion","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_indexing8.py","line number: ": "788","func name: ": "test_preserve_refs","func arg: ": "(datetime_series)","comments: ": ""},"func39": {"source file: ": "test_indexing8.py","line number: ": "794","func name: ": "test_cast_on_putmask","func arg: ": "()","comments: ": ""},"func40": {"source file: ": "test_indexing8.py","line number: ": "805","func name: ": "test_type_promote_putmask","func arg: ": "()","comments: ": ""},"func41": {"source file: ": "test_indexing8.py","line number: ": "826","func name: ": "test_multilevel_preserve_name","func arg: ": "()","comments: ": ""},"func42": {"source file: ": "test_indexing8.py","line number: ": "840","func name: ": "test_setitem_scalar_into_readonly_backing_data","func arg: ": "()","comments: ": ""},"func43": {"source file: ": "test_indexing8.py","line number: ": "855","func name: ": "test_setitem_slice_into_readonly_backing_data","func arg: ": "()","comments: ": ""},"func44": {"source file: ": "test_indexing8.py","line number: ": "874","func name: ": "test_pop","func arg: ": "()","comments: ": ""},"func45": {"source file: ": "test_indexing8.py","line number: ": "886","func name: ": "test_take","func arg: ": "()","comments: ": ""},"func46": {"source file: ": "test_indexing8.py","line number: ": "904","func name: ": "test_take_categorical","func arg: ": "()","comments: ": ""},"func47": {"source file: ": "test_indexing8.py","line number: ": "914","func name: ": "test_head_tail","func arg: ": "(string_series)","comments: ": ""},"func48": {"source file: ": "test_indexing8.py","line number: ": "921","func name: ": "test_uint_drop","func arg: ": "(any_int_dtype)","comments: ": ""},"func49": {"source file: ": "test_indexing8.py","line number: ": "930","func name: ": "test_getitem_2d_no_warning","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_infer_datetimelike1.py","line number: ": "15","func name: ": "test_maybe_infer_to_datetimelike_df_construct","func arg: ": "(data, exp_size)","comments: ": ""},"func2": {"source file: ": "test_infer_datetimelike1.py","line number: ": "20","func name: ": "test_maybe_infer_to_datetimelike_ser_construct","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_infer_dtype1.py","line number: ": "26","func name: ": "pandas_dtype","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_infer_dtype1.py","line number: ": "30","func name: ": "test_infer_dtype_from_int_scalar","func arg: ": "(any_int_dtype)","comments: ": ""},"func3": {"source file: ": "test_infer_dtype1.py","line number: ": "38","func name: ": "test_infer_dtype_from_float_scalar","func arg: ": "(float_dtype)","comments: ": ""},"func4": {"source file: ": "test_infer_dtype1.py","line number: ": "47","func name: ": "test_infer_dtype_from_python_scalar","func arg: ": "(data, exp_dtype)","comments: ": ""},"func5": {"source file: ": "test_infer_dtype1.py","line number: ": "53","func name: ": "test_infer_dtype_from_boolean","func arg: ": "(bool_val)","comments: ": ""},"func6": {"source file: ": "test_infer_dtype1.py","line number: ": "58","func name: ": "test_infer_dtype_from_complex","func arg: ": "(complex_dtype)","comments: ": ""},"func7": {"source file: ": "test_infer_dtype1.py","line number: ": "67","func name: ": "test_infer_dtype_from_datetime","func arg: ": "(data)","comments: ": ""},"func8": {"source file: ": "test_infer_dtype1.py","line number: ": "73","func name: ": "test_infer_dtype_from_timedelta","func arg: ": "(data)","comments: ": ""},"func9": {"source file: ": "test_infer_dtype1.py","line number: ": "79","func name: ": "test_infer_dtype_from_period","func arg: ": "(freq, pandas_dtype)","comments: ": ""},"func10": {"source file: ": "test_infer_dtype1.py","line number: ": "97","func name: ": "test_infer_dtype_misc","func arg: ": "(data)","comments: ": ""},"func11": {"source file: ": "test_infer_dtype1.py","line number: ": "103","func name: ": "test_infer_from_scalar_tz","func arg: ": "(tz, pandas_dtype)","comments: ": ""},"func12": {"source file: ": "test_infer_dtype1.py","line number: ": "128","func name: ": "test_infer_from_interval","func arg: ": "(left, right, subtype, closed, pandas_dtype)","comments: ": ""},"func13": {"source file: ": "test_infer_dtype1.py","line number: ": "137","func name: ": "test_infer_dtype_from_scalar_errors","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_infer_dtype1.py","line number: ": "176","func name: ": "test_infer_dtype_from_array","func arg: ": "(arr, expected, pandas_dtype)","comments: ": ""},"func15": {"source file: ": "test_infer_dtype1.py","line number: ": "191","func name: ": "test_cast_scalar_to_array","func arg: ": "(obj, dtype)","comments: ": ""}}{"func1": {"source file: ": "test_inference1.py","line number: ": "18","func name: ": "_check_generated_range","func arg: ": "(start, periods, freq)","comments: ": "Check the range generated from a given start, frequency, and period count.\n\nParameters ---------- start : str The start date. periods : int The number of periods. freq : str The frequency of the range.\n"},"func2": {"source file: ": "test_inference1.py","line number: ": "73","func name: ": "base_delta_code_pair","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_inference1.py","line number: ": "78","func name: ": "count","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "test_inference1.py","line number: ": "83","func name: ": "day","func arg: ": "(request)","comments: ": ""},"func5": {"source file: ": "test_inference1.py","line number: ": "88","func name: ": "month","func arg: ": "(request)","comments: ": ""},"func6": {"source file: ": "test_inference1.py","line number: ": "93","func name: ": "periods","func arg: ": "(request)","comments: ": ""},"func7": {"source file: ": "test_inference1.py","line number: ": "97","func name: ": "test_raise_if_period_index","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_inference1.py","line number: ": "105","func name: ": "test_raise_if_too_few","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_inference1.py","line number: ": "113","func name: ": "test_business_daily","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_inference1.py","line number: ": "118","func name: ": "test_business_daily_look_alike","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_inference1.py","line number: ": "126","func name: ": "test_day_corner","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_inference1.py","line number: ": "131","func name: ": "test_non_datetime_index","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_inference1.py","line number: ": "136","func name: ": "test_fifth_week_of_month_infer","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_inference1.py","line number: ": "144","func name: ": "test_week_of_month_fake","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_inference1.py","line number: ": "151","func name: ": "test_fifth_week_of_month","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_inference1.py","line number: ": "164","func name: ": "test_monthly_ambiguous","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_inference1.py","line number: ": "169","func name: ": "test_annual_ambiguous","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_inference1.py","line number: ": "174","func name: ": "test_infer_freq_delta","func arg: ": "(base_delta_code_pair, count)","comments: ": ""},"func19": {"source file: ": "test_inference1.py","line number: ": "196","func name: ": "test_infer_freq_custom","func arg: ": "(base_delta_code_pair, constructor)","comments: ": ""},"func20": {"source file: ": "test_inference1.py","line number: ": "204","func name: ": "test_weekly_infer","func arg: ": "(periods, day)","comments: ": ""},"func21": {"source file: ": "test_inference1.py","line number: ": "208","func name: ": "test_week_of_month_infer","func arg: ": "(periods, day, count)","comments: ": ""},"func22": {"source file: ": "test_inference1.py","line number: ": "215","func name: ": "test_monthly_infer","func arg: ": "(periods, freq)","comments: ": ""},"func23": {"source file: ": "test_inference1.py","line number: ": "219","func name: ": "test_quarterly_infer","func arg: ": "(month, periods)","comments: ": ""},"func24": {"source file: ": "test_inference1.py","line number: ": "224","func name: ": "test_annually_infer","func arg: ": "(month, periods, annual)","comments: ": ""},"func25": {"source file: ": "test_inference1.py","line number: ": "233","func name: ": "test_infer_freq_index","func arg: ": "(freq, expected)","comments: ": ""},"func26": {"source file: ": "test_inference1.py","line number: ": "258","func name: ": "test_infer_freq_tz","func arg: ": "(tz_naive_fixture, expected, dates)","comments: ": ""},"func27": {"source file: ": "test_inference1.py","line number: ": "276","func name: ": "test_infer_freq_tz_transition","func arg: ": "(tz_naive_fixture, date_pair, freq)","comments: ": ""},"func28": {"source file: ": "test_inference1.py","line number: ": "283","func name: ": "test_infer_freq_tz_transition_custom","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_inference1.py","line number: ": "368","func name: ": "test_infer_freq_business_hour","func arg: ": "(data, expected)","comments: ": ""},"func30": {"source file: ": "test_inference1.py","line number: ": "374","func name: ": "test_not_monotonic","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_inference1.py","line number: ": "381","func name: ": "test_non_datetime_index2","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_inference1.py","line number: ": "392","func name: ": "test_invalid_index_types","func arg: ": "(idx)","comments: ": ""},"func33": {"source file: ": "test_inference1.py","line number: ": "404","func name: ": "test_invalid_index_types_unicode","func arg: ": "(idx)","comments: ": ""},"func34": {"source file: ": "test_inference1.py","line number: ": "414","func name: ": "test_string_datetime_like_compat","func arg: ": "()","comments: ": ""},"func35": {"source file: ": "test_inference1.py","line number: ": "424","func name: ": "test_series","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_inference1.py","line number: ": "432","func name: ": "test_series_invalid_type","func arg: ": "(end)","comments: ": ""},"func37": {"source file: ": "test_inference1.py","line number: ": "441","func name: ": "test_series_inconvertible_string","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_inference1.py","line number: ": "450","func name: ": "test_series_period_index","func arg: ": "(freq)","comments: ": ""},"func39": {"source file: ": "test_inference1.py","line number: ": "462","func name: ": "test_series_datetime_index","func arg: ": "(freq)","comments: ": ""},"func40": {"source file: ": "test_inference1.py","line number: ": "525","func name: ": "test_legacy_offset_warnings","func arg: ": "(offset_func, freq)","comments: ": ""},"func41": {"source file: ": "test_inference1.py","line number: ": "530","func name: ": "test_ms_vs_capital_ms","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_inference2.py","line number: ": "60","func name: ": "coerce","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_inference2.py","line number: ": "112","func name: ": "maybe_list_like","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_inference2.py","line number: ": "116","func name: ": "test_is_list_like","func arg: ": "(maybe_list_like)","comments: ": ""},"func4": {"source file: ": "test_inference2.py","line number: ": "122","func name: ": "test_is_list_like_disallow_sets","func arg: ": "(maybe_list_like)","comments: ": ""},"func5": {"source file: ": "test_inference2.py","line number: ": "128","func name: ": "test_is_sequence","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_inference2.py","line number: ": "142","func name: ": "test_is_array_like","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_inference2.py","line number: ": "175","func name: ": "test_is_nested_list_like_passes","func arg: ": "(inner, outer)","comments: ": ""},"func8": {"source file: ": "test_inference2.py","line number: ": "196","func name: ": "test_is_nested_list_like_fails","func arg: ": "(obj)","comments: ": ""},"func9": {"source file: ": "test_inference2.py","line number: ": "201","func name: ": "test_is_dict_like_passes","func arg: ": "(ll)","comments: ": ""},"func10": {"source file: ": "test_inference2.py","line number: ": "219","func name: ": "test_is_dict_like_fails","func arg: ": "(ll)","comments: ": ""},"func11": {"source file: ": "test_inference2.py","line number: ": "226","func name: ": "test_is_dict_like_duck_type","func arg: ": "(has_keys, has_getitem, has_contains)","comments: ": ""},"func12": {"source file: ": "test_inference2.py","line number: ": "253","func name: ": "test_is_file_like","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_inference2.py","line number: ": "297","func name: ": "test_is_names_tuple_passes","func arg: ": "(ll)","comments: ": ""},"func14": {"source file: ": "test_inference2.py","line number: ": "302","func name: ": "test_is_names_tuple_fails","func arg: ": "(ll)","comments: ": ""},"func15": {"source file: ": "test_inference2.py","line number: ": "306","func name: ": "test_is_hashable","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_inference2.py","line number: ": "337","func name: ": "test_is_re_passes","func arg: ": "(ll)","comments: ": ""},"func17": {"source file: ": "test_inference2.py","line number: ": "342","func name: ": "test_is_re_fails","func arg: ": "(ll)","comments: ": ""},"func18": {"source file: ": "test_inference2.py","line number: ": "349","func name: ": "test_is_recompilable_passes","func arg: ": "(ll)","comments: ": ""},"func19": {"source file: ": "test_inference2.py","line number: ": "354","func name: ": "test_is_recompilable_fails","func arg: ": "(ll)","comments: ": ""},"func20": {"source file: ": "test_inference2.py","line number: ": "1439","func name: ": "test_datetimeindex_from_empty_datetime64_array","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_inference2.py","line number: ": "1445","func name: ": "test_nan_to_nat_conversions","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_inference2.py","line number: ": "1463","func name: ": "test_is_scipy_sparse","func arg: ": "(spmatrix)","comments: ": ""},"func23": {"source file: ": "test_inference2.py","line number: ": "1468","func name: ": "test_ensure_int32","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_inference2.py","line number: ": "1478","func name: ": "test_ensure_categorical","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_integer1.py","line number: ": "37","func name: ": "make_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_integer1.py","line number: ": "53","func name: ": "dtype","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_integer1.py","line number: ": "58","func name: ": "data","func arg: ": "(dtype)","comments: ": ""},"func4": {"source file: ": "test_integer1.py","line number: ": "63","func name: ": "data_for_twos","func arg: ": "(dtype)","comments: ": ""},"func5": {"source file: ": "test_integer1.py","line number: ": "68","func name: ": "data_missing","func arg: ": "(dtype)","comments: ": ""},"func6": {"source file: ": "test_integer1.py","line number: ": "73","func name: ": "data_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func7": {"source file: ": "test_integer1.py","line number: ": "78","func name: ": "data_missing_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func8": {"source file: ": "test_integer1.py","line number: ": "83","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_integer1.py","line number: ": "89","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_integer1.py","line number: ": "94","func name: ": "data_for_grouping","func arg: ": "(dtype)","comments: ": ""}}{"func1": {"source file: ": "test_integer2.py","line number: ": "25","func name: ": "make_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_integer2.py","line number: ": "41","func name: ": "dtype","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_integer2.py","line number: ": "46","func name: ": "data","func arg: ": "(dtype)","comments: ": ""},"func4": {"source file: ": "test_integer2.py","line number: ": "51","func name: ": "data_missing","func arg: ": "(dtype)","comments: ": ""},"func5": {"source file: ": "test_integer2.py","line number: ": "56","func name: ": "all_data","func arg: ": "(request, data, data_missing)","comments: ": "Parametrized fixture giving 'data' and 'data_missing'\n\n\n"},"func6": {"source file: ": "test_integer2.py","line number: ": "64","func name: ": "test_dtypes","func arg: ": "(dtype)","comments: ": ""},"func7": {"source file: ": "test_integer2.py","line number: ": "87","func name: ": "test_repr_dtype","func arg: ": "(dtype, expected)","comments: ": ""},"func8": {"source file: ": "test_integer2.py","line number: ": "91","func name: ": "test_repr_array","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_integer2.py","line number: ": "97","func name: ": "test_repr_array_long","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_integer2.py","line number: ": "691","func name: ": "test_frame_repr","func arg: ": "(data_missing)","comments: ": ""},"func11": {"source file: ": "test_integer2.py","line number: ": "699","func name: ": "test_conversions","func arg: ": "(data_missing)","comments: ": ""},"func12": {"source file: ": "test_integer2.py","line number: ": "725","func name: ": "test_integer_array_constructor","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_integer2.py","line number: ": "755","func name: ": "test_integer_array_constructor_none_is_nan","func arg: ": "(a, b)","comments: ": ""},"func14": {"source file: ": "test_integer2.py","line number: ": "761","func name: ": "test_integer_array_constructor_copy","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_integer2.py","line number: ": "788","func name: ": "test_to_integer_array_error","func arg: ": "(values)","comments: ": ""},"func16": {"source file: ": "test_integer2.py","line number: ": "794","func name: ": "test_to_integer_array_inferred_dtype","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_integer2.py","line number: ": "806","func name: ": "test_to_integer_array_dtype_keyword","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_integer2.py","line number: ": "815","func name: ": "test_to_integer_array_float","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_integer2.py","line number: ": "836","func name: ": "test_to_integer_array_bool","func arg: ": "(bool_values, int_values, target_dtype, expected_dtype)","comments: ": ""},"func20": {"source file: ": "test_integer2.py","line number: ": "851","func name: ": "test_to_integer_array","func arg: ": "(values, to_dtype, result_dtype)","comments: ": ""},"func21": {"source file: ": "test_integer2.py","line number: ": "859","func name: ": "test_cross_type_arithmetic","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_integer2.py","line number: ": "883","func name: ": "test_preserve_dtypes","func arg: ": "(op)","comments: ": ""},"func23": {"source file: ": "test_integer2.py","line number: ": "910","func name: ": "test_reduce_to_float","func arg: ": "(op)","comments: ": ""},"func24": {"source file: ": "test_integer2.py","line number: ": "935","func name: ": "test_astype_nansafe","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_integer2.py","line number: ": "945","func name: ": "test_ufuncs_single_int","func arg: ": "(ufunc)","comments: ": ""},"func26": {"source file: ": "test_integer2.py","line number: ": "958","func name: ": "test_ufuncs_single_float","func arg: ": "(ufunc)","comments: ": ""},"func27": {"source file: ": "test_integer2.py","line number: ": "973","func name: ": "test_ufuncs_binary_int","func arg: ": "(ufunc)","comments: ": ""},"func28": {"source file: ": "test_integer2.py","line number: ": "1001","func name: ": "test_ufunc_reduce_raises","func arg: ": "(values)","comments: ": ""},"func29": {"source file: ": "test_integer2.py","line number: ": "1008","func name: ": "test_arrow_array","func arg: ": "(data)","comments: ": ""},"func30": {"source file: ": "test_integer2.py","line number: ": "1020","func name: ": "test_arrow_roundtrip","func arg: ": "(data)","comments: ": ""},"func31": {"source file: ": "test_integer2.py","line number: ": "1032","func name: ": "test_arrow_from_arrow_uint","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_integer2.py","line number: ": "1054","func name: ": "test_stat_method","func arg: ": "(pandasmethname, kwargs)","comments: ": ""},"func33": {"source file: ": "test_integer2.py","line number: ": "1064","func name: ": "test_value_counts_na","func arg: ": "()","comments: ": ""},"func34": {"source file: ": "test_integer2.py","line number: ": "1075","func name: ": "test_array_setitem_nullable_boolean_mask","func arg: ": "()","comments: ": ""},"func35": {"source file: ": "test_integer2.py","line number: ": "1083","func name: ": "test_array_setitem","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_integrity1.py","line number: ": "13","func name: ": "test_labels_dtypes","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_integrity1.py","line number: ": "32","func name: ": "test_values_boxed","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_integrity1.py","line number: ": "48","func name: ": "test_values_multiindex_datetimeindex","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_integrity1.py","line number: ": "74","func name: ": "test_values_multiindex_periodindex","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_integrity1.py","line number: ": "98","func name: ": "test_consistency","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_integrity1.py","line number: ": "121","func name: ": "test_hash_collisions","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_integrity1.py","line number: ": "135","func name: ": "test_dims","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_integrity1.py","line number: ": "139","func name: ": "take_invalid_kwargs","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_integrity1.py","line number: ": "157","func name: ": "test_isna_behavior","func arg: ": "(idx)","comments: ": ""},"func10": {"source file: ": "test_integrity1.py","line number: ": "166","func name: ": "test_large_multiindex_error","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_integrity1.py","line number: ": "184","func name: ": "test_million_record_attribute_error","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_integrity1.py","line number: ": "196","func name: ": "test_can_hold_identifiers","func arg: ": "(idx)","comments: ": ""},"func13": {"source file: ": "test_integrity1.py","line number: ": "201","func name: ": "test_metadata_immutable","func arg: ": "(idx)","comments: ": ""},"func14": {"source file: ": "test_integrity1.py","line number: ": "220","func name: ": "test_level_setting_resets_attributes","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_integrity1.py","line number: ": "228","func name: ": "test_rangeindex_fallback_coercion_bug","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_integrity1.py","line number: ": "253","func name: ": "test_hash_error","func arg: ": "(indices)","comments: ": ""},"func17": {"source file: ": "test_integrity1.py","line number: ": "259","func name: ": "test_mutability","func arg: ": "(indices)","comments: ": ""},"func18": {"source file: ": "test_integrity1.py","line number: ": "267","func name: ": "test_wrong_number_names","func arg: ": "(indices)","comments: ": ""},"func19": {"source file: ": "test_integrity1.py","line number: ": "272","func name: ": "test_memory_usage","func arg: ": "(idx)","comments: ": ""},"func20": {"source file: ": "test_integrity1.py","line number: ": "293","func name: ": "test_nlevels","func arg: ": "(idx)","comments: ": ""}}{"func1": {"source file: ": "test_internals1.py","line number: ": "234","func name: ": "test_hasnans_unchached_for_series","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_internals2.py","line number: ": "21","func name: ": "mgr","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_internals2.py","line number: ": "29","func name: ": "assert_block_equal","func arg: ": "(left, right)","comments: ": ""},"func3": {"source file: ": "test_internals2.py","line number: ": "37","func name: ": "get_numeric_mat","func arg: ": "(shape)","comments: ": ""},"func4": {"source file: ": "test_internals2.py","line number: ": "47","func name: ": "create_block","func arg: ": "(typestr, placement, item_shape, num_offset)","comments: ": "Supported typestr\n\n* float, f8, f4, f2 * int, i8, i4, i2, i1 * uint, u8, u4, u2, u1 * complex, c16, c8 * bool * object, string, O * datetime, dt, M8[ns], M8[ns, tz] * timedelta, td, m8[ns] * sparse (SparseArray with fill_value=0.0) * sparse_na (SparseArray with fill_value=np.nan) * category, category2\n"},"func5": {"source file: ": "test_internals2.py","line number: ": "134","func name: ": "create_single_mgr","func arg: ": "(typestr, num_rows)","comments: ": ""},"func6": {"source file: ": "test_internals2.py","line number: ": "144","func name: ": "create_mgr","func arg: ": "(descr, item_shape)","comments: ": "Construct BlockManager from string description.\n\nString description syntax looks similar to np.matrix initializer.\n\nIt looks like this::\n\na,b,c: f8; d,e,f: i8\n\nRules are rather simple:\n\n* see list of supported datatypes in `create_block` method * components are semicolon-separated * each component is `NAME,NAME,NAME: DTYPE_ID` * whitespace around colons & semicolons are removed * components with same DTYPE_ID are combined into single block * to force multiple blocks with same dtype, use '-SUFFIX'::\n\n'a:f8-1; b:f8-2; c:f8-foobar'\n"},"func7": {"source file: ": "test_internals2.py","line number: ": "1239","func name: ": "test_holder","func arg: ": "(typestr, holder)","comments: ": ""},"func8": {"source file: ": "test_internals2.py","line number: ": "1244","func name: ": "test_validate_ndim","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_internals2.py","line number: ": "1253","func name: ": "test_block_shape","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_internals2.py","line number: ": "1261","func name: ": "test_make_block_no_pandas_array","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_internals2.py","line number: ": "1281","func name: ": "test_dataframe_not_equal","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_interval_range1.py","line number: ": "24","func name: ": "name","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "test_interval_tree1.py","line number: ": "12","func name: ": "skipif_32bit","func arg: ": "(param)","comments: ": "Skip parameters in a parametrize on 32bit systems. Specifically used here to skip leaf_size parameters related to GH 23440.\n\n\n"},"func2": {"source file: ": "test_interval_tree1.py","line number: ": "24","func name: ": "dtype","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_interval_tree1.py","line number: ": "29","func name: ": "leaf_size","func arg: ": "(request)","comments: ": "Fixture to specify IntervalTree leaf_size parameter; to be used with the tree fixture.\n\n\n"},"func4": {"source file: ": "test_interval_tree1.py","line number: ": "45","func name: ": "tree","func arg: ": "(request, leaf_size)","comments: ": ""}}{}{"func1": {"source file: ": "test_interval2.py","line number: ": "26","func name: ": "make_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_interval2.py","line number: ": "34","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_interval2.py","line number: ": "39","func name: ": "data","func arg: ": "()","comments: ": "Length-100 PeriodArray for semantics test.\n\n\n"},"func4": {"source file: ": "test_interval2.py","line number: ": "45","func name: ": "data_missing","func arg: ": "()","comments: ": "Length 2 array with [NA, Valid]\n\n\n"},"func5": {"source file: ": "test_interval2.py","line number: ": "51","func name: ": "data_for_sorting","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_interval2.py","line number: ": "56","func name: ": "data_missing_for_sorting","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_interval2.py","line number: ": "61","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_interval2.py","line number: ": "66","func name: ": "data_for_grouping","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_interval3.py","line number: ": "33","func name: ": "left_right_dtypes","func arg: ": "(request)","comments: ": "Fixture for building an IntervalArray from various dtypes\n\n\n"},"func2": {"source file: ": "test_interval3.py","line number: ": "116","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_interval3.py","line number: ": "136","func name: ": "test_arrow_extension_type","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_interval3.py","line number: ": "152","func name: ": "test_arrow_array","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_interval3.py","line number: ": "181","func name: ": "test_arrow_array_missing","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_interval3.py","line number: ": "215","func name: ": "test_arrow_table_roundtrip","func arg: ": "(breaks)","comments: ": ""}}{"func1": {"source file: ": "test_interval4.py","line number: ": "45","func name: ": "left_right_dtypes","func arg: ": "(request)","comments: ": "Fixture for building an IntervalArray from various dtypes\n\n\n"},"func2": {"source file: ": "test_interval4.py","line number: ": "53","func name: ": "array","func arg: ": "(left_right_dtypes)","comments: ": "Fixture to generate an IntervalArray of various dtypes containing NA if possible\n\n\n"},"func3": {"source file: ": "test_interval4.py","line number: ": "61","func name: ": "create_categorical_intervals","func arg: ": "(left, right, closed)","comments: ": ""},"func4": {"source file: ": "test_interval4.py","line number: ": "65","func name: ": "create_series_intervals","func arg: ": "(left, right, closed)","comments: ": ""},"func5": {"source file: ": "test_interval4.py","line number: ": "69","func name: ": "create_series_categorical_intervals","func arg: ": "(left, right, closed)","comments: ": ""}}{"func1": {"source file: ": "test_interval5.py","line number: ": "9","func name: ": "interval","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_interval6.py","line number: ": "25","func name: ": "name","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_interval6.py","line number: ": "864","func name: ": "test_dir","func arg: ": "()","comments: ": ""}}{}{}{}{}{"func1": {"source file: ": "test_join1.py","line number: ": "9","func name: ": "frame_with_period_index","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_join1.py","line number: ": "18","func name: ": "left","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_join1.py","line number: ": "23","func name: ": "right","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_join1.py","line number: ": "70","func name: ": "test_join","func arg: ": "(left, right, how, sort, expected)","comments: ": ""},"func5": {"source file: ": "test_join1.py","line number: ": "76","func name: ": "test_join_index","func arg: ": "(float_frame)","comments: ": ""},"func6": {"source file: ": "test_join1.py","line number: ": "117","func name: ": "test_join_index_more","func arg: ": "(float_frame)","comments: ": ""},"func7": {"source file: ": "test_join1.py","line number: ": "135","func name: ": "test_join_index_series","func arg: ": "(float_frame)","comments: ": ""},"func8": {"source file: ": "test_join1.py","line number: ": "148","func name: ": "test_join_overlap","func arg: ": "(float_frame)","comments: ": ""},"func9": {"source file: ": "test_join1.py","line number: ": "163","func name: ": "test_join_period_index","func arg: ": "(frame_with_period_index)","comments: ": ""},"func10": {"source file: ": "test_join1.py","line number: ": "178","func name: ": "test_join_left_sequence_non_unique_index","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_join1.py","line number: ": "199","func name: ": "test_suppress_future_warning_with_sort_kw","func arg: ": "(sort_kw)","comments: ": ""}}{}{"func1": {"source file: ": "test_join3.py","line number: ": "12","func name: ": "test_join_level","func arg: ": "(idx, other, join_type)","comments: ": ""},"func2": {"source file: ": "test_join3.py","line number: ": "37","func name: ": "test_join_level_corner_case","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_join3.py","line number: ": "47","func name: ": "test_join_self","func arg: ": "(idx, join_type)","comments: ": ""},"func4": {"source file: ": "test_join3.py","line number: ": "52","func name: ": "test_join_multi","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_join3.py","line number: ": "86","func name: ": "test_join_self_unique","func arg: ": "(idx, join_type)","comments: ": ""},"func6": {"source file: ": "test_join3.py","line number: ": "92","func name: ": "test_join_multi_wrong_order","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_join5.py","line number: ": "46","func name: ": "test_left_join_indexer_unique","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_join5.py","line number: ": "55","func name: ": "test_left_outer_join_bug","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_join5.py","line number: ": "177","func name: ": "test_inner_join_indexer","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_join5.py","line number: ": "200","func name: ": "test_outer_join_indexer","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_join5.py","line number: ": "223","func name: ": "test_left_join_indexer","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_join5.py","line number: ": "245","func name: ": "test_left_join_indexer2","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_join5.py","line number: ": "261","func name: ": "test_outer_join_indexer2","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_join5.py","line number: ": "277","func name: ": "test_inner_join_indexer2","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_join5.py","line number: ": "293","func name: ": "test_merge_join_categorical_multiindex","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_json1.py","line number: ": "14","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_json1.py","line number: ": "19","func name: ": "data","func arg: ": "()","comments: ": "Length-100 PeriodArray for semantics test.\n\n\n"},"func3": {"source file: ": "test_json1.py","line number: ": "36","func name: ": "data_missing","func arg: ": "()","comments: ": "Length 2 array with [NA, Valid]\n\n\n"},"func4": {"source file: ": "test_json1.py","line number: ": "42","func name: ": "data_for_sorting","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_json1.py","line number: ": "47","func name: ": "data_missing_for_sorting","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_json1.py","line number: ": "52","func name: ": "na_value","func arg: ": "(dtype)","comments: ": ""},"func7": {"source file: ": "test_json1.py","line number: ": "57","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_json1.py","line number: ": "62","func name: ": "data_for_grouping","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_label_or_level_utils1.py","line number: ": "11","func name: ": "df","func arg: ": "()","comments: ": "DataFrame with columns 'L1', 'L2', and 'L3'\n\n\n"},"func2": {"source file: ": "test_label_or_level_utils1.py","line number: ": "17","func name: ": "df_levels","func arg: ": "(request, df)","comments: ": "DataFrame with columns or index levels 'L1', 'L2', and 'L3'\n\n\n"},"func3": {"source file: ": "test_label_or_level_utils1.py","line number: ": "28","func name: ": "df_ambig","func arg: ": "(df)","comments: ": "DataFrame with levels 'L1' and 'L2' and labels 'L1' and 'L3'\n\n\n"},"func4": {"source file: ": "test_label_or_level_utils1.py","line number: ": "38","func name: ": "df_duplabels","func arg: ": "(df)","comments: ": "DataFrame with level 'L1' and labels 'L2', 'L3', and 'L2'\n\n\n"},"func5": {"source file: ": "test_label_or_level_utils1.py","line number: ": "48","func name: ": "get_labels_levels","func arg: ": "(df_levels)","comments: ": ""},"func6": {"source file: ": "test_label_or_level_utils1.py","line number: ": "54","func name: ": "assert_label_reference","func arg: ": "(frame, labels, axis)","comments: ": ""},"func7": {"source file: ": "test_label_or_level_utils1.py","line number: ": "61","func name: ": "assert_level_reference","func arg: ": "(frame, levels, axis)","comments: ": ""},"func8": {"source file: ": "test_label_or_level_utils1.py","line number: ": "70","func name: ": "test_is_level_or_label_reference_df_simple","func arg: ": "(df_levels, axis)","comments: ": ""},"func9": {"source file: ": "test_label_or_level_utils1.py","line number: ": "84","func name: ": "test_is_level_reference_df_ambig","func arg: ": "(df_ambig, axis)","comments: ": ""},"func10": {"source file: ": "test_label_or_level_utils1.py","line number: ": "104","func name: ": "test_is_level_reference_series_simple_axis0","func arg: ": "(df)","comments: ": ""},"func11": {"source file: ": "test_label_or_level_utils1.py","line number: ": "117","func name: ": "test_is_level_reference_series_axis1_error","func arg: ": "(df)","comments: ": ""},"func12": {"source file: ": "test_label_or_level_utils1.py","line number: ": "131","func name: ": "test_check_label_or_level_ambiguity_df","func arg: ": "(df_ambig, axis)","comments: ": ""},"func13": {"source file: ": "test_label_or_level_utils1.py","line number: ": "156","func name: ": "test_check_label_or_level_ambiguity_series","func arg: ": "(df)","comments: ": ""},"func14": {"source file: ": "test_label_or_level_utils1.py","line number: ": "172","func name: ": "test_check_label_or_level_ambiguity_series_axis1_error","func arg: ": "(df)","comments: ": ""},"func15": {"source file: ": "test_label_or_level_utils1.py","line number: ": "183","func name: ": "assert_label_values","func arg: ": "(frame, labels, axis)","comments: ": ""},"func16": {"source file: ": "test_label_or_level_utils1.py","line number: ": "194","func name: ": "assert_level_values","func arg: ": "(frame, levels, axis)","comments: ": ""},"func17": {"source file: ": "test_label_or_level_utils1.py","line number: ": "207","func name: ": "test_get_label_or_level_values_df_simple","func arg: ": "(df_levels, axis)","comments: ": ""},"func18": {"source file: ": "test_label_or_level_utils1.py","line number: ": "221","func name: ": "test_get_label_or_level_values_df_ambig","func arg: ": "(df_ambig, axis)","comments: ": ""},"func19": {"source file: ": "test_label_or_level_utils1.py","line number: ": "234","func name: ": "test_get_label_or_level_values_df_duplabels","func arg: ": "(df_duplabels, axis)","comments: ": ""},"func20": {"source file: ": "test_label_or_level_utils1.py","line number: ": "258","func name: ": "test_get_label_or_level_values_series_axis0","func arg: ": "(df)","comments: ": ""},"func21": {"source file: ": "test_label_or_level_utils1.py","line number: ": "269","func name: ": "test_get_label_or_level_values_series_axis1_error","func arg: ": "(df)","comments: ": ""},"func22": {"source file: ": "test_label_or_level_utils1.py","line number: ": "280","func name: ": "assert_labels_dropped","func arg: ": "(frame, labels, axis)","comments: ": ""},"func23": {"source file: ": "test_label_or_level_utils1.py","line number: ": "292","func name: ": "assert_levels_dropped","func arg: ": "(frame, levels, axis)","comments: ": ""},"func24": {"source file: ": "test_label_or_level_utils1.py","line number: ": "306","func name: ": "test_drop_labels_or_levels_df","func arg: ": "(df_levels, axis)","comments: ": ""},"func25": {"source file: ": "test_label_or_level_utils1.py","line number: ": "325","func name: ": "test_drop_labels_or_levels_series","func arg: ": "(df)","comments: ": ""}}{"func1": {"source file: ": "test_lib1.py","line number: ": "194","func name: ": "test_cache_readonly_preserve_docstrings","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_libfrequencies1.py","line number: ": "33","func name: ": "test_get_rule_month","func arg: ": "(obj, expected)","comments: ": ""},"func2": {"source file: ": "test_libfrequencies1.py","line number: ": "59","func name: ": "test_period_str_to_code","func arg: ": "(obj, expected)","comments: ": ""},"func3": {"source file: ": "test_libfrequencies1.py","line number: ": "79","func name: ": "test_super_sub_symmetry","func arg: ": "(p1, p2, expected)","comments: ": ""},"func4": {"source file: ": "test_libfrequencies1.py","line number: ": "98","func name: ": "test_assert_aliases_deprecated","func arg: ": "(freq, expected, aliases)","comments: ": ""}}{"func1": {"source file: ": "test_liboffsets1.py","line number: ": "15","func name: ": "day_opt","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_liboffsets1.py","line number: ": "26","func name: ": "test_get_last_bday","func arg: ": "(dt, exp_week_day, exp_last_day)","comments: ": ""},"func3": {"source file: ": "test_liboffsets1.py","line number: ": "38","func name: ": "test_get_first_bday","func arg: ": "(dt, exp_week_day, exp_first_day)","comments: ": ""},"func4": {"source file: ": "test_liboffsets1.py","line number: ": "54","func name: ": "test_shift_month_dt","func arg: ": "(months, day_opt, expected)","comments: ": ""},"func5": {"source file: ": "test_liboffsets1.py","line number: ": "68","func name: ": "test_shift_month_ts","func arg: ": "(months, day_opt, expected)","comments: ": ""},"func6": {"source file: ": "test_liboffsets1.py","line number: ": "73","func name: ": "test_shift_month_error","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_liboffsets1.py","line number: ": "91","func name: ": "test_roll_yearday","func arg: ": "(other, expected, n)","comments: ": ""},"func8": {"source file: ": "test_liboffsets1.py","line number: ": "108","func name: ": "test_roll_yearday2","func arg: ": "(other, expected, n)","comments: ": ""},"func9": {"source file: ": "test_liboffsets1.py","line number: ": "115","func name: ": "test_get_day_of_month_error","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_liboffsets1.py","line number: ": "131","func name: ": "test_roll_qtr_day_not_mod_unequal","func arg: ": "(day_opt, month, n)","comments: ": ""},"func11": {"source file: ": "test_liboffsets1.py","line number: ": "158","func name: ": "test_roll_qtr_day_mod_equal","func arg: ": "(other, month, exp_dict, n, day_opt)","comments: ": ""},"func12": {"source file: ": "test_liboffsets1.py","line number: ": "168","func name: ": "test_roll_convention","func arg: ": "(n, expected, compare)","comments: ": ""}}{"func1": {"source file: ": "test_libsparse1.py","line number: ": "53","func name: ": "check_cases","func arg: ": "(_check_case)","comments: ": ""}}{"func1": {"source file: ": "test_list1.py","line number: ": "9","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_list1.py","line number: ": "14","func name: ": "data","func arg: ": "()","comments: ": "Length-100 ListArray for semantics test.\n\n\n"},"func3": {"source file: ": "test_list1.py","line number: ": "24","func name: ": "test_to_csv","func arg: ": "(data)","comments: ": ""}}{"func1": {"source file: ": "test_loc1.py","line number: ": "11","func name: ": "single_level_multiindex","func arg: ": "()","comments: ": "single level MultiIndex\n\n\n"},"func2": {"source file: ": "test_loc1.py","line number: ": "19","func name: ": "frame_random_data_integer_multi_index","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_loc1.py","line number: ": "305","func name: ": "test_loc_getitem_duplicates_multiindex_missing_indexers","func arg: ": "(indexer, pos)","comments: ": ""},"func4": {"source file: ": "test_loc1.py","line number: ": "317","func name: ": "test_series_loc_getitem_fancy","func arg: ": "(multiindex_year_month_day_dataframe_random_data)","comments: ": ""},"func5": {"source file: ": "test_loc1.py","line number: ": "325","func name: ": "test_loc_getitem_duplicates_multiindex_empty_indexer","func arg: ": "(columns_indexer)","comments: ": ""},"func6": {"source file: ": "test_loc1.py","line number: ": "337","func name: ": "test_loc_getitem_duplicates_multiindex_non_scalar_type_object","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_loc1.py","line number: ": "350","func name: ": "test_loc_getitem_tuple_plus_slice","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_loc1.py","line number: ": "365","func name: ": "test_loc_getitem_int","func arg: ": "(frame_random_data_integer_multi_index)","comments: ": ""},"func9": {"source file: ": "test_loc1.py","line number: ": "373","func name: ": "test_loc_getitem_int_raises_exception","func arg: ": "(frame_random_data_integer_multi_index)","comments: ": ""},"func10": {"source file: ": "test_loc1.py","line number: ": "379","func name: ": "test_loc_getitem_lowerdim_corner","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func11": {"source file: ": "test_loc1.py","line number: ": "393","func name: ": "test_loc_setitem_single_column_slice","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_loc1.py","line number: ": "416","func name: ": "test_loc_nan_multiindex","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_loc1.py","line number: ": "442","func name: ": "test_loc_period_string_indexing","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_loc2.py","line number: ": "946","func name: ": "test_series_loc_getitem_label_list_missing_values","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_loc2.py","line number: ": "964","func name: ": "test_loc_getitem_label_list_integer_labels","func arg: ": "(columns, column_key, expected_columns, check_column_type)","comments: ": ""},"func3": {"source file: ": "test_loc2.py","line number: ": "974","func name: ": "test_loc_setitem_float_intindex","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_loc2.py","line number: ": "988","func name: ": "test_loc_axis_1_slice","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_loc3.py","line number: ": "10","func name: ": "test_loc_uint64","func arg: ": "(val, expected)","comments: ": ""},"func2": {"source file: ": "test_loc3.py","line number: ": "16","func name: ": "test_loc_getitem","func arg: ": "(string_series, datetime_series)","comments: ": ""},"func3": {"source file: ": "test_loc3.py","line number: ": "36","func name: ": "test_loc_getitem_not_monotonic","func arg: ": "(datetime_series)","comments: ": ""},"func4": {"source file: ": "test_loc3.py","line number: ": "48","func name: ": "test_loc_getitem_setitem_integer_slice_keyerrors","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_loc3.py","line number: ": "76","func name: ": "test_loc_getitem_iterator","func arg: ": "(string_series)","comments: ": ""},"func6": {"source file: ": "test_loc3.py","line number: ": "82","func name: ": "test_loc_setitem_boolean","func arg: ": "(string_series)","comments: ": ""},"func7": {"source file: ": "test_loc3.py","line number: ": "92","func name: ": "test_loc_setitem_corner","func arg: ": "(string_series)","comments: ": ""},"func8": {"source file: ": "test_loc3.py","line number: ": "100","func name: ": "test_basic_setitem_with_labels","func arg: ": "(datetime_series)","comments: ": ""}}{"func1": {"source file: ": "test_localization1.py","line number: ": "26","func name: ": "test_can_set_locale_valid_set","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_localization1.py","line number: ": "31","func name: ": "test_can_set_locale_invalid_set","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_localization1.py","line number: ": "36","func name: ": "test_can_set_locale_invalid_get","func arg: ": "(monkeypatch)","comments: ": ""},"func4": {"source file: ": "test_localization1.py","line number: ": "49","func name: ": "test_get_locales_at_least_one","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_localization1.py","line number: ": "55","func name: ": "test_get_locales_prefix","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_localization1.py","line number: ": "70","func name: ": "test_set_locale","func arg: ": "(lang, enc)","comments: ": ""},"func7": {"source file: ": "test_localization1.py","line number: ": "98","func name: ": "test_encoding_detected","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_mangle_dupes1.py","line number: ": "15","func name: ": "test_basic","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func2": {"source file: ": "test_mangle_dupes1.py","line number: ": "27","func name: ": "test_basic_names","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_mangle_dupes1.py","line number: ": "38","func name: ": "test_basic_names_raise","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_mangle_dupes1.py","line number: ": "67","func name: ": "test_thorough_mangle_columns","func arg: ": "(all_parsers, data, expected)","comments: ": ""},"func5": {"source file: ": "test_mangle_dupes1.py","line number: ": "106","func name: ": "test_thorough_mangle_names","func arg: ": "(all_parsers, data, names, expected)","comments: ": ""},"func6": {"source file: ": "test_mangle_dupes1.py","line number: ": "114","func name: ": "test_mangled_unnamed_placeholders","func arg: ": "(all_parsers)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_merge_index_as_string1.py","line number: ": "9","func name: ": "df1","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_merge_index_as_string1.py","line number: ": "20","func name: ": "df2","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_merge_index_as_string1.py","line number: ": "31","func name: ": "left_df","func arg: ": "(request, df1)","comments: ": "Construct left test DataFrame with specified levels (any of 'outer', 'inner', and 'v1')\n\n\n"},"func4": {"source file: ": "test_merge_index_as_string1.py","line number: ": "42","func name: ": "right_df","func arg: ": "(request, df2)","comments: ": "Construct right test DataFrame with specified levels (any of 'outer', 'inner', and 'v2')\n\n\n"},"func5": {"source file: ": "test_merge_index_as_string1.py","line number: ": "53","func name: ": "compute_expected","func arg: ": "(df_left, df_right, on, left_on, right_on, how)","comments: ": "Compute the expected merge result for the test case.\n\nThis method computes the expected result of merging two DataFrames on a combination of their columns and index levels. It does so by explicitly dropping/resetting their named index levels, performing a merge on their columns, and then finally restoring the appropriate index in the result.\n\nParameters ---------- df_left : DataFrame The left DataFrame (may have zero or more named index levels) df_right : DataFrame The right DataFrame (may have zero or more named index levels) on : list of str The on parameter to the merge operation left_on : list of str The left_on parameter to the merge operation right_on : list of str The right_on parameter to the merge operation how : str The how parameter to the merge operation\n##### Returns\n"},"func6": {"source file: ": "test_merge_index_as_string1.py","line number: ": "132","func name: ": "test_merge_indexes_and_columns_on","func arg: ": "(left_df, right_df, on, how)","comments: ": ""},"func7": {"source file: ": "test_merge_index_as_string1.py","line number: ": "151","func name: ": "test_merge_indexes_and_columns_lefton_righton","func arg: ": "(left_df, right_df, left_on, right_on, how)","comments: ": ""},"func8": {"source file: ": "test_merge_index_as_string1.py","line number: ": "166","func name: ": "test_join_indexes_and_columns_on","func arg: ": "(df1, df2, left_index, join_type)","comments: ": ""}}{}{"func1": {"source file: ": "test_merge1.py","line number: ": "37","func name: ": "get_test_data","func arg: ": "(ngroups, n)","comments: ": ""},"func2": {"source file: ": "test_merge1.py","line number: ": "48","func name: ": "get_series","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_merge1.py","line number: ": "60","func name: ": "get_series_na","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_merge1.py","line number: ": "70","func name: ": "series_of_dtype","func arg: ": "(request)","comments: ": "A parametrized fixture returning a variety of Series of different dtypes\n\n\n"},"func5": {"source file: ": "test_merge1.py","line number: ": "79","func name: ": "series_of_dtype2","func arg: ": "(request)","comments: ": "A duplicate of the series_of_dtype fixture, so that it can be used twice by a single function\n\n\n"},"func6": {"source file: ": "test_merge1.py","line number: ": "88","func name: ": "series_of_dtype_all_na","func arg: ": "(request)","comments: ": "A parametrized fixture returning a variety of Series with all NA values\n\n\n"},"func7": {"source file: ": "test_merge1.py","line number: ": "1360","func name: ": "_check_merge","func arg: ": "(x, y)","comments: ": ""},"func8": {"source file: ": "test_merge1.py","line number: ": "1585","func name: ": "left","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_merge1.py","line number: ": "1598","func name: ": "right","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_merge1.py","line number: ": "1842","func name: ": "left_df","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_merge1.py","line number: ": "1847","func name: ": "right_df","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_merge1.py","line number: ": "1918","func name: ": "test_merge_index_types","func arg: ": "(index)","comments: ": ""},"func13": {"source file: ": "test_merge1.py","line number: ": "1945","func name: ": "test_merge_series","func arg: ": "(on, left_on, right_on, left_index, right_index, nm)","comments: ": ""},"func14": {"source file: ": "test_merge1.py","line number: ": "2006","func name: ": "test_merge_suffix","func arg: ": "(col1, col2, kwargs, expected_cols)","comments: ": ""},"func15": {"source file: ": "test_merge1.py","line number: ": "2030","func name: ": "test_merge_suffix_error","func arg: ": "(col1, col2, suffixes)","comments: ": ""},"func16": {"source file: ": "test_merge1.py","line number: ": "2042","func name: ": "test_merge_suffix_none_error","func arg: ": "(col1, col2, suffixes)","comments: ": ""},"func17": {"source file: ": "test_merge1.py","line number: ": "2055","func name: ": "test_merge_equal_cat_dtypes","func arg: ": "(cat_dtype, reverse)","comments: ": ""},"func18": {"source file: ": "test_merge1.py","line number: ": "2091","func name: ": "test_merge_equal_cat_dtypes2","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_merge1.py","line number: ": "2114","func name: ": "test_merge_on_cat_and_ext_array","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_merge1.py","line number: ": "2128","func name: ": "test_merge_multiindex_columns","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_merge1.py","line number: ": "2158","func name: ": "test_merge_datetime_upcast_dtype","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_misc1.py","line number: ": "20","func name: ": "test_import_error_message","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_misc1.py","line number: ": "28","func name: ": "test_get_accessor_args","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_misc2.py","line number: ": "379","func name: ": "test_iter_readonly","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_missing2.py","line number: ": "32","func name: ": "test_notna_notnull","func arg: ": "(notna_f)","comments: ": ""},"func2": {"source file: ": "test_missing2.py","line number: ": "288","func name: ": "test_array_equivalent","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_missing2.py","line number: ": "355","func name: ": "test_array_equivalent_tzawareness","func arg: ": "(lvalue, rvalue)","comments: ": ""},"func4": {"source file: ": "test_missing2.py","line number: ": "364","func name: ": "test_array_equivalent_compat","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_missing2.py","line number: ": "382","func name: ": "test_array_equivalent_str","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_missing2.py","line number: ": "392","func name: ": "test_array_equivalent_nested","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_missing2.py","line number: ": "435","func name: ": "test_na_value_for_dtype","func arg: ": "(dtype, na_value)","comments: ": ""}}{"func1": {"source file: ": "test_missing3.py","line number: ": "27","func name: ": "_simple_ts","func arg: ": "(start, end, freq)","comments: ": ""},"func2": {"source file: ": "test_missing3.py","line number: ": "1013","func name: ": "nontemporal_method","func arg: ": "(request)","comments: ": "Fixture that returns an (method name, required kwargs) pair.\n\nThis fixture does not include method 'time' as a parameterization; that method requires a Series with a DatetimeIndex, and is generally tested separately from these non-temporal methods.\n"},"func3": {"source file: ": "test_missing3.py","line number: ": "1042","func name: ": "interp_methods_ind","func arg: ": "(request)","comments: ": "Fixture that returns a (method name, required kwargs) pair to be tested for various Index types.\n\nThis fixture does not include methods\n\n- 'time', 'index', 'nearest', 'values' as a parameterization\n"}}{"func1": {"source file: ": "test_missing4.py","line number: ": "12","func name: ": "test_fillna","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_missing4.py","line number: ": "55","func name: ": "test_dropna","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_missing4.py","line number: ": "95","func name: ": "test_nulls","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_missing4.py","line number: ": "105","func name: ": "test_hasnans_isnans","func arg: ": "(idx)","comments: ": ""},"func5": {"source file: ": "test_missing4.py","line number: ": "126","func name: ": "test_nan_stays_float","func arg: ": "()","comments: ": ""}}{}{}{}{}{"func1": {"source file: ": "test_moments_rolling1.py","line number: ": "926","func name: ": "_rolling_consistency_cases","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_monotonic1.py","line number: ": "9","func name: ": "test_is_monotonic_increasing","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_monotonic1.py","line number: ": "86","func name: ": "test_is_monotonic_decreasing","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_monotonic1.py","line number: ": "165","func name: ": "test_is_strictly_monotonic_increasing","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_monotonic1.py","line number: ": "173","func name: ": "test_is_strictly_monotonic_decreasing","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_monotonic1.py","line number: ": "181","func name: ": "test_searchsorted_monotonic","func arg: ": "(indices)","comments: ": ""}}{"func1": {"source file: ": "test_multi_thread1.py","line number: ": "15","func name: ": "_construct_dataframe","func arg: ": "(num_rows)","comments: ": "Construct a DataFrame for testing.\n\nParameters ---------- num_rows : int The number of rows for our DataFrame.\n##### Returns\n* **df **: DataFrame\n\n"},"func2": {"source file: ": "test_multi_thread1.py","line number: ": "37","func name: ": "test_multi_thread_string_io_read_csv","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_multi_thread1.py","line number: ": "61","func name: ": "_generate_multi_thread_dataframe","func arg: ": "(parser, path, num_rows, num_tasks)","comments: ": "Generate a DataFrame via multi-thread.\n\nParameters ---------- parser : BaseParser The parser object to use for reading the data. path : str The location of the CSV file to read. num_rows : int The number of rows to read per task. num_tasks : int The number of tasks to use for reading this DataFrame.\n##### Returns\n* **df **: DataFrame\n\n"},"func4": {"source file: ": "test_multi_thread1.py","line number: ": "131","func name: ": "test_multi_thread_path_multipart_read_csv","func arg: ": "(all_parsers)","comments: ": ""}}{"func1": {"source file: ": "test_multi1.py","line number: ": "13","func name: ": "left","func arg: ": "()","comments: ": "left dataframe (not multi-indexed) for multi-index join tests\n\n\n"},"func2": {"source file: ": "test_multi1.py","line number: ": "24","func name: ": "right","func arg: ": "()","comments: ": "right dataframe (multi-indexed) for multi-index join tests\n\n\n"},"func3": {"source file: ": "test_multi1.py","line number: ": "38","func name: ": "left_multi","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_multi1.py","line number: ": "52","func name: ": "right_multi","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_multi1.py","line number: ": "66","func name: ": "on_cols_multi","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_multi1.py","line number: ": "71","func name: ": "idx_cols_multi","func arg: ": "()","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_na_indexing1.py","line number: ": "27","func name: ": "test_series_mask_boolean","func arg: ": "(values, dtype, mask, box_mask, frame)","comments: ": ""},"func2": {"source file: ": "test_na_indexing1.py","line number: ": "65","func name: ": "test_na_treated_as_false","func arg: ": "(frame)","comments: ": ""}}{"func1": {"source file: ": "test_na_scalar1.py","line number: ": "14","func name: ": "test_singleton","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_na_scalar1.py","line number: ": "20","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_na_scalar1.py","line number: ": "25","func name: ": "test_truthiness","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_na_scalar1.py","line number: ": "33","func name: ": "test_hashable","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_na_scalar1.py","line number: ": "39","func name: ": "test_arithmetic_ops","func arg: ": "(all_arithmetic_functions)","comments: ": ""},"func6": {"source file: ": "test_na_scalar1.py","line number: ": "54","func name: ": "test_comparison_ops","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_na_scalar1.py","line number: ": "87","func name: ": "test_pow_special","func arg: ": "(value, asarray)","comments: ": ""},"func8": {"source file: ": "test_na_scalar1.py","line number: ": "104","func name: ": "test_rpow_special","func arg: ": "(value, asarray)","comments: ": ""},"func9": {"source file: ": "test_na_scalar1.py","line number: ": "122","func name: ": "test_rpow_minus_one","func arg: ": "(value, asarray)","comments: ": ""},"func10": {"source file: ": "test_na_scalar1.py","line number: ": "133","func name: ": "test_unary_ops","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_na_scalar1.py","line number: ": "140","func name: ": "test_logical_and","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_na_scalar1.py","line number: ": "152","func name: ": "test_logical_or","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_na_scalar1.py","line number: ": "164","func name: ": "test_logical_xor","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_na_scalar1.py","line number: ": "176","func name: ": "test_logical_not","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_na_scalar1.py","line number: ": "183","func name: ": "test_arithmetic_ndarray","func arg: ": "(shape, all_arithmetic_functions)","comments: ": ""},"func16": {"source file: ": "test_na_scalar1.py","line number: ": "193","func name: ": "test_is_scalar","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_na_scalar1.py","line number: ": "197","func name: ": "test_isna","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_na_scalar1.py","line number: ": "202","func name: ": "test_series_isna","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_na_scalar1.py","line number: ": "208","func name: ": "test_ufunc","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_na_scalar1.py","line number: ": "218","func name: ": "test_ufunc_raises","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_na_scalar1.py","line number: ": "223","func name: ": "test_binary_input_not_dunder","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_na_scalar1.py","line number: ": "240","func name: ": "test_divmod_ufunc","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_na_scalar1.py","line number: ": "257","func name: ": "test_integer_hash_collision_dict","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_na_scalar1.py","line number: ": "265","func name: ": "test_integer_hash_collision_set","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_na_scalar1.py","line number: ": "274","func name: ": "test_pickle_roundtrip","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_na_scalar1.py","line number: ": "280","func name: ": "test_pickle_roundtrip_pandas","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_na_scalar1.py","line number: ": "289","func name: ": "test_pickle_roundtrip_containers","func arg: ": "(as_frame, values, dtype)","comments: ": ""}}{"func1": {"source file: ": "test_na_values1.py","line number: ": "16","func name: ": "test_string_nas","func arg: ": "(all_parsers)","comments: ": ""},"func2": {"source file: ": "test_na_values1.py","line number: ": "31","func name: ": "test_detect_string_na","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_na_values1.py","line number: ": "72","func name: ": "test_non_string_na_values","func arg: ": "(all_parsers, data, na_values)","comments: ": ""},"func4": {"source file: ": "test_na_values1.py","line number: ": "82","func name: ": "test_default_na_values","func arg: ": "(all_parsers)","comments: ": ""},"func5": {"source file: ": "test_na_values1.py","line number: ": "129","func name: ": "test_custom_na_values","func arg: ": "(all_parsers, na_values)","comments: ": ""},"func6": {"source file: ": "test_na_values1.py","line number: ": "144","func name: ": "test_bool_na_values","func arg: ": "(all_parsers)","comments: ": ""},"func7": {"source file: ": "test_na_values1.py","line number: ": "161","func name: ": "test_na_value_dict","func arg: ": "(all_parsers)","comments: ": ""},"func8": {"source file: ": "test_na_values1.py","line number: ": "202","func name: ": "test_na_value_dict_multi_index","func arg: ": "(all_parsers, index_col, expected)","comments: ": ""},"func9": {"source file: ": "test_na_values1.py","line number: ": "257","func name: ": "test_na_values_keep_default","func arg: ": "(all_parsers, kwargs, expected)","comments: ": ""},"func10": {"source file: ": "test_na_values1.py","line number: ": "273","func name: ": "test_no_na_values_no_keep_default","func arg: ": "(all_parsers)","comments: ": ""},"func11": {"source file: ": "test_na_values1.py","line number: ": "299","func name: ": "test_no_keep_default_na_dict_na_values","func arg: ": "(all_parsers)","comments: ": ""},"func12": {"source file: ": "test_na_values1.py","line number: ": "310","func name: ": "test_no_keep_default_na_dict_na_scalar_values","func arg: ": "(all_parsers)","comments: ": ""},"func13": {"source file: ": "test_na_values1.py","line number: ": "322","func name: ": "test_no_keep_default_na_dict_na_values_diff_reprs","func arg: ": "(all_parsers, col_zero_na_values)","comments: ": ""},"func14": {"source file: ": "test_na_values1.py","line number: ": "357","func name: ": "test_na_values_na_filter_override","func arg: ": "(all_parsers, na_filter, row_data)","comments: ": ""},"func15": {"source file: ": "test_na_values1.py","line number: ": "371","func name: ": "test_na_trailing_columns","func arg: ": "(all_parsers)","comments: ": ""},"func16": {"source file: ": "test_na_values1.py","line number: ": "405","func name: ": "test_na_values_scalar","func arg: ": "(all_parsers, na_values, row_data)","comments: ": ""},"func17": {"source file: ": "test_na_values1.py","line number: ": "416","func name: ": "test_na_values_dict_aliasing","func arg: ": "(all_parsers)","comments: ": ""},"func18": {"source file: ": "test_na_values1.py","line number: ": "431","func name: ": "test_na_values_dict_col_index","func arg: ": "(all_parsers)","comments: ": ""},"func19": {"source file: ": "test_na_values1.py","line number: ": "454","func name: ": "test_na_values_uint64","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func20": {"source file: ": "test_na_values1.py","line number: ": "461","func name: ": "test_empty_na_values_no_default_with_index","func arg: ": "(all_parsers)","comments: ": ""},"func21": {"source file: ": "test_na_values1.py","line number: ": "474","func name: ": "test_no_na_filter_on_index","func arg: ": "(all_parsers, na_filter, index_data)","comments: ": ""},"func22": {"source file: ": "test_na_values1.py","line number: ": "486","func name: ": "test_inf_na_values_with_int_index","func arg: ": "(all_parsers)","comments: ": ""},"func23": {"source file: ": "test_na_values1.py","line number: ": "500","func name: ": "test_na_values_with_dtype_str_and_na_filter","func arg: ": "(all_parsers, na_filter)","comments: ": ""},"func24": {"source file: ": "test_na_values1.py","line number: ": "525","func name: ": "test_cast_NA_to_bool_raises_error","func arg: ": "(all_parsers, data, na_values)","comments: ": ""},"func25": {"source file: ": "test_na_values1.py","line number: ": "542","func name: ": "test_str_nan_dropped","func arg: ": "(all_parsers)","comments: ": ""}}{"func1": {"source file: ": "test_names1.py","line number: ": "8","func name: ": "check_level_names","func arg: ": "(index, names)","comments: ": ""},"func2": {"source file: ": "test_names1.py","line number: ": "12","func name: ": "test_slice_keep_name","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_names1.py","line number: ": "17","func name: ": "test_index_name_retained","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_names1.py","line number: ": "29","func name: ": "test_changing_names","func arg: ": "(idx)","comments: ": ""},"func5": {"source file: ": "test_names1.py","line number: ": "51","func name: ": "test_take_preserve_name","func arg: ": "(idx)","comments: ": ""},"func6": {"source file: ": "test_names1.py","line number: ": "56","func name: ": "test_copy_names","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_names1.py","line number: ": "79","func name: ": "test_names","func arg: ": "(idx, index_names)","comments: ": ""},"func8": {"source file: ": "test_names1.py","line number: ": "115","func name: ": "test_duplicate_level_names_access_raises","func arg: ": "(idx)","comments: ": ""},"func9": {"source file: ": "test_names1.py","line number: ": "122","func name: ": "test_get_names_from_levels","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_names1.py","line number: ": "129","func name: ": "test_setting_names_from_levels_raises","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_nanops1.py","line number: ": "1014","func name: ": "test_use_bottleneck","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_nanops1.py","line number: ": "1042","func name: ": "test_numpy_ops","func arg: ": "(numpy_op, expected)","comments: ": ""},"func3": {"source file: ": "test_nanops1.py","line number: ": "1068","func name: ": "test_nanops_independent_of_mask_param","func arg: ": "(operation)","comments: ": ""}}{"func1": {"source file: ": "test_nat1.py","line number: ": "37","func name: ": "test_nat_fields","func arg: ": "(nat, idx)","comments: ": ""},"func2": {"source file: ": "test_nat1.py","line number: ": "60","func name: ": "test_nat_vector_field_access","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_nat1.py","line number: ": "93","func name: ": "test_identity","func arg: ": "(klass, value)","comments: ": ""},"func4": {"source file: ": "test_nat1.py","line number: ": "99","func name: ": "test_equality","func arg: ": "(klass, value)","comments: ": ""},"func5": {"source file: ": "test_nat1.py","line number: ": "109","func name: ": "test_round_nat","func arg: ": "(klass, method, freq)","comments: ": ""},"func6": {"source file: ": "test_nat1.py","line number: ": "149","func name: ": "test_nat_methods_raise","func arg: ": "(method)","comments: ": ""},"func7": {"source file: ": "test_nat1.py","line number: ": "158","func name: ": "test_nat_methods_nan","func arg: ": "(method)","comments: ": ""},"func8": {"source file: ": "test_nat1.py","line number: ": "166","func name: ": "test_nat_methods_nat","func arg: ": "(method)","comments: ": ""},"func9": {"source file: ": "test_nat1.py","line number: ": "174","func name: ": "test_nat_iso_format","func arg: ": "(get_nat)","comments: ": ""},"func10": {"source file: ": "test_nat1.py","line number: ": "197","func name: ": "test_missing_public_nat_methods","func arg: ": "(klass, expected)","comments: ": ""},"func11": {"source file: ": "test_nat1.py","line number: ": "212","func name: ": "_get_overlap_public_nat_methods","func arg: ": "(klass, as_tuple)","comments: ": "Get overlapping public methods between NaT and another class.\n\nParameters ---------- klass : type The class to compare with NaT as_tuple : bool, default False Whether to return a list of tuples of the form (klass, method).\n##### Returns\n* **overlap **: list\n\n"},"func12": {"source file: ": "test_nat1.py","line number: ": "297","func name: ": "test_overlap_public_nat_methods","func arg: ": "(klass, expected)","comments: ": ""},"func13": {"source file: ": "test_nat1.py","line number: ": "322","func name: ": "test_nat_doc_strings","func arg: ": "(compare)","comments: ": ""},"func14": {"source file: ": "test_nat1.py","line number: ": "362","func name: ": "test_nat_arithmetic_scalar","func arg: ": "(op_name, value, val_type)","comments: ": ""},"func15": {"source file: ": "test_nat1.py","line number: ": "419","func name: ": "test_nat_rfloordiv_timedelta","func arg: ": "(val, expected)","comments: ": ""},"func16": {"source file: ": "test_nat1.py","line number: ": "441","func name: ": "test_nat_arithmetic_index","func arg: ": "(op_name, value)","comments: ": ""},"func17": {"source file: ": "test_nat1.py","line number: ": "464","func name: ": "test_nat_arithmetic_td64_vector","func arg: ": "(op_name, box)","comments: ": ""},"func18": {"source file: ": "test_nat1.py","line number: ": "484","func name: ": "test_nat_arithmetic_ndarray","func arg: ": "(dtype, op, out_dtype)","comments: ": ""},"func19": {"source file: ": "test_nat1.py","line number: ": "493","func name: ": "test_nat_pinned_docstrings","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_nat1.py","line number: ": "498","func name: ": "test_to_numpy_alias","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_nat1.py","line number: ": "507","func name: ": "test_nat_comparisons","func arg: ": "(compare_operators_no_eq_ne, other)","comments: ": ""}}{"func1": {"source file: ": "test_network1.py","line number: ": "26","func name: ": "test_compressed_urls","func arg: ": "(salaries_table, compress_type, extension, mode, engine)","comments: ": ""},"func2": {"source file: ": "test_network1.py","line number: ": "31","func name: ": "check_compressed_urls","func arg: ": "(salaries_table, compression, extension, mode, engine)","comments: ": ""},"func3": {"source file: ": "test_network1.py","line number: ": "49","func name: ": "tips_df","func arg: ": "(datapath)","comments: ": "DataFrame with the tips dataset.\n\n\n"}}{"func1": {"source file: ": "test_nlargest1.py","line number: ": "32","func name: ": "s_main_dtypes","func arg: ": "()","comments: ": "A DataFrame with many dtypes\n\n* datetime * datetimetz * timedelta * [u]int{8,16,32,64} * float{32,64}\n\nThe columns are the name of the dtype.\n"},"func2": {"source file: ": "test_nlargest1.py","line number: ": "72","func name: ": "s_main_dtypes_split","func arg: ": "(request, s_main_dtypes)","comments: ": "Each series in s_main_dtypes.\n\n\n"},"func3": {"source file: ": "test_nlargest1.py","line number: ": "77","func name: ": "assert_check_nselect_boundary","func arg: ": "(vals, dtype, method)","comments: ": ""}}{"func1": {"source file: ": "test_nlargest2.py","line number: ": "15","func name: ": "df_duplicates","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_nlargest2.py","line number: ": "23","func name: ": "df_strings","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_nlargest2.py","line number: ": "34","func name: ": "df_main_dtypes","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_normalize_date1.py","line number: ": "19","func name: ": "test_normalize_date","func arg: ": "(value, expected)","comments: ": ""},"func2": {"source file: ": "test_normalize_date1.py","line number: ": "36","func name: ": "test_normalize_date_sub_types","func arg: ": "(dt, expected)","comments: ": ""}}{"func1": {"source file: ": "test_normalize1.py","line number: ": "13","func name: ": "deep_nested","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_normalize1.py","line number: ": "52","func name: ": "state_data","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_normalize1.py","line number: ": "77","func name: ": "author_missing_data","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_normalize1.py","line number: ": "88","func name: ": "missing_metadata","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_normalize1.py","line number: ": "117","func name: ": "max_level_test_input_data","func arg: ": "()","comments: ": "input data to test json_normalize with max_level param\n\n\n"}}{"func1": {"source file: ": "test_nth1.py","line number: ": "9","func name: ": "test_first_last_nth","func arg: ": "(df)","comments: ": ""},"func2": {"source file: ": "test_nth1.py","line number: ": "58","func name: ": "test_first_last_with_na_object","func arg: ": "(method, nulls_fixture)","comments: ": ""},"func3": {"source file: ": "test_nth1.py","line number: ": "78","func name: ": "test_nth_with_na_object","func arg: ": "(index, nulls_fixture)","comments: ": ""},"func4": {"source file: ": "test_nth1.py","line number: ": "98","func name: ": "test_first_last_with_None","func arg: ": "(method)","comments: ": ""},"func5": {"source file: ": "test_nth1.py","line number: ": "108","func name: ": "test_first_last_nth_dtypes","func arg: ": "(df_mixed_floats)","comments: ": ""},"func6": {"source file: ": "test_nth1.py","line number: ": "143","func name: ": "test_first_strings_timestamps","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_nth1.py","line number: ": "162","func name: ": "test_nth","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_nth1.py","line number: ": "286","func name: ": "test_nth_multi_index","func arg: ": "(three_group)","comments: ": ""},"func9": {"source file: ": "test_nth1.py","line number: ": "344","func name: ": "test_first_last_tz","func arg: ": "(data, expected_first, expected_last)","comments: ": ""},"func10": {"source file: ": "test_nth1.py","line number: ": "375","func name: ": "test_first_last_tz_multi_column","func arg: ": "(method, ts, alpha)","comments: ": ""},"func11": {"source file: ": "test_nth1.py","line number: ": "408","func name: ": "test_first_last_extension_array_keeps_dtype","func arg: ": "(values, function)","comments: ": ""},"func12": {"source file: ": "test_nth1.py","line number: ": "424","func name: ": "test_nth_multi_index_as_expected","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_nth1.py","line number: ": "482","func name: ": "test_groupby_head_tail","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_nth1.py","line number: ": "533","func name: ": "test_group_selection_cache","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_nth1.py","line number: ": "563","func name: ": "test_nth_empty","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_nth1.py","line number: ": "577","func name: ": "test_nth_column_order","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_nth1.py","line number: ": "598","func name: ": "test_nth_nan_in_grouper","func arg: ": "(dropna)","comments: ": ""}}{}{"func1": {"source file: ": "test_numeric1.py","line number: ": "19","func name: ": "adjust_negative_zero","func arg: ": "(zero, expected)","comments: ": "Helper to adjust the expected result if we are dividing by -0.0 as opposed to 0.0\n\n\n"},"func2": {"source file: ": "test_numeric1.py","line number: ": "1261","func name: ": "test_fill_value_inf_masking","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_numeric1.py","line number: ": "1275","func name: ": "test_dataframe_div_silenced","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_numeric2.py","line number: ": "13","func name: ": "errors","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_numeric2.py","line number: ": "18","func name: ": "signed","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_numeric2.py","line number: ": "23","func name: ": "transform","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "test_numeric2.py","line number: ": "28","func name: ": "large_val","func arg: ": "(request)","comments: ": ""},"func5": {"source file: ": "test_numeric2.py","line number: ": "33","func name: ": "multiple_elts","func arg: ": "(request)","comments: ": ""},"func6": {"source file: ": "test_numeric2.py","line number: ": "44","func name: ": "transform_assert_equal","func arg: ": "(request)","comments: ": ""},"func7": {"source file: ": "test_numeric2.py","line number: ": "55","func name: ": "test_empty","func arg: ": "(input_kwargs, result_kwargs)","comments: ": ""},"func8": {"source file: ": "test_numeric2.py","line number: ": "65","func name: ": "test_series","func arg: ": "(last_val)","comments: ": ""},"func9": {"source file: ": "test_numeric2.py","line number: ": "82","func name: ": "test_series_numeric","func arg: ": "(data)","comments: ": ""},"func10": {"source file: ": "test_numeric2.py","line number: ": "99","func name: ": "test_error","func arg: ": "(data, msg)","comments: ": ""},"func11": {"source file: ": "test_numeric2.py","line number: ": "109","func name: ": "test_ignore_error","func arg: ": "(errors, exp_data)","comments: ": ""},"func12": {"source file: ": "test_numeric2.py","line number: ": "126","func name: ": "test_bool_handling","func arg: ": "(errors, exp)","comments: ": ""},"func13": {"source file: ": "test_numeric2.py","line number: ": "139","func name: ": "test_list","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_numeric2.py","line number: ": "156","func name: ": "test_list_numeric","func arg: ": "(data, arr_kwargs)","comments: ": ""},"func15": {"source file: ": "test_numeric2.py","line number: ": "163","func name: ": "test_numeric","func arg: ": "(kwargs)","comments: ": ""},"func16": {"source file: ": "test_numeric2.py","line number: ": "182","func name: ": "test_numeric_df_columns","func arg: ": "(columns)","comments: ": ""},"func17": {"source file: ": "test_numeric2.py","line number: ": "209","func name: ": "test_numeric_embedded_arr_likes","func arg: ": "(data, exp_data)","comments: ": ""},"func18": {"source file: ": "test_numeric2.py","line number: ": "218","func name: ": "test_all_nan","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_numeric2.py","line number: ": "226","func name: ": "test_type_check","func arg: ": "(errors)","comments: ": ""},"func20": {"source file: ": "test_numeric2.py","line number: ": "237","func name: ": "test_scalar","func arg: ": "(val, signed, transform)","comments: ": ""},"func21": {"source file: ": "test_numeric2.py","line number: ": "242","func name: ": "test_really_large_scalar","func arg: ": "(large_val, signed, transform, errors)","comments: ": ""},"func22": {"source file: ": "test_numeric2.py","line number: ": "259","func name: ": "test_really_large_in_arr","func arg: ": "(large_val, signed, transform, multiple_elts, errors)","comments: ": ""},"func23": {"source file: ": "test_numeric2.py","line number: ": "298","func name: ": "test_really_large_in_arr_consistent","func arg: ": "(large_val, signed, multiple_elts, errors)","comments: ": ""},"func24": {"source file: ": "test_numeric2.py","line number: ": "336","func name: ": "test_scalar_fail","func arg: ": "(errors, checker)","comments: ": ""},"func25": {"source file: ": "test_numeric2.py","line number: ": "347","func name: ": "test_numeric_dtypes","func arg: ": "(data, transform_assert_equal)","comments: ": ""},"func26": {"source file: ": "test_numeric2.py","line number: ": "362","func name: ": "test_str","func arg: ": "(data, exp, transform_assert_equal)","comments: ": ""},"func27": {"source file: ": "test_numeric2.py","line number: ": "370","func name: ": "test_datetime_like","func arg: ": "(tz_naive_fixture, transform_assert_equal)","comments: ": ""},"func28": {"source file: ": "test_numeric2.py","line number: ": "379","func name: ": "test_timedelta","func arg: ": "(transform_assert_equal)","comments: ": ""},"func29": {"source file: ": "test_numeric2.py","line number: ": "388","func name: ": "test_period","func arg: ": "(transform_assert_equal)","comments: ": ""},"func30": {"source file: ": "test_numeric2.py","line number: ": "411","func name: ": "test_non_hashable","func arg: ": "(errors, expected)","comments: ": ""},"func31": {"source file: ": "test_numeric2.py","line number: ": "423","func name: ": "test_downcast_invalid_cast","func arg: ": "()","comments: ": ""},"func32": {"source file: ": "test_numeric2.py","line number: ": "433","func name: ": "test_errors_invalid_value","func arg: ": "()","comments: ": ""},"func33": {"source file: ": "test_numeric2.py","line number: ": "463","func name: ": "test_downcast_basic","func arg: ": "(data, kwargs, exp_dtype)","comments: ": ""},"func34": {"source file: ": "test_numeric2.py","line number: ": "479","func name: ": "test_signed_downcast","func arg: ": "(data, signed_downcast)","comments: ": ""},"func35": {"source file: ": "test_numeric2.py","line number: ": "488","func name: ": "test_ignore_downcast_invalid_data","func arg: ": "()","comments: ": ""},"func36": {"source file: ": "test_numeric2.py","line number: ": "499","func name: ": "test_ignore_downcast_neg_to_unsigned","func arg: ": "()","comments: ": ""},"func37": {"source file: ": "test_numeric2.py","line number: ": "522","func name: ": "test_ignore_downcast_cannot_convert_float","func arg: ": "(data, expected, downcast)","comments: ": ""},"func38": {"source file: ": "test_numeric2.py","line number: ": "533","func name: ": "test_downcast_not8bit","func arg: ": "(downcast, expected_dtype)","comments: ": ""},"func39": {"source file: ": "test_numeric2.py","line number: ": "564","func name: ": "test_downcast_limits","func arg: ": "(dtype, downcast, min_max)","comments: ": ""},"func40": {"source file: ": "test_numeric2.py","line number: ": "579","func name: ": "test_downcast_uint64","func arg: ": "(ser, expected)","comments: ": ""},"func41": {"source file: ": "test_numeric2.py","line number: ": "601","func name: ": "test_coerce_uint64_conflict","func arg: ": "(data, exp_data)","comments: ": ""},"func42": {"source file: ": "test_numeric2.py","line number: ": "618","func name: ": "test_non_coerce_uint64_conflict","func arg: ": "(errors, exp)","comments: ": ""}}{"func1": {"source file: ": "test_numeric3.py","line number: ": "9","func name: ": "test_get","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_numeric3.py","line number: ": "112","func name: ": "test_get_nan","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_numeric3.py","line number: ": "119","func name: ": "test_get_nan_multiple","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_numeric3.py","line number: ": "139","func name: ": "test_delitem","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_numeric3.py","line number: ": "177","func name: ": "test_slice_float64","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_numeric3.py","line number: ": "202","func name: ": "test_getitem_negative_out_of_bounds","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_numeric3.py","line number: ": "213","func name: ": "test_getitem_regression","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_numeric3.py","line number: ": "219","func name: ": "test_getitem_setitem_slice_bug","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_numeric3.py","line number: ": "238","func name: ": "test_getitem_setitem_slice_integers","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_numeric3.py","line number: ": "250","func name: ": "test_setitem_float_labels","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_numeric3.py","line number: ": "261","func name: ": "test_slice_float_get_set","func arg: ": "(datetime_series)","comments: ": ""},"func12": {"source file: ": "test_numeric3.py","line number: ": "279","func name: ": "test_slice_floats2","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_numeric3.py","line number: ": "292","func name: ": "test_int_indexing","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_numeric3.py","line number: ": "311","func name: ": "test_getitem_int64","func arg: ": "(datetime_series)","comments: ": ""}}{"func1": {"source file: ": "test_numeric4.py","line number: ": "1195","func name: ": "test_int_float_union_dtype","func arg: ": "(dtype)","comments: ": ""},"func2": {"source file: ": "test_numeric4.py","line number: ": "1208","func name: ": "test_range_float_union_dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_numeric4.py","line number: ": "1220","func name: ": "test_uint_index_does_not_convert_to_float64","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_numpy_compat1.py","line number: ": "47","func name: ": "test_numpy_ufuncs_basic","func arg: ": "(indices, func)","comments: ": ""},"func2": {"source file: ": "test_numpy_compat1.py","line number: ": "78","func name: ": "test_numpy_ufuncs_other","func arg: ": "(indices, func)","comments: ": ""},"func3": {"source file: ": "test_numpy_compat1.py","line number: ": "118","func name: ": "test_elementwise_comparison_warning","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_numpy1.py","line number: ": "25","func name: ": "any_numpy_array","func arg: ": "(request)","comments: ": "Parametrized fixture for NumPy arrays with different dtypes.\n\nThis excludes string and bytes.\n"},"func2": {"source file: ": "test_numpy1.py","line number: ": "53","func name: ": "test_is_numeric","func arg: ": "(dtype, expected)","comments: ": ""},"func3": {"source file: ": "test_numpy1.py","line number: ": "73","func name: ": "test_is_boolean","func arg: ": "(dtype, expected)","comments: ": ""},"func4": {"source file: ": "test_numpy1.py","line number: ": "78","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_numpy1.py","line number: ": "83","func name: ": "test_constructor_from_string","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_numpy1.py","line number: ": "93","func name: ": "test_constructor_no_coercion","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_numpy1.py","line number: ": "98","func name: ": "test_series_constructor_with_copy","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_numpy1.py","line number: ": "105","func name: ": "test_series_constructor_with_astype","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_numpy1.py","line number: ": "112","func name: ": "test_from_sequence_dtype","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_numpy1.py","line number: ": "119","func name: ": "test_constructor_copy","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_numpy1.py","line number: ": "126","func name: ": "test_constructor_with_data","func arg: ": "(any_numpy_array)","comments: ": ""},"func12": {"source file: ": "test_numpy1.py","line number: ": "136","func name: ": "test_to_numpy","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_numpy1.py","line number: ": "153","func name: ": "test_setitem_series","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_numpy1.py","line number: ": "160","func name: ": "test_setitem","func arg: ": "(any_numpy_array)","comments: ": ""},"func15": {"source file: ": "test_numpy1.py","line number: ": "174","func name: ": "test_bad_reduce_raises","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_numpy1.py","line number: ": "182","func name: ": "test_validate_reduction_keyword_args","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_numpy1.py","line number: ": "193","func name: ": "test_ufunc","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_numpy1.py","line number: ": "207","func name: ": "test_basic_binop","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_numpy1.py","line number: ": "217","func name: ": "test_setitem_object_typecode","func arg: ": "(dtype)","comments: ": ""},"func20": {"source file: ": "test_numpy1.py","line number: ": "224","func name: ": "test_setitem_no_coercion","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_numpy1.py","line number: ": "236","func name: ": "test_setitem_preserves_views","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_numpy2.py","line number: ": "14","func name: ": "dtype","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_numpy2.py","line number: ": "19","func name: ": "allow_in_pandas","func arg: ": "(monkeypatch)","comments: ": "A monkeypatch to tells pandas to let us in.\n\nBy default, passing a PandasArray to an index / series / frame constructor will unbox that PandasArray to an ndarray, and treat it as a non-EA column. We don't want people using EAs without reason.\n\nThe mechanism for this is a check against ABCPandasArray in each constructor.\n\nBut, for testing, we need to allow them in pandas. So we patch the _typ of PandasArray, so that we evade the ABCPandasArray check.\n"},"func3": {"source file: ": "test_numpy2.py","line number: ": "41","func name: ": "data","func arg: ": "(allow_in_pandas, dtype)","comments: ": ""},"func4": {"source file: ": "test_numpy2.py","line number: ": "48","func name: ": "data_missing","func arg: ": "(allow_in_pandas, dtype)","comments: ": ""},"func5": {"source file: ": "test_numpy2.py","line number: ": "59","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_numpy2.py","line number: ": "64","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_numpy2.py","line number: ": "72","func name: ": "data_for_sorting","func arg: ": "(allow_in_pandas, dtype)","comments: ": "Length-3 array with a known sort order.\n\nThis should be three items [B, C, A] with A < B < C\n"},"func8": {"source file: ": "test_numpy2.py","line number: ": "86","func name: ": "data_missing_for_sorting","func arg: ": "(allow_in_pandas, dtype)","comments: ": "Length-3 array with a known sort order.\n\nThis should be three items [B, NA, A] with A < B and NA missing.\n"},"func9": {"source file: ": "test_numpy2.py","line number: ": "98","func name: ": "data_for_grouping","func arg: ": "(allow_in_pandas, dtype)","comments: ": "Data for factorization, grouping, and unique tests.\n\nExpected to be like [B, B, NA, NA, A, A, B, C]\n\nWhere A < B < C and NA is missing\n"},"func10": {"source file: ": "test_numpy2.py","line number: ": "115","func name: ": "skip_numpy_object","func arg: ": "(dtype)","comments: ": "Tests for PandasArray with nested data. Users typically won't create these objects via `pd.array`, but they can show up through `.array` on a Series with nested data. Many of the base tests fail, as they aren't appropriate for nested data.\n\nThis fixture allows these tests to be skipped when used as a usefixtures marker to either an individual test or a test class.\n"}}{"func1": {"source file: ": "test_object1.py","line number: ": "356","func name: ": "test_index_ops_defer_to_unknown_subclasses","func arg: ": "(other)","comments: ": ""}}{"func1": {"source file: ": "test_observance1.py","line number: ": "28","func name: ": "test_next_monday","func arg: ": "(day)","comments: ": ""},"func2": {"source file: ": "test_observance1.py","line number: ": "35","func name: ": "test_next_monday_or_tuesday","func arg: ": "(day, expected)","comments: ": ""},"func3": {"source file: ": "test_observance1.py","line number: ": "40","func name: ": "test_previous_friday","func arg: ": "(day)","comments: ": ""},"func4": {"source file: ": "test_observance1.py","line number: ": "44","func name: ": "test_sunday_to_monday","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_observance1.py","line number: ": "51","func name: ": "test_nearest_workday","func arg: ": "(day, expected)","comments: ": ""},"func6": {"source file: ": "test_observance1.py","line number: ": "58","func name: ": "test_weekend_to_monday","func arg: ": "(day, expected)","comments: ": ""},"func7": {"source file: ": "test_observance1.py","line number: ": "65","func name: ": "test_next_workday","func arg: ": "(day, expected)","comments: ": ""},"func8": {"source file: ": "test_observance1.py","line number: ": "72","func name: ": "test_previous_workday","func arg: ": "(day, expected)","comments: ": ""},"func9": {"source file: ": "test_observance1.py","line number: ": "79","func name: ": "test_before_nearest_workday","func arg: ": "(day, expected)","comments: ": ""},"func10": {"source file: ": "test_observance1.py","line number: ": "86","func name: ": "test_after_nearest_workday","func arg: ": "(day, expected)","comments: ": ""}}{"func1": {"source file: ": "test_odf1.py","line number: ": "13","func name: ": "cd_and_set_engine","func arg: ": "(monkeypatch, datapath)","comments: ": ""},"func2": {"source file: ": "test_odf1.py","line number: ": "19","func name: ": "test_read_invalid_types_raises","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_odf1.py","line number: ": "26","func name: ": "test_read_writer_table","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_odf1.py","line number: ": "41","func name: ": "test_nonexistent_sheetname_raises","func arg: ": "(read_ext)","comments: ": ""}}{"func1": {"source file: ": "test_offsets_properties1.py","line number: ": "91","func name: ": "test_on_offset_implementations","func arg: ": "(dt, offset)","comments: ": ""},"func2": {"source file: ": "test_offsets_properties1.py","line number: ": "107","func name: ": "test_apply_index_implementations","func arg: ": "(offset, rng)","comments: ": ""},"func3": {"source file: ": "test_offsets_properties1.py","line number: ": "130","func name: ": "test_shift_across_dst","func arg: ": "(offset)","comments: ": ""}}{"func1": {"source file: ": "test_offsets1.py","line number: ": "3976","func name: ": "test_Easter","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_offsets1.py","line number: ": "4006","func name: ": "test_get_offset","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_offsets1.py","line number: ": "4032","func name: ": "test_get_offset_legacy","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_offsets1.py","line number: ": "4093","func name: ": "test_dateoffset_misc","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_offsets1.py","line number: ": "4101","func name: ": "test_freq_offsets","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_offsets1.py","line number: ": "4140","func name: ": "get_utc_offset_hours","func arg: ": "(ts)","comments: ": ""},"func7": {"source file: ": "test_offsets1.py","line number: ": "4294","func name: ": "test_get_offset_day_error","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_offsets1.py","line number: ": "4302","func name: ": "test_valid_default_arguments","func arg: ": "(offset_types)","comments: ": ""},"func9": {"source file: ": "test_offsets1.py","line number: ": "4310","func name: ": "test_valid_month_attributes","func arg: ": "(kwd, month_classes)","comments: ": ""},"func10": {"source file: ": "test_offsets1.py","line number: ": "4319","func name: ": "test_valid_relativedelta_kwargs","func arg: ": "(kwd)","comments: ": ""},"func11": {"source file: ": "test_offsets1.py","line number: ": "4326","func name: ": "test_valid_tick_attributes","func arg: ": "(kwd, tick_classes)","comments: ": ""},"func12": {"source file: ": "test_offsets1.py","line number: ": "4334","func name: ": "test_validate_n_error","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_offsets1.py","line number: ": "4345","func name: ": "test_require_integers","func arg: ": "(offset_types)","comments: ": ""},"func14": {"source file: ": "test_offsets1.py","line number: ": "4351","func name: ": "test_tick_normalize_raises","func arg: ": "(tick_classes)","comments: ": ""},"func15": {"source file: ": "test_offsets1.py","line number: ": "4359","func name: ": "test_weeks_onoffset","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_offsets1.py","line number: ": "4376","func name: ": "test_weekofmonth_onoffset","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_offsets1.py","line number: ": "4393","func name: ": "test_last_week_of_month_on_offset","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_offsets1.py","line number: ": "4409","func name: ": "test_week_add_invalid","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_openpyxl1.py","line number: ": "17","func name: ": "test_to_excel_styleconverter","func arg: ": "(ext)","comments: ": ""},"func2": {"source file: ": "test_openpyxl1.py","line number: ": "50","func name: ": "test_write_cells_merge_styled","func arg: ": "(ext)","comments: ": ""},"func3": {"source file: ": "test_openpyxl1.py","line number: ": "87","func name: ": "test_write_append_mode","func arg: ": "(ext, mode, expected)","comments: ": ""},"func4": {"source file: ": "test_openpyxl1.py","line number: ": "110","func name: ": "test_to_excel_with_openpyxl_engine","func arg: ": "(ext, tmpdir)","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_ops1.py","line number: ": "11","func name: ": "constructor","func arg: ": "(request)","comments: ": "Fixture for testing both interval container classes.\n\n\n"},"func2": {"source file: ": "test_ops1.py","line number: ": "26","func name: ": "start_shift","func arg: ": "(request)","comments: ": "Fixture for generating intervals of different types from a start value and a shift value that can be added to start to generate an endpoint.\n\n\n"}}{}{"func1": {"source file: ": "test_ops3.py","line number: ": "15","func name: ": "start_shift","func arg: ": "(request)","comments: ": "Fixture for generating intervals of types from a start value and a shift value that can be added to start to generate an endpoint\n\n\n"}}{}{}{}{"func1": {"source file: ": "test_optional_dependency1.py","line number: ": "11","func name: ": "test_import_optional","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_optional_dependency1.py","line number: ": "20","func name: ": "test_xlrd_version_fallback","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_optional_dependency1.py","line number: ": "25","func name: ": "test_bad_version","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_optional_dependency1.py","line number: ": "45","func name: ": "test_no_version_raises","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_orc1.py","line number: ": "21","func name: ": "dirpath","func arg: ": "(datapath)","comments: ": ""},"func2": {"source file: ": "test_orc1.py","line number: ": "25","func name: ": "test_orc_reader_empty","func arg: ": "(dirpath)","comments: ": ""},"func3": {"source file: ": "test_orc1.py","line number: ": "58","func name: ": "test_orc_reader_basic","func arg: ": "(dirpath)","comments: ": ""},"func4": {"source file: ": "test_orc1.py","line number: ": "78","func name: ": "test_orc_reader_decimal","func arg: ": "(dirpath)","comments: ": ""},"func5": {"source file: ": "test_orc1.py","line number: ": "107","func name: ": "test_orc_reader_date_low","func arg: ": "(dirpath)","comments: ": ""},"func6": {"source file: ": "test_orc1.py","line number: ": "148","func name: ": "test_orc_reader_date_high","func arg: ": "(dirpath)","comments: ": ""},"func7": {"source file: ": "test_orc1.py","line number: ": "189","func name: ": "test_orc_reader_snappy_compressed","func arg: ": "(dirpath)","comments: ": ""}}{"func1": {"source file: ": "test_other1.py","line number: ": "27","func name: ": "test_agg_api","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_other1.py","line number: ": "51","func name: ": "test_agg_datetimes_mixed","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_other1.py","line number: ": "88","func name: ": "test_agg_period_index","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_other1.py","line number: ": "103","func name: ": "test_agg_dict_parameter_cast_result_dtypes","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_other1.py","line number: ": "141","func name: ": "test_agg_cast_results_dtypes","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_other1.py","line number: ": "153","func name: ": "test_aggregate_float64_no_int64","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_other1.py","line number: ": "170","func name: ": "test_aggregate_api_consistency","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_other1.py","line number: ": "217","func name: ": "test_agg_dict_renaming_deprecation","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_other1.py","line number: ": "234","func name: ": "test_agg_compat","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_other1.py","line number: ": "255","func name: ": "test_agg_nested_dicts","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_other1.py","line number: ": "284","func name: ": "test_agg_item_by_item_raise_typeerror","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_other1.py","line number: ": "296","func name: ": "test_series_agg_multikey","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_other1.py","line number: ": "305","func name: ": "test_series_agg_multi_pure_python","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_other1.py","line number: ": "362","func name: ": "test_agg_consistency","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_other1.py","line number: ": "390","func name: ": "test_agg_callables","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_other1.py","line number: ": "413","func name: ": "test_agg_over_numpy_arrays","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_other1.py","line number: ": "435","func name: ": "test_agg_tzaware_non_datetime_result","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_other1.py","line number: ": "460","func name: ": "test_agg_timezone_round_trip","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_other1.py","line number: ": "496","func name: ": "test_sum_uint64_overflow","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_other1.py","line number: ": "530","func name: ": "test_agg_structs_dataframe","func arg: ": "(structure, expected)","comments: ": ""},"func21": {"source file: ": "test_other1.py","line number: ": "549","func name: ": "test_agg_structs_series","func arg: ": "(structure, expected)","comments: ": ""},"func22": {"source file: ": "test_other1.py","line number: ": "560","func name: ": "test_agg_category_nansum","func arg: ": "(observed)","comments: ": ""},"func23": {"source file: ": "test_other1.py","line number: ": "576","func name: ": "test_agg_list_like_func","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_other1.py","line number: ": "589","func name: ": "test_agg_lambda_with_timezone","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_other1.py","line number: ": "622","func name: ": "test_groupby_agg_err_catching","func arg: ": "(err_cls)","comments: ": ""}}{}{"func1": {"source file: ": "test_pandas1.py","line number: ": "35","func name: ": "assert_json_roundtrip_equal","func arg: ": "(result, expected, orient)","comments: ": ""}}{"func1": {"source file: ": "test_parquet1.py","line number: ": "61","func name: ": "engine","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_parquet1.py","line number: ": "66","func name: ": "pa","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_parquet1.py","line number: ": "73","func name: ": "fp","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_parquet1.py","line number: ": "80","func name: ": "df_compat","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_parquet1.py","line number: ": "85","func name: ": "df_cross_compat","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_parquet1.py","line number: ": "103","func name: ": "df_full","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_parquet1.py","line number: ": "126","func name: ": "check_round_trip","func arg: ": "(df, engine, path, write_kwargs, read_kwargs, expected, check_names, repeat)","comments: ": "Verify parquet serializer and deserializer produce the same results.\n\nPerforms a pandas to disk and disk to pandas round trip, then compares the 2 resulting DataFrames to verify equality.\n\nParameters ---------- df: Dataframe engine: str, optional 'pyarrow' or 'fastparquet' path: str, optional write_kwargs: dict of str:str, optional read_kwargs: dict of str:str, optional expected: DataFrame, optional Expected deserialization result, otherwise will be equal to `df` check_names: list of str, optional Closed set of column names to be compared repeat: int, optional How many times to repeat the test\n"},"func8": {"source file: ": "test_parquet1.py","line number: ": "182","func name: ": "test_invalid_engine","func arg: ": "(df_compat)","comments: ": ""},"func9": {"source file: ": "test_parquet1.py","line number: ": "187","func name: ": "test_options_py","func arg: ": "(df_compat, pa)","comments: ": ""},"func10": {"source file: ": "test_parquet1.py","line number: ": "194","func name: ": "test_options_fp","func arg: ": "(df_compat, fp)","comments: ": ""},"func11": {"source file: ": "test_parquet1.py","line number: ": "201","func name: ": "test_options_auto","func arg: ": "(df_compat, fp, pa)","comments: ": ""},"func12": {"source file: ": "test_parquet1.py","line number: ": "208","func name: ": "test_options_get_engine","func arg: ": "(fp, pa)","comments: ": ""},"func13": {"source file: ": "test_parquet1.py","line number: ": "228","func name: ": "test_cross_engine_pa_fp","func arg: ": "(df_cross_compat, pa, fp)","comments: ": ""},"func14": {"source file: ": "test_parquet1.py","line number: ": "242","func name: ": "test_cross_engine_fp_pa","func arg: ": "(df_cross_compat, pa, fp)","comments: ": ""}}{"func1": {"source file: ": "test_parse_dates1.py","line number: ": "38","func name: ": "test_separator_date_conflict","func arg: ": "(all_parsers)","comments: ": ""},"func2": {"source file: ": "test_parse_dates1.py","line number: ": "60","func name: ": "test_multiple_date_col_custom","func arg: ": "(all_parsers, keep_date_col)","comments: ": ""},"func3": {"source file: ": "test_parse_dates1.py","line number: ": "204","func name: ": "test_concat_date_col_fail","func arg: ": "(container, dim)","comments: ": ""},"func4": {"source file: ": "test_parse_dates1.py","line number: ": "215","func name: ": "test_multiple_date_col","func arg: ": "(all_parsers, keep_date_col)","comments: ": ""},"func5": {"source file: ": "test_parse_dates1.py","line number: ": "336","func name: ": "test_date_col_as_index_col","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_parse_dates1.py","line number: ": "373","func name: ": "test_multiple_date_cols_int_cast","func arg: ": "(all_parsers)","comments: ": ""},"func7": {"source file: ": "test_parse_dates1.py","line number: ": "431","func name: ": "test_multiple_date_col_timestamp_parse","func arg: ": "(all_parsers)","comments: ": ""},"func8": {"source file: ": "test_parse_dates1.py","line number: ": "465","func name: ": "test_multiple_date_cols_with_header","func arg: ": "(all_parsers)","comments: ": ""},"func9": {"source file: ": "test_parse_dates1.py","line number: ": "575","func name: ": "test_multiple_date_col_name_collision","func arg: ": "(all_parsers, data, parse_dates, msg)","comments: ": ""},"func10": {"source file: ": "test_parse_dates1.py","line number: ": "582","func name: ": "test_date_parser_int_bug","func arg: ": "(all_parsers)","comments: ": ""},"func11": {"source file: ": "test_parse_dates1.py","line number: ": "634","func name: ": "test_nat_parse","func arg: ": "(all_parsers)","comments: ": ""},"func12": {"source file: ": "test_parse_dates1.py","line number: ": "649","func name: ": "test_csv_custom_parser","func arg: ": "(all_parsers)","comments: ": ""},"func13": {"source file: ": "test_parse_dates1.py","line number: ": "663","func name: ": "test_parse_dates_implicit_first_col","func arg: ": "(all_parsers)","comments: ": ""},"func14": {"source file: ": "test_parse_dates1.py","line number: ": "676","func name: ": "test_parse_dates_string","func arg: ": "(all_parsers)","comments: ": ""},"func15": {"source file: ": "test_parse_dates1.py","line number: ": "697","func name: ": "test_yy_format_with_year_first","func arg: ": "(all_parsers, parse_dates)","comments: ": ""},"func16": {"source file: ": "test_parse_dates1.py","line number: ": "719","func name: ": "test_parse_dates_column_list","func arg: ": "(all_parsers, parse_dates)","comments: ": ""},"func17": {"source file: ": "test_parse_dates1.py","line number: ": "735","func name: ": "test_multi_index_parse_dates","func arg: ": "(all_parsers, index_col)","comments: ": ""},"func18": {"source file: ": "test_parse_dates1.py","line number: ": "780","func name: ": "test_parse_dates_custom_euro_format","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func19": {"source file: ": "test_parse_dates1.py","line number: ": "821","func name: ": "test_parse_tz_aware","func arg: ": "(all_parsers)","comments: ": ""},"func20": {"source file: ": "test_parse_dates1.py","line number: ": "838","func name: ": "test_multiple_date_cols_index","func arg: ": "(all_parsers, parse_dates, index_col)","comments: ": ""},"func21": {"source file: ": "test_parse_dates1.py","line number: ": "934","func name: ": "test_multiple_date_cols_chunked","func arg: ": "(all_parsers)","comments: ": ""},"func22": {"source file: ": "test_parse_dates1.py","line number: ": "1026","func name: ": "test_multiple_date_col_named_index_compat","func arg: ": "(all_parsers)","comments: ": ""},"func23": {"source file: ": "test_parse_dates1.py","line number: ": "1049","func name: ": "test_multiple_date_col_multiple_index_compat","func arg: ": "(all_parsers)","comments: ": ""},"func24": {"source file: ": "test_parse_dates1.py","line number: ": "1070","func name: ": "test_read_with_parse_dates_scalar_non_bool","func arg: ": "(all_parsers, kwargs)","comments: ": ""},"func25": {"source file: ": "test_parse_dates1.py","line number: ": "1085","func name: ": "test_read_with_parse_dates_invalid_type","func arg: ": "(all_parsers, parse_dates)","comments: ": ""},"func26": {"source file: ": "test_parse_dates1.py","line number: ": "1100","func name: ": "test_bad_date_parse","func arg: ": "(all_parsers, cache_dates, value)","comments: ": ""},"func27": {"source file: ": "test_parse_dates1.py","line number: ": "1116","func name: ": "test_parse_dates_empty_string","func arg: ": "(all_parsers)","comments: ": ""},"func28": {"source file: ": "test_parse_dates1.py","line number: ": "1159","func name: ": "test_parse_dates_no_convert_thousands","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func29": {"source file: ": "test_parse_dates1.py","line number: ": "1167","func name: ": "test_parse_date_time_multi_level_column_name","func arg: ": "(all_parsers)","comments: ": ""},"func30": {"source file: ": "test_parse_dates1.py","line number: ": "1262","func name: ": "test_parse_date_time","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func31": {"source file: ": "test_parse_dates1.py","line number: ": "1273","func name: ": "test_parse_date_fields","func arg: ": "(all_parsers)","comments: ": ""},"func32": {"source file: ": "test_parse_dates1.py","line number: ": "1290","func name: ": "test_parse_date_all_fields","func arg: ": "(all_parsers)","comments: ": ""},"func33": {"source file: ": "test_parse_dates1.py","line number: ": "1313","func name: ": "test_datetime_fractional_seconds","func arg: ": "(all_parsers)","comments: ": ""},"func34": {"source file: ": "test_parse_dates1.py","line number: ": "1336","func name: ": "test_generic","func arg: ": "(all_parsers)","comments: ": ""},"func35": {"source file: ": "test_parse_dates1.py","line number: ": "1353","func name: ": "test_date_parser_resolution_if_not_ns","func arg: ": "(all_parsers)","comments: ": ""},"func36": {"source file: ": "test_parse_dates1.py","line number: ": "1386","func name: ": "test_parse_date_column_with_empty_string","func arg: ": "(all_parsers)","comments: ": ""},"func37": {"source file: ": "test_parse_dates1.py","line number: ": "1411","func name: ": "test_parse_date_float","func arg: ": "(all_parsers, data, expected, parse_dates)","comments: ": ""},"func38": {"source file: ": "test_parse_dates1.py","line number: ": "1422","func name: ": "test_parse_timezone","func arg: ": "(all_parsers)","comments: ": ""},"func39": {"source file: ": "test_parse_dates1.py","line number: ": "1449","func name: ": "test_invalid_parse_delimited_date","func arg: ": "(all_parsers, date_string)","comments: ": ""},"func40": {"source file: ": "test_parse_dates1.py","line number: ": "1469","func name: ": "test_parse_delimited_date_swap","func arg: ": "(all_parsers, date_string, dayfirst, expected)","comments: ": ""},"func41": {"source file: ": "test_parse_dates1.py","line number: ": "1478","func name: ": "_helper_hypothesis_delimited_date","func arg: ": "(call, date_string, **kwargs)","comments: ": ""},"func42": {"source file: ": "test_parse_dates1.py","line number: ": "1496","func name: ": "test_hypothesis_delimited_date","func arg: ": "(date_format, dayfirst, delimiter, test_datetime)","comments: ": ""}}{"func1": {"source file: ": "test_parse_iso8601.py","line number: ": "23","func name: ": "test_parsers_iso8601","func arg: ": "(date_str, exp)","comments: ": ""},"func2": {"source file: ": "test_parse_iso8601.py","line number: ": "53","func name: ": "test_parsers_iso8601_invalid","func arg: ": "(date_str)","comments: ": ""},"func3": {"source file: ": "test_parse_iso8601.py","line number: ": "60","func name: ": "test_parsers_iso8601_invalid_offset_invalid","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_parse_iso8601.py","line number: ": "68","func name: ": "test_parsers_iso8601_leading_space","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_parsing1.py","line number: ": "17","func name: ": "test_parse_time_string","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_parsing1.py","line number: ": "26","func name: ": "test_parse_time_string_invalid_type","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_parsing1.py","line number: ": "35","func name: ": "test_parse_time_quarter_with_dash","func arg: ": "(dashed, normal)","comments: ": ""},"func4": {"source file: ": "test_parsing1.py","line number: ": "46","func name: ": "test_parse_time_quarter_with_dash_error","func arg: ": "(dashed)","comments: ": ""},"func5": {"source file: ": "test_parsing1.py","line number: ": "69","func name: ": "test_does_not_convert_mixed_integer","func arg: ": "(date_string, expected)","comments: ": ""},"func6": {"source file: ": "test_parsing1.py","line number: ": "95","func name: ": "test_parsers_quarterly_with_freq_error","func arg: ": "(date_str, kwargs, msg)","comments: ": ""},"func7": {"source file: ": "test_parsing1.py","line number: ": "108","func name: ": "test_parsers_quarterly_with_freq","func arg: ": "(date_str, freq, expected)","comments: ": ""},"func8": {"source file: ": "test_parsing1.py","line number: ": "116","func name: ": "test_parsers_quarter_invalid","func arg: ": "(date_str)","comments: ": ""},"func9": {"source file: ": "test_parsing1.py","line number: ": "133","func name: ": "test_parsers_month_freq","func arg: ": "(date_str, expected)","comments: ": ""},"func10": {"source file: ": "test_parsing1.py","line number: ": "150","func name: ": "test_guess_datetime_format_with_parseable_formats","func arg: ": "(string, fmt)","comments: ": ""},"func11": {"source file: ": "test_parsing1.py","line number: ": "156","func name: ": "test_guess_datetime_format_with_dayfirst","func arg: ": "(dayfirst, expected)","comments: ": ""},"func12": {"source file: ": "test_parsing1.py","line number: ": "171","func name: ": "test_guess_datetime_format_with_locale_specific_formats","func arg: ": "(string, fmt)","comments: ": ""},"func13": {"source file: ": "test_parsing1.py","line number: ": "189","func name: ": "test_guess_datetime_format_invalid_inputs","func arg: ": "(invalid_dt)","comments: ": ""},"func14": {"source file: ": "test_parsing1.py","line number: ": "206","func name: ": "test_guess_datetime_format_no_padding","func arg: ": "(string, fmt)","comments: ": ""},"func15": {"source file: ": "test_parsing1.py","line number: ": "212","func name: ": "test_try_parse_dates","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_parsing1.py","line number: ": "220","func name: ": "test_parse_time_string_check_instance_type_raise_exception","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_partial_indexing1.py","line number: ": "9","func name: ": "test_partial_string_timestamp_multiindex","func arg: ": "()","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_partial1.py","line number: ": "186","func name: ": "test_loc_getitem_partial_both_axis","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_pct_change1.py","line number: ": "74","func name: ": "test_pct_change_with_duplicated_indices","func arg: ": "(fill_method)","comments: ": ""}}{"func1": {"source file: ": "test_pct_change2.py","line number: ": "82","func name: ": "test_pct_change_with_duplicated_indices","func arg: ": "(fill_method)","comments: ": ""}}{"func1": {"source file: ": "test_period_asfreq1.py","line number: ": "33","func name: ": "test_intra_day_conversion_factors","func arg: ": "(freq1, freq2, expected)","comments: ": ""},"func2": {"source file: ": "test_period_asfreq1.py","line number: ": "40","func name: ": "test_period_ordinal_start_values","func arg: ": "(freq, expected)","comments: ": ""},"func3": {"source file: ": "test_period_asfreq1.py","line number: ": "54","func name: ": "test_period_ordinal_week","func arg: ": "(dt, expected)","comments: ": ""},"func4": {"source file: ": "test_period_asfreq1.py","line number: ": "76","func name: ": "test_period_ordinal_business_day","func arg: ": "(day, expected)","comments: ": ""}}{"func1": {"source file: ": "test_period_index1.py","line number: ": "23","func name: ": "_index_factory","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_period_index1.py","line number: ": "28","func name: ": "_series_name","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_period1.py","line number: ": "18","func name: ": "test_registered","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_period1.py","line number: ": "42","func name: ": "test_period_array_ok","func arg: ": "(data, freq, expected)","comments: ": ""},"func3": {"source file: ": "test_period1.py","line number: ": "48","func name: ": "test_period_array_readonly_object","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_period1.py","line number: ": "64","func name: ": "test_from_datetime64_freq_changes","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_period1.py","line number: ": "83","func name: ": "test_period_array_raises","func arg: ": "(data, freq, msg)","comments: ": ""},"func6": {"source file: ": "test_period1.py","line number: ": "88","func name: ": "test_period_array_non_period_series_raies","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_period1.py","line number: ": "94","func name: ": "test_period_array_freq_mismatch","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_period1.py","line number: ": "103","func name: ": "test_asi8","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_period1.py","line number: ": "109","func name: ": "test_take_raises","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_period1.py","line number: ": "119","func name: ": "test_astype","func arg: ": "(dtype)","comments: ": ""},"func11": {"source file: ": "test_period1.py","line number: ": "135","func name: ": "test_astype_copies","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_period1.py","line number: ": "147","func name: ": "test_astype_categorical","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_period1.py","line number: ": "155","func name: ": "test_astype_period","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_period1.py","line number: ": "163","func name: ": "test_astype_datetime","func arg: ": "(other)","comments: ": ""},"func15": {"source file: ": "test_period1.py","line number: ": "170","func name: ": "test_fillna_raises","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_period1.py","line number: ": "176","func name: ": "test_fillna_copies","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_period1.py","line number: ": "200","func name: ": "test_setitem","func arg: ": "(key, value, expected)","comments: ": ""},"func18": {"source file: ": "test_period1.py","line number: ": "207","func name: ": "test_setitem_raises_incompatible_freq","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_period1.py","line number: ": "217","func name: ": "test_setitem_raises_length","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_period1.py","line number: ": "223","func name: ": "test_setitem_raises_type","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_period1.py","line number: ": "233","func name: ": "test_sub_period","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_period1.py","line number: ": "248","func name: ": "test_where_different_freq_raises","func arg: ": "(other)","comments: ": ""},"func23": {"source file: ": "test_period1.py","line number: ": "259","func name: ": "test_repr_small","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_period1.py","line number: ": "268","func name: ": "test_repr_large","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_period1.py","line number: ": "336","func name: ": "test_arrow_extension_type","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_period1.py","line number: ": "358","func name: ": "test_arrow_array","func arg: ": "(data, freq)","comments: ": ""},"func27": {"source file: ": "test_period1.py","line number: ": "382","func name: ": "test_arrow_array_missing","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_period1.py","line number: ": "397","func name: ": "test_arrow_table_roundtrip","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_period3.py","line number: ": "14","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_period3.py","line number: ": "19","func name: ": "data","func arg: ": "(dtype)","comments: ": ""},"func3": {"source file: ": "test_period3.py","line number: ": "24","func name: ": "data_for_twos","func arg: ": "(dtype)","comments: ": ""},"func4": {"source file: ": "test_period3.py","line number: ": "29","func name: ": "data_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func5": {"source file: ": "test_period3.py","line number: ": "34","func name: ": "data_missing","func arg: ": "(dtype)","comments: ": ""},"func6": {"source file: ": "test_period3.py","line number: ": "39","func name: ": "data_missing_for_sorting","func arg: ": "(dtype)","comments: ": ""},"func7": {"source file: ": "test_period3.py","line number: ": "44","func name: ": "data_for_grouping","func arg: ": "(dtype)","comments: ": ""},"func8": {"source file: ": "test_period3.py","line number: ": "53","func name: ": "na_value","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_period4.py","line number: ": "20","func name: ": "_permute","func arg: ": "(obj)","comments: ": ""}}{}{"func1": {"source file: ": "test_period6.py","line number: ": "1548","func name: ": "test_period_immutable","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_period6.py","line number: ": "1564","func name: ": "test_small_year_parsing","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_period7.py","line number: ": "655","func name: ": "test_maybe_convert_timedelta","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_pickle1.py","line number: ": "37","func name: ": "current_pickle_data","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_pickle1.py","line number: ": "47","func name: ": "compare_element","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func3": {"source file: ": "test_pickle1.py","line number: ": "68","func name: ": "compare","func arg: ": "(data, vf, version)","comments: ": ""},"func4": {"source file: ": "test_pickle1.py","line number: ": "86","func name: ": "compare_series_ts","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func5": {"source file: ": "test_pickle1.py","line number: ": "106","func name: ": "compare_series_dt_tz","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func6": {"source file: ": "test_pickle1.py","line number: ": "110","func name: ": "compare_series_cat","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func7": {"source file: ": "test_pickle1.py","line number: ": "114","func name: ": "compare_frame_dt_mixed_tzs","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func8": {"source file: ": "test_pickle1.py","line number: ": "118","func name: ": "compare_frame_cat_onecol","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func9": {"source file: ": "test_pickle1.py","line number: ": "122","func name: ": "compare_frame_cat_and_float","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func10": {"source file: ": "test_pickle1.py","line number: ": "126","func name: ": "compare_index_period","func arg: ": "(result, expected, typ, version)","comments: ": ""},"func11": {"source file: ": "test_pickle1.py","line number: ": "140","func name: ": "legacy_pickle","func arg: ": "(request, datapath)","comments: ": ""},"func12": {"source file: ": "test_pickle1.py","line number: ": "147","func name: ": "test_pickles","func arg: ": "(current_pickle_data, legacy_pickle)","comments: ": ""},"func13": {"source file: ": "test_pickle1.py","line number: ": "157","func name: ": "test_round_trip_current","func arg: ": "(current_pickle_data)","comments: ": ""},"func14": {"source file: ": "test_pickle1.py","line number: ": "188","func name: ": "test_pickle_path_pathlib","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_pickle1.py","line number: ": "194","func name: ": "test_pickle_path_localpath","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_pickle1.py","line number: ": "200","func name: ": "test_legacy_sparse_warning","func arg: ": "(datapath)","comments: ": "Generated with\n\n>>> df = pd.DataFrame({\"A\": [1, 2, 3, 4], \"B\": [0, 0, 1, 1]}).to_sparse() >>> df.to_pickle(\"pandas/tests/io/data/pickle/sparseframe-0.20.3.pickle.gz\", ...\n\n\n\n\n\n\n\n\n\n\n\n\n\ncompression=\"gzip\")\n\n>>> s = df['B'] >>> s.to_pickle(\"pandas/tests/io/data/pickle/sparseseries-0.20.3.pickle.gz\", ...\n\n\n\n\n\n\n\n\n\n\n\n compression=\"gzip\")\n"},"func17": {"source file: ": "test_pickle1.py","line number: ": "234","func name: ": "get_random_path","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_pickle1.py","line number: ": "395","func name: ": "test_unicode_decode_error","func arg: ": "(datapath, pickle_file, excols)","comments: ": ""},"func19": {"source file: ": "test_pickle1.py","line number: ": "410","func name: ": "test_pickle_buffer_roundtrip","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_pickle1.py","line number: ": "428","func name: ": "test_pickle_generalurl_read","func arg: ": "(monkeypatch, mockurl)","comments: ": ""},"func21": {"source file: ": "test_pickle1.py","line number: ": "461","func name: ": "test_pickle_gcsurl_roundtrip","func arg: ": "(monkeypatch, mockurl)","comments: ": ""},"func22": {"source file: ": "test_pickle1.py","line number: ": "482","func name: ": "test_pickle_s3url_roundtrip","func arg: ": "(monkeypatch, mockurl)","comments: ": ""}}{}{"func1": {"source file: ": "test_pivot1.py","line number: ": "24","func name: ": "dropna","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_pivot1.py","line number: ": "29","func name: ": "interval_values","func arg: ": "(request, closed)","comments: ": ""}}{"func1": {"source file: ": "test_printing1.py","line number: ": "12","func name: ": "test_adjoin","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_printing1.py","line number: ": "21","func name: ": "test_repr_binary_type","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_promote1.py","line number: ": "46","func name: ": "any_numpy_dtype_reduced","func arg: ": "(request)","comments: ": "Parameterized fixture for numpy dtypes, reduced from any_numpy_dtype.\n\n* bool * 'int32' * 'uint64' * 'float32' * 'float64' * 'complex64' * 'complex128' * 'M8[ns]' * 'M8[ns]' * str * bytes * object\n"},"func2": {"source file: ": "test_promote1.py","line number: ": "66","func name: ": "_check_promote","func arg: ": "(dtype, fill_value, expected_dtype, exp_val_for_scalar)","comments: ": "Auxiliary function to unify testing of scalar/array promotion.\n\nParameters ---------- dtype : dtype The value to pass on as the first argument to maybe_promote. fill_value : scalar The value to pass on as the second argument to maybe_promote as a scalar. expected_dtype : dtype The expected dtype returned by maybe_promote (by design this is the same regardless of whether fill_value was passed as a scalar or in an array!). exp_val_for_scalar : scalar The expected value for the (potentially upcast) fill_value returned by maybe_promote.\n"},"func3": {"source file: ": "test_promote1.py","line number: ": "97","func name: ": "_assert_match","func arg: ": "(result_fill_value, expected_fill_value)","comments: ": ""},"func4": {"source file: ": "test_promote1.py","line number: ": "230","func name: ": "test_maybe_promote_int_with_int","func arg: ": "(dtype, fill_value, expected_dtype)","comments: ": ""},"func5": {"source file: ": "test_promote1.py","line number: ": "240","func name: ": "test_maybe_promote_int_with_float","func arg: ": "(any_int_dtype, float_dtype)","comments: ": ""},"func6": {"source file: ": "test_promote1.py","line number: ": "255","func name: ": "test_maybe_promote_float_with_int","func arg: ": "(float_dtype, any_int_dtype)","comments: ": ""},"func7": {"source file: ": "test_promote1.py","line number: ": "297","func name: ": "test_maybe_promote_float_with_float","func arg: ": "(dtype, fill_value, expected_dtype)","comments: ": ""},"func8": {"source file: ": "test_promote1.py","line number: ": "308","func name: ": "test_maybe_promote_bool_with_any","func arg: ": "(any_numpy_dtype_reduced)","comments: ": ""},"func9": {"source file: ": "test_promote1.py","line number: ": "322","func name: ": "test_maybe_promote_any_with_bool","func arg: ": "(any_numpy_dtype_reduced)","comments: ": ""},"func10": {"source file: ": "test_promote1.py","line number: ": "334","func name: ": "test_maybe_promote_bytes_with_any","func arg: ": "(bytes_dtype, any_numpy_dtype_reduced)","comments: ": ""},"func11": {"source file: ": "test_promote1.py","line number: ": "348","func name: ": "test_maybe_promote_any_with_bytes","func arg: ": "(any_numpy_dtype_reduced, bytes_dtype)","comments: ": ""},"func12": {"source file: ": "test_promote1.py","line number: ": "362","func name: ": "test_maybe_promote_datetime64_with_any","func arg: ": "(datetime64_dtype, any_numpy_dtype_reduced)","comments: ": ""},"func13": {"source file: ": "test_promote1.py","line number: ": "391","func name: ": "test_maybe_promote_any_with_datetime64","func arg: ": "(any_numpy_dtype_reduced, datetime64_dtype, fill_value)","comments: ": ""},"func14": {"source file: ": "test_promote1.py","line number: ": "408","func name: ": "test_maybe_promote_datetimetz_with_any_numpy_dtype","func arg: ": "(tz_aware_fixture, any_numpy_dtype_reduced)","comments: ": ""},"func15": {"source file: ": "test_promote1.py","line number: ": "424","func name: ": "test_maybe_promote_datetimetz_with_datetimetz","func arg: ": "(tz_aware_fixture, tz_aware_fixture2)","comments: ": ""},"func16": {"source file: ": "test_promote1.py","line number: ": "442","func name: ": "test_maybe_promote_datetimetz_with_na","func arg: ": "(tz_aware_fixture, fill_value)","comments: ": ""},"func17": {"source file: ": "test_promote1.py","line number: ": "462","func name: ": "test_maybe_promote_any_numpy_dtype_with_datetimetz","func arg: ": "(any_numpy_dtype_reduced, tz_aware_fixture, fill_value)","comments: ": ""},"func18": {"source file: ": "test_promote1.py","line number: ": "477","func name: ": "test_maybe_promote_timedelta64_with_any","func arg: ": "(timedelta64_dtype, any_numpy_dtype_reduced)","comments: ": ""},"func19": {"source file: ": "test_promote1.py","line number: ": "501","func name: ": "test_maybe_promote_any_with_timedelta64","func arg: ": "(any_numpy_dtype_reduced, timedelta64_dtype, fill_value)","comments: ": ""},"func20": {"source file: ": "test_promote1.py","line number: ": "518","func name: ": "test_maybe_promote_string_with_any","func arg: ": "(string_dtype, any_numpy_dtype_reduced)","comments: ": ""},"func21": {"source file: ": "test_promote1.py","line number: ": "532","func name: ": "test_maybe_promote_any_with_string","func arg: ": "(any_numpy_dtype_reduced, string_dtype)","comments: ": ""},"func22": {"source file: ": "test_promote1.py","line number: ": "545","func name: ": "test_maybe_promote_object_with_any","func arg: ": "(object_dtype, any_numpy_dtype_reduced)","comments: ": ""},"func23": {"source file: ": "test_promote1.py","line number: ": "559","func name: ": "test_maybe_promote_any_with_object","func arg: ": "(any_numpy_dtype_reduced, object_dtype)","comments: ": ""},"func24": {"source file: ": "test_promote1.py","line number: ": "574","func name: ": "test_maybe_promote_any_numpy_dtype_with_na","func arg: ": "(any_numpy_dtype_reduced, fill_value)","comments: ": ""},"func25": {"source file: ": "test_promote1.py","line number: ": "607","func name: ": "test_maybe_promote_dimensions","func arg: ": "(any_numpy_dtype_reduced, dim)","comments: ": ""}}{"func1": {"source file: ": "test_pytables_missing1.py","line number: ": "10","func name: ": "test_pytables_raises","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_python_parser_only1.py","line number: ": "19","func name: ": "test_default_separator","func arg: ": "(python_parser_only)","comments: ": ""},"func2": {"source file: ": "test_python_parser_only1.py","line number: ": "32","func name: ": "test_invalid_skipfooter_non_int","func arg: ": "(python_parser_only, skipfooter)","comments: ": ""},"func3": {"source file: ": "test_python_parser_only1.py","line number: ": "42","func name: ": "test_invalid_skipfooter_negative","func arg: ": "(python_parser_only)","comments: ": ""},"func4": {"source file: ": "test_python_parser_only1.py","line number: ": "53","func name: ": "test_sniff_delimiter","func arg: ": "(python_parser_only, kwargs)","comments: ": ""},"func5": {"source file: ": "test_python_parser_only1.py","line number: ": "70","func name: ": "test_sniff_delimiter_encoding","func arg: ": "(python_parser_only, encoding)","comments: ": ""},"func6": {"source file: ": "test_python_parser_only1.py","line number: ": "98","func name: ": "test_single_line","func arg: ": "(python_parser_only)","comments: ": ""},"func7": {"source file: ": "test_python_parser_only1.py","line number: ": "108","func name: ": "test_skipfooter","func arg: ": "(python_parser_only, kwargs)","comments: ": ""},"func8": {"source file: ": "test_python_parser_only1.py","line number: ": "127","func name: ": "test_decompression_regex_sep","func arg: ": "(python_parser_only, csv1, compression, klass)","comments: ": ""},"func9": {"source file: ": "test_python_parser_only1.py","line number: ": "149","func name: ": "test_read_csv_buglet_4x_multi_index","func arg: ": "(python_parser_only)","comments: ": ""},"func10": {"source file: ": "test_python_parser_only1.py","line number: ": "174","func name: ": "test_read_csv_buglet_4x_multi_index2","func arg: ": "(python_parser_only)","comments: ": ""},"func11": {"source file: ": "test_python_parser_only1.py","line number: ": "189","func name: ": "test_skipfooter_with_decimal","func arg: ": "(python_parser_only, add_footer)","comments: ": ""},"func12": {"source file: ": "test_python_parser_only1.py","line number: ": "213","func name: ": "test_encoding_non_utf8_multichar_sep","func arg: ": "(python_parser_only, sep, encoding)","comments: ": ""},"func13": {"source file: ": "test_python_parser_only1.py","line number: ": "228","func name: ": "test_multi_char_sep_quotes","func arg: ": "(python_parser_only, quoting)","comments: ": ""},"func14": {"source file: ": "test_python_parser_only1.py","line number: ": "249","func name: ": "test_none_delimiter","func arg: ": "(python_parser_only, capsys)","comments: ": ""},"func15": {"source file: ": "test_python_parser_only1.py","line number: ": "269","func name: ": "test_skipfooter_bad_row","func arg: ": "(python_parser_only, data, skipfooter)","comments: ": ""},"func16": {"source file: ": "test_python_parser_only1.py","line number: ": "287","func name: ": "test_malformed_skipfooter","func arg: ": "(python_parser_only)","comments: ": ""}}{"func1": {"source file: ": "test_qcut1.py","line number: ": "29","func name: ": "test_qcut","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_qcut1.py","line number: ": "47","func name: ": "test_qcut_bounds","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_qcut1.py","line number: ": "54","func name: ": "test_qcut_specify_quantiles","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_qcut1.py","line number: ": "62","func name: ": "test_qcut_all_bins_same","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_qcut1.py","line number: ": "67","func name: ": "test_qcut_include_lowest","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_qcut1.py","line number: ": "82","func name: ": "test_qcut_nas","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_qcut1.py","line number: ": "90","func name: ": "test_qcut_index","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_qcut1.py","line number: ": "98","func name: ": "test_qcut_binning_issues","func arg: ": "(datapath)","comments: ": ""},"func9": {"source file: ": "test_qcut1.py","line number: ": "123","func name: ": "test_qcut_return_intervals","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_qcut1.py","line number: ": "135","func name: ": "test_qcut_incorrect_labels","func arg: ": "(labels)","comments: ": ""},"func11": {"source file: ": "test_qcut1.py","line number: ": "144","func name: ": "test_qcut_wrong_length_labels","func arg: ": "(labels)","comments: ": ""},"func12": {"source file: ": "test_qcut1.py","line number: ": "159","func name: ": "test_qcut_list_like_labels","func arg: ": "(labels, expected)","comments: ": ""},"func13": {"source file: ": "test_qcut1.py","line number: ": "175","func name: ": "test_qcut_duplicates_bin","func arg: ": "(kwargs, msg)","comments: ": ""},"func14": {"source file: ": "test_qcut1.py","line number: ": "193","func name: ": "test_single_quantile","func arg: ": "(data, start, end, length, labels)","comments: ": ""},"func15": {"source file: ": "test_qcut1.py","line number: ": "215","func name: ": "test_qcut_nat","func arg: ": "(ser)","comments: ": ""},"func16": {"source file: ": "test_qcut1.py","line number: ": "227","func name: ": "test_datetime_tz_qcut","func arg: ": "(bins)","comments: ": ""},"func17": {"source file: ": "test_qcut1.py","line number: ": "267","func name: ": "test_date_like_qcut_bins","func arg: ": "(arg, expected_bins)","comments: ": ""},"func18": {"source file: ": "test_qcut1.py","line number: ": "283","func name: ": "test_qcut_bool_coercion_to_int","func arg: ": "(bins, box, compare)","comments: ": ""},"func19": {"source file: ": "test_qcut1.py","line number: ": "293","func name: ": "test_qcut_nullable_integer","func arg: ": "(q, any_nullable_int_dtype)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_query_eval1.py","line number: ": "19","func name: ": "parser","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_query_eval1.py","line number: ": "24","func name: ": "engine","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_query_eval1.py","line number: ": "28","func name: ": "skip_if_no_pandas_parser","func arg: ": "(parser)","comments: ": ""}}{"func1": {"source file: ": "test_quoting1.py","line number: ": "28","func name: ": "test_bad_quote_char","func arg: ": "(all_parsers, kwargs, msg)","comments: ": ""},"func2": {"source file: ": "test_quoting1.py","line number: ": "43","func name: ": "test_bad_quoting","func arg: ": "(all_parsers, quoting, msg)","comments: ": ""},"func3": {"source file: ": "test_quoting1.py","line number: ": "51","func name: ": "test_quote_char_basic","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_quoting1.py","line number: ": "61","func name: ": "test_quote_char_various","func arg: ": "(all_parsers, quote_char)","comments: ": ""},"func5": {"source file: ": "test_quoting1.py","line number: ": "74","func name: ": "test_null_quote_char","func arg: ": "(all_parsers, quoting, quote_char)","comments: ": ""},"func6": {"source file: ": "test_quoting1.py","line number: ": "107","func name: ": "test_quoting_various","func arg: ": "(all_parsers, kwargs, exp_data)","comments: ": ""},"func7": {"source file: ": "test_quoting1.py","line number: ": "120","func name: ": "test_double_quote","func arg: ": "(all_parsers, doublequote, exp_data)","comments: ": ""},"func8": {"source file: ": "test_quoting1.py","line number: ": "130","func name: ": "test_quotechar_unicode","func arg: ": "(all_parsers, quotechar)","comments: ": ""},"func9": {"source file: ": "test_quoting1.py","line number: ": "141","func name: ": "test_unbalanced_quoting","func arg: ": "(all_parsers, balanced)","comments: ": ""}}{}{"func1": {"source file: ": "test_rank1.py","line number: ": "464","func name: ": "test_rank_dense_pct","func arg: ": "(dtype, ser, exp)","comments: ": ""},"func2": {"source file: ": "test_rank1.py","line number: ": "486","func name: ": "test_rank_min_pct","func arg: ": "(dtype, ser, exp)","comments: ": ""},"func3": {"source file: ": "test_rank1.py","line number: ": "508","func name: ": "test_rank_max_pct","func arg: ": "(dtype, ser, exp)","comments: ": ""},"func4": {"source file: ": "test_rank1.py","line number: ": "530","func name: ": "test_rank_average_pct","func arg: ": "(dtype, ser, exp)","comments: ": ""},"func5": {"source file: ": "test_rank1.py","line number: ": "552","func name: ": "test_rank_first_pct","func arg: ": "(dtype, ser, exp)","comments: ": ""},"func6": {"source file: ": "test_rank1.py","line number: ": "561","func name: ": "test_pct_max_many_rows","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_rank3.py","line number: ": "10","func name: ": "test_rank_apply","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_rank3.py","line number: ": "80","func name: ": "test_rank_args","func arg: ": "(grps, vals, ties_method, ascending, pct, exp)","comments: ": ""},"func3": {"source file: ": "test_rank3.py","line number: ": "129","func name: ": "test_infs_n_nans","func arg: ": "(grps, vals, ties_method, ascending, na_option, exp)","comments: ": ""},"func4": {"source file: ": "test_rank3.py","line number: ": "347","func name: ": "test_rank_args_missing","func arg: ": "(grps, vals, ties_method, ascending, na_option, pct, exp)","comments: ": ""},"func5": {"source file: ": "test_rank3.py","line number: ": "362","func name: ": "test_rank_resets_each_group","func arg: ": "(pct, exp)","comments: ": ""},"func6": {"source file: ": "test_rank3.py","line number: ": "371","func name: ": "test_rank_avg_even_vals","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_rank3.py","line number: ": "385","func name: ": "test_rank_object_raises","func arg: ": "(ties_method, ascending, na_option, pct, vals)","comments: ": ""},"func8": {"source file: ": "test_rank3.py","line number: ": "406","func name: ": "test_rank_naoption_raises","func arg: ": "(ties_method, ascending, na_option, pct, vals)","comments: ": ""},"func9": {"source file: ": "test_rank3.py","line number: ": "416","func name: ": "test_rank_empty_group","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_rank3.py","line number: ": "439","func name: ": "test_rank_zero_div","func arg: ": "(input_key, input_value, output_value)","comments: ": ""}}{"func1": {"source file: ": "test_read_fwf1.py","line number: ": "20","func name: ": "test_basic","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_read_fwf1.py","line number: ": "43","func name: ": "test_colspecs","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_read_fwf1.py","line number: ": "68","func name: ": "test_widths","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_read_fwf1.py","line number: ": "92","func name: ": "test_non_space_filler","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_read_fwf1.py","line number: ": "123","func name: ": "test_over_specified","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_read_fwf1.py","line number: ": "138","func name: ": "test_under_specified","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_read_fwf1.py","line number: ": "151","func name: ": "test_read_csv_compat","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_read_fwf1.py","line number: ": "175","func name: ": "test_bytes_io_input","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_read_fwf1.py","line number: ": "183","func name: ": "test_fwf_colspecs_is_list_or_tuple","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_read_fwf1.py","line number: ": "199","func name: ": "test_fwf_colspecs_is_list_or_tuple_of_two_element_tuples","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_read_fwf1.py","line number: ": "224","func name: ": "test_fwf_colspecs_none","func arg: ": "(colspecs, exp_data)","comments: ": ""},"func12": {"source file: ": "test_read_fwf1.py","line number: ": "245","func name: ": "test_fwf_colspecs_infer_nrows","func arg: ": "(infer_nrows, exp_data)","comments: ": ""},"func13": {"source file: ": "test_read_fwf1.py","line number: ": "257","func name: ": "test_fwf_regression","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_read_fwf1.py","line number: ": "303","func name: ": "test_fwf_for_uint8","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_read_fwf1.py","line number: ": "330","func name: ": "test_fwf_comment","func arg: ": "(comment)","comments: ": ""},"func16": {"source file: ": "test_read_fwf1.py","line number: ": "345","func name: ": "test_fwf_thousands","func arg: ": "(thousands)","comments: ": ""},"func17": {"source file: ": "test_read_fwf1.py","line number: ": "362","func name: ": "test_bool_header_arg","func arg: ": "(header)","comments: ": ""},"func18": {"source file: ": "test_read_fwf1.py","line number: ": "376","func name: ": "test_full_file","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_read_fwf1.py","line number: ": "393","func name: ": "test_full_file_with_missing","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_read_fwf1.py","line number: ": "410","func name: ": "test_full_file_with_spaces","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_read_fwf1.py","line number: ": "429","func name: ": "test_full_file_with_spaces_and_missing","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_read_fwf1.py","line number: ": "448","func name: ": "test_messed_up_data","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_read_fwf1.py","line number: ": "467","func name: ": "test_multiple_delimiters","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_read_fwf1.py","line number: ": "486","func name: ": "test_variable_width_unicode","func arg: ": "()","comments: ": ""},"func25": {"source file: ": "test_read_fwf1.py","line number: ": "505","func name: ": "test_dtype","func arg: ": "(dtype)","comments: ": ""},"func26": {"source file: ": "test_read_fwf1.py","line number: ": "523","func name: ": "test_skiprows_inference","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_read_fwf1.py","line number: ": "539","func name: ": "test_skiprows_by_index_inference","func arg: ": "()","comments: ": ""},"func28": {"source file: ": "test_read_fwf1.py","line number: ": "554","func name: ": "test_skiprows_inference_empty","func arg: ": "()","comments: ": ""},"func29": {"source file: ": "test_read_fwf1.py","line number: ": "566","func name: ": "test_whitespace_preservation","func arg: ": "()","comments: ": ""},"func30": {"source file: ": "test_read_fwf1.py","line number: ": "583","func name: ": "test_default_delimiter","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_read_fwf1.py","line number: ": "598","func name: ": "test_fwf_compression","func arg: ": "(compression_only, infer)","comments: ": ""}}{"func1": {"source file: ": "test_readers1.py","line number: ": "20","func name: ": "ignore_xlrd_time_clock_warning","func arg: ": "()","comments: ": "Context manager to ignore warnings raised by the xlrd library, regarding the deprecation of `time.clock` in Python 3.7.\n\n\n"},"func2": {"source file: ": "test_readers1.py","line number: ": "65","func name: ": "_is_valid_engine_ext_pair","func arg: ": "(engine, read_ext)","comments: ": "Filter out invalid (engine, ext) pairs instead of skipping, as that produces 500+ pytest.skips.\n\n\n"},"func3": {"source file: ": "test_readers1.py","line number: ": "84","func name: ": "_transfer_marks","func arg: ": "(engine, read_ext)","comments: ": "engine gives us a pytest.param objec with some marks, read_ext is just a string.  We need to generate a new pytest.param inheriting the marks.\n\n\n"},"func4": {"source file: ": "test_readers1.py","line number: ": "103","func name: ": "engine_and_read_ext","func arg: ": "(request)","comments: ": "Fixture for Excel reader engine and read_ext, only including valid pairs.\n\n\n"},"func5": {"source file: ": "test_readers1.py","line number: ": "111","func name: ": "engine","func arg: ": "(engine_and_read_ext)","comments: ": ""},"func6": {"source file: ": "test_readers1.py","line number: ": "117","func name: ": "read_ext","func arg: ": "(engine_and_read_ext)","comments: ": ""}}{"func1": {"source file: ": "test_readlines1.py","line number: ": "13","func name: ": "lines_json_df","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_readlines1.py","line number: ": "18","func name: ": "test_read_jsonl","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_readlines1.py","line number: ": "25","func name: ": "test_read_jsonl_unicode_chars","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_readlines1.py","line number: ": "43","func name: ": "test_to_jsonl","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_readlines1.py","line number: ": "65","func name: ": "test_readjson_chunks","func arg: ": "(lines_json_df, chunksize)","comments: ": ""},"func6": {"source file: ": "test_readlines1.py","line number: ": "77","func name: ": "test_readjson_chunksize_requires_lines","func arg: ": "(lines_json_df)","comments: ": ""},"func7": {"source file: ": "test_readlines1.py","line number: ": "83","func name: ": "test_readjson_chunks_series","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_readlines1.py","line number: ": "96","func name: ": "test_readjson_each_chunk","func arg: ": "(lines_json_df)","comments: ": ""},"func9": {"source file: ": "test_readlines1.py","line number: ": "104","func name: ": "test_readjson_chunks_from_file","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_readlines1.py","line number: ": "114","func name: ": "test_readjson_chunks_closes","func arg: ": "(chunksize)","comments: ": ""},"func11": {"source file: ": "test_readlines1.py","line number: ": "141","func name: ": "test_readjson_invalid_chunksize","func arg: ": "(lines_json_df, chunksize)","comments: ": ""},"func12": {"source file: ": "test_readlines1.py","line number: ": "149","func name: ": "test_readjson_chunks_multiple_empty_lines","func arg: ": "(chunksize)","comments: ": ""},"func13": {"source file: ": "test_readlines1.py","line number: ": "173","func name: ": "test_readjson_unicode","func arg: ": "(monkeypatch)","comments: ": ""}}{"func1": {"source file: ": "test_reductions1.py","line number: ": "28","func name: ": "get_objs","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_register_accessor1.py","line number: ": "10","func name: ": "ensure_removed","func arg: ": "(obj, attr)","comments: ": "Ensure that an attribute added to 'obj' during the test is removed when we're done\n\n\n"},"func2": {"source file: ": "test_register_accessor1.py","line number: ": "44","func name: ": "test_register","func arg: ": "(obj, registrar)","comments: ": ""},"func3": {"source file: ": "test_register_accessor1.py","line number: ": "55","func name: ": "test_accessor_works","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_register_accessor1.py","line number: ": "66","func name: ": "test_overwrite_warns","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_register_accessor1.py","line number: ": "82","func name: ": "test_raises_attribute_error","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_reindex1.py","line number: ": "9","func name: ": "test_reindex","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_reindex1.py","line number: ": "22","func name: ": "test_reindex_level","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_reindex1.py","line number: ": "46","func name: ": "test_reindex_preserves_names_when_target_is_list_or_ndarray","func arg: ": "(idx)","comments: ": ""},"func4": {"source file: ": "test_reindex1.py","line number: ": "71","func name: ": "test_reindex_lvl_preserves_names_when_target_is_list_or_array","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_reindex1.py","line number: ": "78","func name: ": "test_reindex_lvl_preserves_type_if_target_is_empty_list_or_array","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_reindex1.py","line number: ": "85","func name: ": "test_reindex_base","func arg: ": "(idx)","comments: ": ""},"func7": {"source file: ": "test_reindex1.py","line number: ": "96","func name: ": "test_reindex_non_unique","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_replace1.py","line number: ": "29","func name: ": "test_replace","func arg: ": "(to_replace, value, expected, check_types, check_categorical)","comments: ": ""}}{}{"func1": {"source file: ": "test_replace3.py","line number: ": "15","func name: ": "mix_ab","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_replace3.py","line number: ": "20","func name: ": "mix_abc","func arg: ": "()","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_resample_api1.py","line number: ": "19","func name: ": "test_frame","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_resample_api1.py","line number: ": "23","func name: ": "test_str","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_resample_api1.py","line number: ": "32","func name: ": "test_api","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_resample_api1.py","line number: ": "45","func name: ": "test_groupby_resample_api","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_resample_api1.py","line number: ": "69","func name: ": "test_groupby_resample_on_api","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_resample_api1.py","line number: ": "88","func name: ": "test_pipe","func arg: ": "(test_frame)","comments: ": ""},"func7": {"source file: ": "test_resample_api1.py","line number: ": "104","func name: ": "test_getitem","func arg: ": "(test_frame)","comments: ": ""},"func8": {"source file: ": "test_resample_api1.py","line number: ": "121","func name: ": "test_select_bad_cols","func arg: ": "(key, test_frame)","comments: ": ""},"func9": {"source file: ": "test_resample_api1.py","line number: ": "130","func name: ": "test_attribute_access","func arg: ": "(test_frame)","comments: ": ""},"func10": {"source file: ": "test_resample_api1.py","line number: ": "136","func name: ": "test_api_compat_before_use","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_resample_api1.py","line number: ": "153","func name: ": "tests_skip_nuisance","func arg: ": "(test_frame)","comments: ": ""},"func12": {"source file: ": "test_resample_api1.py","line number: ": "167","func name: ": "test_downsample_but_actually_upsampling","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_resample_api1.py","line number: ": "180","func name: ": "test_combined_up_downsampling_of_irregular","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_resample_api1.py","line number: ": "236","func name: ": "test_transform","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_resample_api1.py","line number: ": "244","func name: ": "test_fillna","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_resample_api1.py","line number: ": "267","func name: ": "test_apply_without_aggregation","func arg: ": "()","comments: ": ""},"func17": {"source file: ": "test_resample_api1.py","line number: ": "278","func name: ": "test_agg_consistency","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_resample_api1.py","line number: ": "299","func name: ": "test_agg","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_resample_api1.py","line number: ": "386","func name: ": "test_agg_misc","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_resample_api1.py","line number: ": "459","func name: ": "test_agg_nested_dicts","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_resample_api1.py","line number: ": "494","func name: ": "test_try_aggregate_non_existing_column","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_resample_api1.py","line number: ": "509","func name: ": "test_selection_api_validation","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_resample_api1.py","line number: ": "561","func name: ": "test_agg_with_datetime_index_list_agg_func","func arg: ": "(col_name)","comments: ": ""},"func24": {"source file: ": "test_resample_api1.py","line number: ": "585","func name: ": "test_resample_agg_readonly","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_resampler_grouper1.py","line number: ": "44","func name: ": "test_deferred_with_groupby","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_resampler_grouper1.py","line number: ": "87","func name: ": "test_getitem","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_resampler_grouper1.py","line number: ": "102","func name: ": "test_getitem_multiple","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_resampler_grouper1.py","line number: ": "124","func name: ": "test_groupby_resample_on_api_with_getitem","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_resampler_grouper1.py","line number: ": "134","func name: ": "test_nearest","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_resampler_grouper1.py","line number: ": "160","func name: ": "test_methods","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_resampler_grouper1.py","line number: ": "200","func name: ": "test_apply","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_resampler_grouper1.py","line number: ": "221","func name: ": "test_apply_with_mutated_index","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_resampler_grouper1.py","line number: ": "241","func name: ": "test_resample_groupby_with_label","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_resampler_grouper1.py","line number: ": "261","func name: ": "test_consistency_with_window","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_resampler_grouper1.py","line number: ": "275","func name: ": "test_median_duplicate_columns","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_reshape1.py","line number: ": "1071","func name: ": "test_unstack_fill_frame_object","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_reshape1.py","line number: ": "1093","func name: ": "test_unstack_timezone_aware_values","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_reshape1.py","line number: ": "1117","func name: ": "test_stack_timezone_aware_values","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_reshape1.py","line number: ": "1133","func name: ": "test_unstacking_multi_index_df","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_reshape3.py","line number: ": "9","func name: ": "test_insert","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_reshape3.py","line number: ": "85","func name: ": "test_append","func arg: ": "(idx)","comments: ": ""},"func3": {"source file: ": "test_reshape3.py","line number: ": "98","func name: ": "test_repeat","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_reshape3.py","line number: ": "108","func name: ": "test_insert_base","func arg: ": "(idx)","comments: ": ""},"func5": {"source file: ": "test_reshape3.py","line number: ": "116","func name: ": "test_delete_base","func arg: ": "(idx)","comments: ": ""}}{"func1": {"source file: ": "test_rolling1.py","line number: ": "366","func name: ": "test_rolling_window_as_string","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_rolling1.py","line number: ": "423","func name: ": "test_min_periods1","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_rolling1.py","line number: ": "432","func name: ": "test_rolling_count_with_min_periods","func arg: ": "(constructor)","comments: ": ""},"func4": {"source file: ": "test_rolling1.py","line number: ": "440","func name: ": "test_rolling_count_default_min_periods_with_null_values","func arg: ": "(constructor)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_s3(1).py","line number: ": "16","func name: ": "test_streaming_s3_objects","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_safe_import1.py","line number: ": "10","func name: ": "test_safe_import_non_existent","func arg: ": "(name)","comments: ": ""},"func2": {"source file: ": "test_safe_import1.py","line number: ": "14","func name: ": "test_safe_import_exists","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_safe_import1.py","line number: ": "19","func name: ": "test_safe_import_versions","func arg: ": "(min_version, valid)","comments: ": ""},"func4": {"source file: ": "test_safe_import1.py","line number: ": "28","func name: ": "test_safe_import_dummy","func arg: ": "(monkeypatch, min_version, valid)","comments: ": ""}}{}{"func1": {"source file: ": "test_sas7bdat1.py","line number: ": "119","func name: ": "test_encoding_options","func arg: ": "(datapath)","comments: ": ""},"func2": {"source file: ": "test_sas7bdat1.py","line number: ": "139","func name: ": "test_productsales","func arg: ": "(datapath)","comments: ": ""},"func3": {"source file: ": "test_sas7bdat1.py","line number: ": "149","func name: ": "test_12659","func arg: ": "(datapath)","comments: ": ""},"func4": {"source file: ": "test_sas7bdat1.py","line number: ": "158","func name: ": "test_airline","func arg: ": "(datapath)","comments: ": ""},"func5": {"source file: ": "test_sas7bdat1.py","line number: ": "167","func name: ": "test_date_time","func arg: ": "(datapath)","comments: ": ""},"func6": {"source file: ": "test_sas7bdat1.py","line number: ": "180","func name: ": "test_compact_numerical_values","func arg: ": "(datapath)","comments: ": ""},"func7": {"source file: ": "test_sas7bdat1.py","line number: ": "196","func name: ": "test_many_columns","func arg: ": "(datapath)","comments: ": ""},"func8": {"source file: ": "test_sas7bdat1.py","line number: ": "205","func name: ": "test_inconsistent_number_of_rows","func arg: ": "(datapath)","comments: ": ""},"func9": {"source file: ": "test_sas7bdat1.py","line number: ": "212","func name: ": "test_zero_variables","func arg: ": "(datapath)","comments: ": ""}}{}{}{}{}{}{}{}{}{"func1": {"source file: ": "test_setitem1.py","line number: ": "428","func name: ": "test_frame_setitem_view_direct","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func2": {"source file: ": "test_setitem1.py","line number: ": "436","func name: ": "test_frame_setitem_copy_raises","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func3": {"source file: ": "test_setitem1.py","line number: ": "444","func name: ": "test_frame_setitem_copy_no_write","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""}}{"func1": {"source file: ": "test_setops1.py","line number: ": "14","func name: ": "test_set_ops_error_cases","func arg: ": "(idx, case, sort, method)","comments: ": ""},"func2": {"source file: ": "test_setops1.py","line number: ": "22","func name: ": "test_intersection_base","func arg: ": "(idx, sort)","comments: ": ""},"func3": {"source file: ": "test_setops1.py","line number: ": "45","func name: ": "test_union_base","func arg: ": "(idx, sort)","comments: ": ""},"func4": {"source file: ": "test_setops1.py","line number: ": "68","func name: ": "test_difference_base","func arg: ": "(idx, sort)","comments: ": ""},"func5": {"source file: ": "test_setops1.py","line number: ": "91","func name: ": "test_symmetric_difference","func arg: ": "(idx, sort)","comments: ": ""},"func6": {"source file: ": "test_setops1.py","line number: ": "113","func name: ": "test_empty","func arg: ": "(idx)","comments: ": ""},"func7": {"source file: ": "test_setops1.py","line number: ": "120","func name: ": "test_difference","func arg: ": "(idx, sort)","comments: ": ""},"func8": {"source file: ": "test_setops1.py","line number: ": "186","func name: ": "test_difference_sort_special","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_setops1.py","line number: ": "195","func name: ": "test_difference_sort_special_true","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_setops1.py","line number: ": "203","func name: ": "test_difference_sort_incomparable","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_setops1.py","line number: ": "220","func name: ": "test_difference_sort_incomparable_true","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_setops1.py","line number: ": "231","func name: ": "test_union","func arg: ": "(idx, sort)","comments: ": ""},"func13": {"source file: ": "test_setops1.py","line number: ": "267","func name: ": "test_intersection","func arg: ": "(idx, sort)","comments: ": ""},"func14": {"source file: ": "test_setops1.py","line number: ": "292","func name: ": "test_intersect_equal_sort","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_setops1.py","line number: ": "300","func name: ": "test_intersect_equal_sort_true","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_setops1.py","line number: ": "308","func name: ": "test_union_sort_other_empty","func arg: ": "(slice_)","comments: ": ""},"func17": {"source file: ": "test_setops1.py","line number: ": "323","func name: ": "test_union_sort_other_empty_sort","func arg: ": "(slice_)","comments: ": ""},"func18": {"source file: ": "test_setops1.py","line number: ": "333","func name: ": "test_union_sort_other_incomparable","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_setops1.py","line number: ": "347","func name: ": "test_union_sort_other_incomparable_sort","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_setops1.py","line number: ": "358","func name: ": "test_setops_disallow_true","func arg: ": "(method)","comments: ": ""}}{"func1": {"source file: ": "test_setops2.py","line number: ": "9","func name: ": "name","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_setops2.py","line number: ": "14","func name: ": "sort","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_setops2.py","line number: ": "18","func name: ": "monotonic_index","func arg: ": "(start, end, dtype, closed)","comments: ": ""},"func4": {"source file: ": "test_setops2.py","line number: ": "22","func name: ": "empty_index","func arg: ": "(dtype, closed)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_setops5.py","line number: ": "27","func name: ": "index_pair","func arg: ": "(request)","comments: ": "Create all combinations of 2 index types.\n\n\n"},"func2": {"source file: ": "test_setops5.py","line number: ": "34","func name: ": "test_union_same_types","func arg: ": "(indices)","comments: ": ""},"func3": {"source file: ": "test_setops5.py","line number: ": "42","func name: ": "test_union_different_types","func arg: ": "(index_pair)","comments: ": ""},"func4": {"source file: ": "test_setops5.py","line number: ": "69","func name: ": "test_compatible_inconsistent_pairs","func arg: ": "(idx_fact1, idx_fact2)","comments: ": ""},"func5": {"source file: ": "test_setops5.py","line number: ": "101","func name: ": "test_union_dtypes","func arg: ": "(left, right, expected)","comments: ": ""}}{}{"func1": {"source file: ": "test_setops7.py","line number: ": "11","func name: ": "_permute","func arg: ": "(obj)","comments: ": ""}}{}{}{}{}{}{"func1": {"source file: ": "test_skiprows1.py","line number: ": "19","func name: ": "test_skip_rows_bug","func arg: ": "(all_parsers, skiprows)","comments: ": ""},"func2": {"source file: ": "test_skiprows1.py","line number: ": "45","func name: ": "test_deep_skip_rows","func arg: ": "(all_parsers)","comments: ": ""},"func3": {"source file: ": "test_skiprows1.py","line number: ": "60","func name: ": "test_skip_rows_blank","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_skiprows1.py","line number: ": "119","func name: ": "test_skip_row_with_newline","func arg: ": "(all_parsers, data, kwargs, expected)","comments: ": ""},"func5": {"source file: ": "test_skiprows1.py","line number: ": "126","func name: ": "test_skip_row_with_quote","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_skiprows1.py","line number: ": "167","func name: ": "test_skip_row_with_newline_and_quote","func arg: ": "(all_parsers, data, exp_data)","comments: ": ""},"func7": {"source file: ": "test_skiprows1.py","line number: ": "179","func name: ": "test_skiprows_lineterminator","func arg: ": "(all_parsers, line_terminator)","comments: ": ""},"func8": {"source file: ": "test_skiprows1.py","line number: ": "212","func name: ": "test_skiprows_infield_quote","func arg: ": "(all_parsers)","comments: ": ""},"func9": {"source file: ": "test_skiprows1.py","line number: ": "229","func name: ": "test_skip_rows_callable","func arg: ": "(all_parsers, kwargs, expected)","comments: ": ""},"func10": {"source file: ": "test_skiprows1.py","line number: ": "237","func name: ": "test_skip_rows_skip_all","func arg: ": "(all_parsers)","comments: ": ""},"func11": {"source file: ": "test_skiprows1.py","line number: ": "246","func name: ": "test_skip_rows_bad_callable","func arg: ": "(all_parsers)","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_sort_values_level_as_str1.py","line number: ": "11","func name: ": "df_none","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_sort_values_level_as_str1.py","line number: ": "23","func name: ": "df_idx","func arg: ": "(request, df_none)","comments: ": ""},"func3": {"source file: ": "test_sort_values_level_as_str1.py","line number: ": "40","func name: ": "sort_names","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "test_sort_values_level_as_str1.py","line number: ": "45","func name: ": "ascending","func arg: ": "(request)","comments: ": ""},"func5": {"source file: ": "test_sort_values_level_as_str1.py","line number: ": "49","func name: ": "test_sort_index_level_and_column_label","func arg: ": "(df_none, df_idx, sort_names, ascending)","comments: ": ""},"func6": {"source file: ": "test_sort_values_level_as_str1.py","line number: ": "67","func name: ": "test_sort_column_level_and_index_label","func arg: ": "(df_none, df_idx, sort_names, ascending)","comments: ": ""}}{}{}{}{}{"func1": {"source file: ": "test_sorting2.py","line number: ": "11","func name: ": "test_sortlevel","func arg: ": "(idx)","comments: ": ""},"func2": {"source file: ": "test_sorting2.py","line number: ": "35","func name: ": "test_sortlevel_not_sort_remaining","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_sorting2.py","line number: ": "41","func name: ": "test_sortlevel_deterministic","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_sorting2.py","line number: ": "69","func name: ": "test_sort","func arg: ": "(indices)","comments: ": ""},"func5": {"source file: ": "test_sorting2.py","line number: ": "74","func name: ": "test_numpy_argsort","func arg: ": "(idx)","comments: ": ""},"func6": {"source file: ": "test_sorting2.py","line number: ": "100","func name: ": "test_unsortedindex","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_sorting2.py","line number: ": "122","func name: ": "test_unsortedindex_doc_examples","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_sorting2.py","line number: ": "147","func name: ": "test_reconstruct_sort","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_sorting2.py","line number: ": "194","func name: ": "test_reconstruct_remove_unused","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_sorting2.py","line number: ": "229","func name: ": "test_remove_unused_levels_large","func arg: ": "(first_type, second_type)","comments: ": ""},"func11": {"source file: ": "test_sorting2.py","line number: ": "261","func name: ": "test_remove_unused_nan","func arg: ": "(level0, level1)","comments: ": ""},"func12": {"source file: ": "test_sorting2.py","line number: ": "273","func name: ": "test_argsort","func arg: ": "(idx)","comments: ": ""}}{"func1": {"source file: ": "test_sorting3.py","line number: ": "316","func name: ": "test_decons","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_sparse1.py","line number: ": "13","func name: ": "make_data","func arg: ": "(fill_value)","comments: ": ""},"func2": {"source file: ": "test_sparse1.py","line number: ": "26","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_sparse1.py","line number: ": "31","func name: ": "data","func arg: ": "(request)","comments: ": "Length-100 PeriodArray for semantics test.\n\n\n"},"func4": {"source file: ": "test_sparse1.py","line number: ": "38","func name: ": "data_for_twos","func arg: ": "(request)","comments: ": ""},"func5": {"source file: ": "test_sparse1.py","line number: ": "43","func name: ": "data_missing","func arg: ": "(request)","comments: ": "Length 2 array with [NA, Valid]\n\n\n"},"func6": {"source file: ": "test_sparse1.py","line number: ": "49","func name: ": "data_repeated","func arg: ": "(request)","comments: ": "Return different versions of data for count times\n\n\n"},"func7": {"source file: ": "test_sparse1.py","line number: ": "60","func name: ": "data_for_sorting","func arg: ": "(request)","comments: ": ""},"func8": {"source file: ": "test_sparse1.py","line number: ": "65","func name: ": "data_missing_for_sorting","func arg: ": "(request)","comments: ": ""},"func9": {"source file: ": "test_sparse1.py","line number: ": "70","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_sparse1.py","line number: ": "75","func name: ": "na_cmp","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_sparse1.py","line number: ": "80","func name: ": "data_for_grouping","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "test_spss1.py","line number: ": "10","func name: ": "test_spss_labelled_num","func arg: ": "(datapath)","comments: ": ""},"func2": {"source file: ": "test_spss1.py","line number: ": "24","func name: ": "test_spss_labelled_num_na","func arg: ": "(datapath)","comments: ": ""},"func3": {"source file: ": "test_spss1.py","line number: ": "38","func name: ": "test_spss_labelled_str","func arg: ": "(datapath)","comments: ": ""},"func4": {"source file: ": "test_spss1.py","line number: ": "52","func name: ": "test_spss_umlauts","func arg: ": "(datapath)","comments: ": ""},"func5": {"source file: ": "test_spss1.py","line number: ": "68","func name: ": "test_spss_usecols","func arg: ": "(datapath)","comments: ": ""}}{"func1": {"source file: ": "test_sql1.py","line number: ": "2293","func name: ": "date_format","func arg: ": "(dt)","comments: ": "Returns date in YYYYMMDD format.\n\n\n"},"func2": {"source file: ": "test_sql1.py","line number: ": "2311","func name: ": "format_query","func arg: ": "(sql)","comments: ": "\n\n\n"},"func3": {"source file: ": "test_sql1.py","line number: ": "2326","func name: ": "tquery","func arg: ": "(query, con, cur)","comments: ": "Replace removed sql.tquery function\n\n\n"}}{}{"func1": {"source file: ": "test_stata1.py","line number: ": "30","func name: ": "mixed_frame","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_stata1.py","line number: ": "41","func name: ": "dirpath","func arg: ": "(datapath)","comments: ": ""},"func3": {"source file: ": "test_stata1.py","line number: ": "46","func name: ": "parsed_114","func arg: ": "(dirpath)","comments: ": ""}}{}{"func1": {"source file: ": "test_string1.py","line number: ": "12","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_string1.py","line number: ": "24","func name: ": "test_none_to_nan","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_string1.py","line number: ": "30","func name: ": "test_setitem_validates","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_string1.py","line number: ": "39","func name: ": "test_setitem_with_scalar_string","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_string1.py","line number: ": "56","func name: ": "test_string_methods","func arg: ": "(input, method)","comments: ": ""},"func6": {"source file: ": "test_string1.py","line number: ": "66","func name: ": "test_astype_roundtrip","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_string1.py","line number: ": "74","func name: ": "test_add","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_string1.py","line number: ": "94","func name: ": "test_add_2d","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_string1.py","line number: ": "105","func name: ": "test_add_sequence","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_string1.py","line number: ": "118","func name: ": "test_mul","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_string1.py","line number: ": "129","func name: ": "test_add_strings","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_string1.py","line number: ": "144","func name: ": "test_add_frame","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_string1.py","line number: ": "159","func name: ": "test_comparison_methods_scalar","func arg: ": "(all_compare_operators)","comments: ": ""},"func14": {"source file: ": "test_string1.py","line number: ": "174","func name: ": "test_comparison_methods_array","func arg: ": "(all_compare_operators)","comments: ": ""},"func15": {"source file: ": "test_string1.py","line number: ": "190","func name: ": "test_constructor_raises","func arg: ": "()","comments: ": ""},"func16": {"source file: ": "test_string1.py","line number: ": "208","func name: ": "test_from_sequence_no_mutate","func arg: ": "(copy)","comments: ": ""},"func17": {"source file: ": "test_string1.py","line number: ": "219","func name: ": "test_reduce","func arg: ": "(skipna)","comments: ": ""},"func18": {"source file: ": "test_string1.py","line number: ": "227","func name: ": "test_reduce_missing","func arg: ": "(skipna)","comments: ": ""},"func19": {"source file: ": "test_string1.py","line number: ": "237","func name: ": "test_arrow_array","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_string1.py","line number: ": "248","func name: ": "test_arrow_roundtrip","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_string1.py","line number: ": "263","func name: ": "test_value_counts_na","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_string2.py","line number: ": "10","func name: ": "test_constructor_from_list","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_string3.py","line number: ": "12","func name: ": "dtype","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_string3.py","line number: ": "17","func name: ": "data","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_string3.py","line number: ": "26","func name: ": "data_missing","func arg: ": "()","comments: ": "Length 2 array with [NA, Valid]\n\n\n"},"func4": {"source file: ": "test_string3.py","line number: ": "32","func name: ": "data_for_sorting","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_string3.py","line number: ": "37","func name: ": "data_missing_for_sorting","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_string3.py","line number: ": "42","func name: ": "na_value","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_string3.py","line number: ": "47","func name: ": "data_for_grouping","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_strings1.py","line number: ": "16","func name: ": "assert_series_or_index_equal","func arg: ": "(left, right)","comments: ": ""},"func2": {"source file: ": "test_strings1.py","line number: ": "111","func name: ": "any_string_method","func arg: ": "(request)","comments: ": "Fixture for all public methods of `StringMethods`\n\nThis fixture returns a tuple of the method name and sample arguments necessary to call the method.\n##### Returns\n* **method_name **: str\nThe name of the method in `StringMethods`\n\n* **args **: tuple\nSample values for the positional arguments\n\n* **kwargs **: dict\nSample values for the keyword arguments\n\n* **>>> def test_something(any_string_method)**: \n\n"},"func3": {"source file: ": "test_strings1.py","line number: ": "152","func name: ": "any_allowed_skipna_inferred_dtype","func arg: ": "(request)","comments: ": "Fixture for all (inferred) dtypes allowed in StringMethods.__init__\n\nThe covered (inferred) types are: * 'string' * 'empty' * 'bytes' * 'mixed' * 'mixed-integer'\n##### Returns\n* **inferred_dtype **: str\nThe string for the inferred dtype from _libs.lib.infer_dtype\n\n* **values **: np.ndarray\nAn array of object dtype that will be inferred to have\n`inferred_dtype`\n\n* **>>> def test_something(any_allowed_skipna_inferred_dtype)**: \n\n"},"func4": {"source file: ": "test_strings1.py","line number: ": "3526","func name: ": "test_string_array","func arg: ": "(any_string_method)","comments: ": ""},"func5": {"source file: ": "test_strings1.py","line number: ": "3571","func name: ": "test_string_array_numeric_integer_array","func arg: ": "(method, expected)","comments: ": ""},"func6": {"source file: ": "test_strings1.py","line number: ": "3587","func name: ": "test_string_array_boolean_array","func arg: ": "(method, expected)","comments: ": ""},"func7": {"source file: ": "test_strings1.py","line number: ": "3594","func name: ": "test_string_array_extract","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_style1.py","line number: ": "1747","func name: ": "test_block_names","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_style1.py","line number: ": "1772","func name: ": "test_from_custom_template","func arg: ": "(tmpdir)","comments: ": ""}}{"func1": {"source file: ": "test_style2.py","line number: ": "24","func name: ": "test_styler_to_excel","func arg: ": "(engine)","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_take1.py","line number: ": "14","func name: ": "writeable","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_take1.py","line number: ": "37","func name: ": "dtype_can_hold_na","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_take1.py","line number: ": "67","func name: ": "dtype_fill_out_dtype","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "test_textreader1.py","line number: ": "345","func name: ": "assert_array_dicts_equal","func arg: ": "(left, right)","comments: ": ""}}{"func1": {"source file: ": "test_ticks1.py","line number: ": "27","func name: ": "test_apply_ticks","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_ticks1.py","line number: ": "33","func name: ": "test_delta_to_tick","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_ticks1.py","line number: ": "50","func name: ": "test_tick_add_sub","func arg: ": "(cls, n, m)","comments: ": ""},"func4": {"source file: ": "test_ticks1.py","line number: ": "69","func name: ": "test_tick_equality","func arg: ": "(cls, n, m)","comments: ": ""},"func5": {"source file: ": "test_ticks1.py","line number: ": "88","func name: ": "test_Hour","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_ticks1.py","line number: ": "100","func name: ": "test_Minute","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_ticks1.py","line number: ": "111","func name: ": "test_Second","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_ticks1.py","line number: ": "125","func name: ": "test_Millisecond","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_ticks1.py","line number: ": "146","func name: ": "test_MillisecondTimestampArithmetic","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_ticks1.py","line number: ": "155","func name: ": "test_Microsecond","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_ticks1.py","line number: ": "172","func name: ": "test_NanosecondGeneric","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_ticks1.py","line number: ": "183","func name: ": "test_Nanosecond","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_ticks1.py","line number: ": "210","func name: ": "test_tick_addition","func arg: ": "(kls, expected)","comments: ": ""},"func14": {"source file: ": "test_ticks1.py","line number: ": "218","func name: ": "test_tick_division","func arg: ": "(cls)","comments: ": ""},"func15": {"source file: ": "test_ticks1.py","line number: ": "246","func name: ": "test_tick_rdiv","func arg: ": "(cls)","comments: ": ""},"func16": {"source file: ": "test_ticks1.py","line number: ": "269","func name: ": "test_tick_zero","func arg: ": "(cls1, cls2)","comments: ": ""},"func17": {"source file: ": "test_ticks1.py","line number: ": "281","func name: ": "test_tick_equalities","func arg: ": "(cls)","comments: ": ""},"func18": {"source file: ": "test_ticks1.py","line number: ": "286","func name: ": "test_tick_offset","func arg: ": "(cls)","comments: ": ""},"func19": {"source file: ": "test_ticks1.py","line number: ": "291","func name: ": "test_compare_ticks","func arg: ": "(cls)","comments: ": ""},"func20": {"source file: ": "test_ticks1.py","line number: ": "304","func name: ": "test_compare_ticks_to_strs","func arg: ": "(cls)","comments: ": ""}}{"func1": {"source file: ": "test_time_grouper1.py","line number: ": "16","func name: ": "test_apply","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_time_grouper1.py","line number: ": "32","func name: ": "test_count","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_time_grouper1.py","line number: ": "47","func name: ": "test_numpy_reduction","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_time_grouper1.py","line number: ": "56","func name: ": "test_apply_iteration","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_time_grouper1.py","line number: ": "85","func name: ": "test_fails_on_no_datetime_index","func arg: ": "(name, func)","comments: ": ""},"func6": {"source file: ": "test_time_grouper1.py","line number: ": "98","func name: ": "test_aaa_group_order","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_time_grouper1.py","line number: ": "120","func name: ": "test_aggregate_normal","func arg: ": "(resample_method)","comments: ": "Check TimeGrouper's aggregation is identical as normal groupby.\n\n\n"},"func8": {"source file: ": "test_time_grouper1.py","line number: ": "170","func name: ": "test_resample_entirly_nat_window","func arg: ": "(method, method_args, unit)","comments: ": ""},"func9": {"source file: ": "test_time_grouper1.py","line number: ": "183","func name: ": "test_aggregate_with_nat","func arg: ": "(func, fill_value)","comments: ": ""},"func10": {"source file: ": "test_time_grouper1.py","line number: ": "216","func name: ": "test_aggregate_with_nat_size","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_time_grouper1.py","line number: ": "246","func name: ": "test_repr","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_time_grouper1.py","line number: ": "270","func name: ": "test_upsample_sum","func arg: ": "(method, method_args, expected_values)","comments: ": ""}}{}{"func1": {"source file: ": "test_timedelta1.py","line number: ": "821","func name: ": "test_truthiness","func arg: ": "(value, expected)","comments: ": ""}}{"func1": {"source file: ": "test_timedelta2.py","line number: ": "11","func name: ": "test_asfreq_bug","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_timedelta2.py","line number: ": "21","func name: ": "test_resample_with_nat","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_timedelta2.py","line number: ": "32","func name: ": "test_resample_as_freq_with_subperiod","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_timedelta2.py","line number: ": "44","func name: ": "test_resample_with_timedeltas","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_timedelta2.py","line number: ": "62","func name: ": "test_resample_single_period_timedelta","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_timedelta2.py","line number: ": "72","func name: ": "test_resample_timedelta_idempotency","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_timedelta2.py","line number: ": "82","func name: ": "test_resample_base_with_timedeltaindex","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_timedelta2.py","line number: ": "98","func name: ": "test_resample_categorical_data_with_timedeltaindex","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_timedelta2.py","line number: ": "112","func name: ": "test_resample_timedelta_values","func arg: ": "()","comments: ": ""}}{}{}{}{}{"func1": {"source file: ": "test_timedeltas2.py","line number: ": "21","func name: ": "test_delta_to_nanoseconds","func arg: ": "(obj, expected)","comments: ": ""},"func2": {"source file: ": "test_timedeltas2.py","line number: ": "26","func name: ": "test_delta_to_nanoseconds_error","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_timeseries1.py","line number: ": "29","func name: ": "_simple_ts","func arg: ": "(start, end, freq)","comments: ": ""},"func2": {"source file: ": "test_timeseries1.py","line number: ": "34","func name: ": "assert_range_equal","func arg: ": "(left, right)","comments: ": ""}}{"func1": {"source file: ": "test_timeseries2.py","line number: ": "25","func name: ": "close_open_fixture","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "test_timestamp1.py","line number: ": "1081","func name: ": "test_dt_subclass_add_timedelta","func arg: ": "(lh, rh)","comments: ": ""}}{"func1": {"source file: ": "test_timezones1.py","line number: ": "18","func name: ": "_compare_with_tz","func arg: ": "(a, b)","comments: ": ""},"func2": {"source file: ": "test_timezones1.py","line number: ": "32","func name: ": "test_append_with_timezones_dateutil","func arg: ": "(setup_path)","comments: ": ""},"func3": {"source file: ": "test_timezones1.py","line number: ": "134","func name: ": "test_append_with_timezones_pytz","func arg: ": "(setup_path)","comments: ": ""},"func4": {"source file: ": "test_timezones1.py","line number: ": "225","func name: ": "test_tseries_select_index_column","func arg: ": "(setup_path)","comments: ": ""},"func5": {"source file: ": "test_timezones1.py","line number: ": "258","func name: ": "test_timezones_fixed","func arg: ": "(setup_path)","comments: ": ""},"func6": {"source file: ": "test_timezones1.py","line number: ": "285","func name: ": "test_fixed_offset_tz","func arg: ": "(setup_path)","comments: ": ""},"func7": {"source file: ": "test_timezones1.py","line number: ": "297","func name: ": "test_store_timezone","func arg: ": "(setup_path)","comments: ": ""},"func8": {"source file: ": "test_timezones1.py","line number: ": "325","func name: ": "test_legacy_datetimetz_object","func arg: ": "(datapath, setup_path)","comments: ": ""},"func9": {"source file: ": "test_timezones1.py","line number: ": "341","func name: ": "test_dst_transitions","func arg: ": "(setup_path)","comments: ": ""},"func10": {"source file: ": "test_timezones1.py","line number: ": "360","func name: ": "test_read_with_where_tz_aware_index","func arg: ": "(setup_path)","comments: ": ""},"func11": {"source file: ": "test_timezones1.py","line number: ": "375","func name: ": "test_py2_created_with_datetimez","func arg: ": "(datapath, setup_path)","comments: ": ""}}{}{}{}{"func1": {"source file: ": "test_timezones5.py","line number: ": "13","func name: ": "test_cache_keys_are_distinct_for_pytz_vs_dateutil","func arg: ": "(tz_name)","comments: ": ""},"func2": {"source file: ": "test_timezones5.py","line number: ": "26","func name: ": "test_tzlocal_repr","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_timezones5.py","line number: ": "33","func name: ": "test_tzlocal_maybe_get_tz","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_timezones5.py","line number: ": "39","func name: ": "test_tzlocal_offset","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_timezones5.py","line number: ": "57","func name: ": "infer_setup","func arg: ": "(request)","comments: ": ""},"func6": {"source file: ": "test_timezones5.py","line number: ": "69","func name: ": "test_infer_tz_compat","func arg: ": "(infer_setup)","comments: ": ""},"func7": {"source file: ": "test_timezones5.py","line number: ": "86","func name: ": "test_infer_tz_utc_localize","func arg: ": "(infer_setup)","comments: ": ""},"func8": {"source file: ": "test_timezones5.py","line number: ": "97","func name: ": "test_infer_tz_mismatch","func arg: ": "(infer_setup, ordered)","comments: ": ""}}{}{}{}{}{}{"func1": {"source file: ": "test_to_excel1.py","line number: ": "208","func name: ": "test_css_to_excel","func arg: ": "(css, expected)","comments: ": ""},"func2": {"source file: ": "test_to_excel1.py","line number: ": "213","func name: ": "test_css_to_excel_multiple","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_to_excel1.py","line number: ": "257","func name: ": "test_css_to_excel_inherited","func arg: ": "(css, inherited, expected)","comments: ": ""},"func4": {"source file: ": "test_to_excel1.py","line number: ": "270","func name: ": "test_css_to_excel_good_colors","func arg: ": "(input_color, output_color)","comments: ": ""},"func5": {"source file: ": "test_to_excel1.py","line number: ": "297","func name: ": "test_css_to_excel_bad_colors","func arg: ": "(input_color)","comments: ": ""}}{"func1": {"source file: ": "test_to_html1.py","line number: ": "25","func name: ": "expected_html","func arg: ": "(datapath, name)","comments: ": "Read HTML file from formats data directory.\n\nParameters ---------- datapath : pytest fixture The datapath fixture injected into a test by pytest. name : str The name of the HTML file without the suffix.\n##### Returns\n* **str **: contents of HTML file.\n\n"},"func2": {"source file: ": "test_to_html1.py","line number: ": "48","func name: ": "biggie_df_fixture","func arg: ": "(request)","comments: ": "Fixture for a big mixed Dataframe and an empty Dataframe\n\n\n"},"func3": {"source file: ": "test_to_html1.py","line number: ": "64","func name: ": "justify","func arg: ": "(request)","comments: ": ""},"func4": {"source file: ": "test_to_html1.py","line number: ": "69","func name: ": "test_to_html_with_col_space","func arg: ": "(col_space)","comments: ": ""},"func5": {"source file: ": "test_to_html1.py","line number: ": "81","func name: ": "test_to_html_with_empty_string_label","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_to_html1.py","line number: ": "96","func name: ": "test_to_html_unicode","func arg: ": "(df, expected, datapath)","comments: ": ""},"func7": {"source file: ": "test_to_html1.py","line number: ": "102","func name: ": "test_to_html_encoding","func arg: ": "(float_frame, tmp_path)","comments: ": ""},"func8": {"source file: ": "test_to_html1.py","line number: ": "110","func name: ": "test_to_html_decimal","func arg: ": "(datapath)","comments: ": ""},"func9": {"source file: ": "test_to_html1.py","line number: ": "125","func name: ": "test_to_html_escaped","func arg: ": "(kwargs, string, expected, datapath)","comments: ": ""},"func10": {"source file: ": "test_to_html1.py","line number: ": "136","func name: ": "test_to_html_multiindex_index_false","func arg: ": "(index_is_named, datapath)","comments: ": ""},"func11": {"source file: ": "test_to_html1.py","line number: ": "158","func name: ": "test_to_html_multiindex_sparsify","func arg: ": "(multi_sparse, expected, datapath)","comments: ": ""},"func12": {"source file: ": "test_to_html1.py","line number: ": "177","func name: ": "test_to_html_multiindex_odd_even_truncate","func arg: ": "(max_rows, expected, datapath)","comments: ": ""},"func13": {"source file: ": "test_to_html1.py","line number: ": "218","func name: ": "test_to_html_formatters","func arg: ": "(df, formatters, expected, datapath)","comments: ": ""},"func14": {"source file: ": "test_to_html1.py","line number: ": "224","func name: ": "test_to_html_regression_GH6098","func arg: ": "()","comments: ": ""},"func15": {"source file: ": "test_to_html1.py","line number: ": "238","func name: ": "test_to_html_truncate","func arg: ": "(datapath)","comments: ": ""},"func16": {"source file: ": "test_to_html1.py","line number: ": "247","func name: ": "test_html_invalid_formatters_arg_raises","func arg: ": "(size)","comments: ": ""},"func17": {"source file: ": "test_to_html1.py","line number: ": "255","func name: ": "test_to_html_truncate_formatter","func arg: ": "(datapath)","comments: ": ""},"func18": {"source file: ": "test_to_html1.py","line number: ": "276","func name: ": "test_to_html_truncate_multi_index","func arg: ": "(sparsify, expected, datapath)","comments: ": ""},"func19": {"source file: ": "test_to_html1.py","line number: ": "296","func name: ": "test_to_html_border","func arg: ": "(option, result, expected)","comments: ": ""},"func20": {"source file: ": "test_to_html1.py","line number: ": "308","func name: ": "test_to_html","func arg: ": "(biggie_df_fixture)","comments: ": ""},"func21": {"source file: ": "test_to_html1.py","line number: ": "328","func name: ": "test_to_html_empty_dataframe","func arg: ": "(biggie_df_fixture)","comments: ": ""},"func22": {"source file: ": "test_to_html1.py","line number: ": "333","func name: ": "test_to_html_filename","func arg: ": "(biggie_df_fixture, tmpdir)","comments: ": ""},"func23": {"source file: ": "test_to_html1.py","line number: ": "342","func name: ": "test_to_html_with_no_bold","func arg: ": "()","comments: ": ""},"func24": {"source file: ": "test_to_html1.py","line number: ": "349","func name: ": "test_to_html_columns_arg","func arg: ": "(float_frame)","comments: ": ""},"func25": {"source file: ": "test_to_html1.py","line number: ": "372","func name: ": "test_to_html_multiindex","func arg: ": "(columns, justify, expected, datapath)","comments: ": ""},"func26": {"source file: ": "test_to_html1.py","line number: ": "379","func name: ": "test_to_html_justify","func arg: ": "(justify, datapath)","comments: ": ""},"func27": {"source file: ": "test_to_html1.py","line number: ": "392","func name: ": "test_to_html_invalid_justify","func arg: ": "(justify)","comments: ": ""},"func28": {"source file: ": "test_to_html1.py","line number: ": "401","func name: ": "test_to_html_index","func arg: ": "(datapath)","comments: ": ""},"func29": {"source file: ": "test_to_html1.py","line number: ": "441","func name: ": "test_to_html_with_classes","func arg: ": "(classes, datapath)","comments: ": ""},"func30": {"source file: ": "test_to_html1.py","line number: ": "448","func name: ": "test_to_html_no_index_max_rows","func arg: ": "(datapath)","comments: ": ""},"func31": {"source file: ": "test_to_html1.py","line number: ": "456","func name: ": "test_to_html_multiindex_max_cols","func arg: ": "(datapath)","comments: ": ""},"func32": {"source file: ": "test_to_html1.py","line number: ": "477","func name: ": "test_to_html_multi_indexes_index_false","func arg: ": "(datapath)","comments: ": ""},"func33": {"source file: ": "test_to_html1.py","line number: ": "520","func name: ": "test_to_html_basic_alignment","func arg: ": "(datapath, row_index, row_type, column_index, column_type, index, header, index_names)","comments: ": ""},"func34": {"source file: ": "test_to_html1.py","line number: ": "579","func name: ": "test_to_html_alignment_with_truncation","func arg: ": "(datapath, row_index, row_type, column_index, column_type, index, header, index_names)","comments: ": ""},"func35": {"source file: ": "test_to_html1.py","line number: ": "604","func name: ": "test_to_html_truncation_index_false_max_rows","func arg: ": "(datapath, index)","comments: ": ""},"func36": {"source file: ": "test_to_html1.py","line number: ": "624","func name: ": "test_to_html_truncation_index_false_max_cols","func arg: ": "(datapath, index, col_index_named, expected_output)","comments: ": ""},"func37": {"source file: ": "test_to_html1.py","line number: ": "641","func name: ": "test_to_html_notebook_has_style","func arg: ": "(notebook)","comments: ": ""},"func38": {"source file: ": "test_to_html1.py","line number: ": "655","func name: ": "test_to_html_with_index_names_false","func arg: ": "()","comments: ": ""},"func39": {"source file: ": "test_to_html1.py","line number: ": "662","func name: ": "test_to_html_with_id","func arg: ": "()","comments: ": ""},"func40": {"source file: ": "test_to_html1.py","line number: ": "676","func name: ": "test_to_html_float_format_no_fixed_width","func arg: ": "(value, float_format, expected, datapath)","comments: ": ""},"func41": {"source file: ": "test_to_html1.py","line number: ": "688","func name: ": "test_to_html_render_links","func arg: ": "(render_links, expected, datapath)","comments: ": ""},"func42": {"source file: ": "test_to_html1.py","line number: ": "709","func name: ": "test_ignore_display_max_colwidth","func arg: ": "(method, expected, max_colwidth)","comments: ": ""},"func43": {"source file: ": "test_to_html1.py","line number: ": "719","func name: ": "test_to_html_invalid_classes_type","func arg: ": "(classes)","comments: ": ""},"func44": {"source file: ": "test_to_html1.py","line number: ": "728","func name: ": "test_to_html_round_column_headers","func arg: ": "()","comments: ": ""},"func45": {"source file: ": "test_to_html1.py","line number: ": "739","func name: ": "test_to_html_with_col_space_units","func arg: ": "(unit)","comments: ": ""},"func46": {"source file: ": "test_to_html1.py","line number: ": "752","func name: ": "test_html_repr_min_rows_default","func arg: ": "(datapath)","comments: ": ""},"func47": {"source file: ": "test_to_html1.py","line number: ": "781","func name: ": "test_html_repr_min_rows","func arg: ": "(datapath, max_rows, min_rows, expected)","comments: ": ""}}{}{"func1": {"source file: ": "test_to_markdown1.py","line number: ": "10","func name: ": "test_simple","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_to_markdown1.py","line number: ": "20","func name: ": "test_other_tablefmt","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_to_markdown1.py","line number: ": "28","func name: ": "test_other_headers","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_to_markdown1.py","line number: ": "39","func name: ": "test_series","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_to_markdown1.py","line number: ": "50","func name: ": "test_no_buf","func arg: ": "(capsys)","comments: ": ""}}{"func1": {"source file: ": "test_to_offset1.py","line number: ": "35","func name: ": "test_to_offset","func arg: ": "(freq_input, expected)","comments: ": ""},"func2": {"source file: ": "test_to_offset1.py","line number: ": "43","func name: ": "test_to_offset_negative","func arg: ": "(freqstr, expected)","comments: ": ""},"func3": {"source file: ": "test_to_offset1.py","line number: ": "84","func name: ": "test_to_offset_invalid","func arg: ": "(freqstr)","comments: ": ""},"func4": {"source file: ": "test_to_offset1.py","line number: ": "94","func name: ": "test_to_offset_no_evaluate","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_to_offset1.py","line number: ": "110","func name: ": "test_to_offset_whitespace","func arg: ": "(freqstr, expected)","comments: ": ""},"func6": {"source file: ": "test_to_offset1.py","line number: ": "118","func name: ": "test_to_offset_leading_zero","func arg: ": "(freqstr, expected)","comments: ": ""},"func7": {"source file: ": "test_to_offset1.py","line number: ": "124","func name: ": "test_to_offset_leading_plus","func arg: ": "(freqstr, expected)","comments: ": ""},"func8": {"source file: ": "test_to_offset1.py","line number: ": "142","func name: ": "test_to_offset_pd_timedelta","func arg: ": "(kwargs, expected)","comments: ": ""},"func9": {"source file: ": "test_to_offset1.py","line number: ": "149","func name: ": "test_to_offset_pd_timedelta_invalid","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_to_offset1.py","line number: ": "174","func name: ": "test_anchored_shortcuts","func arg: ": "(shortcut, expected)","comments: ": ""}}{}{"func1": {"source file: ": "test_tools1.py","line number: ": "2109","func name: ": "units","func arg: ": "(request)","comments: ": "Day and some time units.\n\n* D * s * ms * us * ns\n"},"func2": {"source file: ": "test_tools1.py","line number: ": "2122","func name: ": "epoch_1960","func arg: ": "()","comments: ": "Timestamp at 1960-01-01.\n\n\n"},"func3": {"source file: ": "test_tools1.py","line number: ": "2128","func name: ": "units_from_epochs","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_tools1.py","line number: ": "2133","func name: ": "epochs","func arg: ": "(epoch_1960, request)","comments: ": "Timestamp at 1960-01-01 in various forms.\n\n* pd.Timestamp * datetime.datetime * numpy.datetime64 * str\n"},"func5": {"source file: ": "test_tools1.py","line number: ": "2153","func name: ": "julian_dates","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_tools1.py","line number: ": "2277","func name: ": "test_should_cache","func arg: ": "(listlike, do_caching)","comments: ": ""},"func7": {"source file: ": "test_tools1.py","line number: ": "2291","func name: ": "test_should_cache_errors","func arg: ": "(unique_share, check_count, err_message)","comments: ": ""},"func8": {"source file: ": "test_tools1.py","line number: ": "2298","func name: ": "test_nullable_integer_to_datetime","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_tools1.py","line number: ": "2321","func name: ": "test_na_to_datetime","func arg: ": "(nulls_fixture, klass)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_transform1.py","line number: ": "25","func name: ": "assert_fp_equal","func arg: ": "(a, b)","comments: ": ""},"func2": {"source file: ": "test_transform1.py","line number: ": "29","func name: ": "test_transform","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_transform1.py","line number: ": "83","func name: ": "test_transform_fast","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_transform1.py","line number: ": "134","func name: ": "test_transform_broadcast","func arg: ": "(tsframe, ts)","comments: ": ""},"func5": {"source file: ": "test_transform1.py","line number: ": "163","func name: ": "test_transform_axis","func arg: ": "(tsframe)","comments: ": ""},"func6": {"source file: ": "test_transform1.py","line number: ": "203","func name: ": "test_transform_dtype","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_transform1.py","line number: ": "212","func name: ": "test_transform_bug","func arg: ": "()","comments: ": ""},"func8": {"source file: ": "test_transform1.py","line number: ": "221","func name: ": "test_transform_numeric_to_boolean","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_transform1.py","line number: ": "235","func name: ": "test_transform_datetime_to_timedelta","func arg: ": "()","comments: ": ""},"func10": {"source file: ": "test_transform1.py","line number: ": "254","func name: ": "test_transform_datetime_to_numeric","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_transform1.py","line number: ": "275","func name: ": "test_transform_casting","func arg: ": "()","comments: ": ""},"func12": {"source file: ": "test_transform1.py","line number: ": "302","func name: ": "test_transform_multiple","func arg: ": "(ts)","comments: ": ""},"func13": {"source file: ": "test_transform1.py","line number: ": "309","func name: ": "test_dispatch_transform","func arg: ": "(tsframe)","comments: ": ""},"func14": {"source file: ": "test_transform1.py","line number: ": "320","func name: ": "test_transform_select_columns","func arg: ": "(df)","comments: ": ""},"func15": {"source file: ": "test_transform1.py","line number: ": "330","func name: ": "test_transform_exclude_nuisance","func arg: ": "(df)","comments: ": ""},"func16": {"source file: ": "test_transform1.py","line number: ": "344","func name: ": "test_transform_function_aliases","func arg: ": "(df)","comments: ": ""},"func17": {"source file: ": "test_transform1.py","line number: ": "354","func name: ": "test_series_fast_transform_date","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_transform1.py","line number: ": "370","func name: ": "test_transform_length","func arg: ": "()","comments: ": ""},"func19": {"source file: ": "test_transform1.py","line number: ": "388","func name: ": "test_transform_coercion","func arg: ": "()","comments: ": ""},"func20": {"source file: ": "test_transform1.py","line number: ": "401","func name: ": "test_groupby_transform_with_int","func arg: ": "()","comments: ": ""},"func21": {"source file: ": "test_transform1.py","line number: ": "447","func name: ": "test_groupby_transform_with_nan_group","func arg: ": "()","comments: ": ""},"func22": {"source file: ": "test_transform1.py","line number: ": "457","func name: ": "test_transform_mixed_type","func arg: ": "()","comments: ": ""},"func23": {"source file: ": "test_transform1.py","line number: ": "484","func name: ": "_check_cython_group_transform_cumulative","func arg: ": "(pd_op, np_op, dtype)","comments: ": "Check a group transform that executes a cumulative function.\n\nParameters ---------- pd_op : callable The pandas cumulative function. np_op : callable The analogous one in NumPy. dtype : type The specified dtype of the data.\n"},"func24": {"source file: ": "test_transform1.py","line number: ": "510","func name: ": "test_cython_group_transform_cumsum","func arg: ": "(any_real_dtype)","comments: ": ""},"func25": {"source file: ": "test_transform1.py","line number: ": "517","func name: ": "test_cython_group_transform_cumprod","func arg: ": "()","comments: ": ""},"func26": {"source file: ": "test_transform1.py","line number: ": "524","func name: ": "test_cython_group_transform_algos","func arg: ": "()","comments: ": ""},"func27": {"source file: ": "test_transform1.py","line number: ": "571","func name: ": "test_cython_transform_series","func arg: ": "(op, args, targop)","comments: ": ""},"func28": {"source file: ": "test_transform1.py","line number: ": "632","func name: ": "test_groupby_cum_skipna","func arg: ": "(op, skipna, input, exp)","comments: ": ""},"func29": {"source file: ": "test_transform1.py","line number: ": "652","func name: ": "test_cython_transform_frame","func arg: ": "(op, args, targop)","comments: ": ""},"func30": {"source file: ": "test_transform1.py","line number: ": "729","func name: ": "test_transform_with_non_scalar_group","func arg: ": "()","comments: ": ""},"func31": {"source file: ": "test_transform1.py","line number: ": "768","func name: ": "test_transform_numeric_ret","func arg: ": "(cols, exp, comp_func, agg_func, request)","comments: ": ""},"func32": {"source file: ": "test_transform1.py","line number: ": "808","func name: ": "test_group_fill_methods","func arg: ": "(mix_groupings, as_series, val1, val2, fill_method, limit, exp_vals)","comments: ": ""},"func33": {"source file: ": "test_transform1.py","line number: ": "851","func name: ": "test_pad_stable_sorting","func arg: ": "(fill_method)","comments: ": ""},"func34": {"source file: ": "test_transform1.py","line number: ": "883","func name: ": "test_pct_change","func arg: ": "(test_series, freq, periods, fill_method, limit)","comments: ": ""},"func35": {"source file: ": "test_transform1.py","line number: ": "916","func name: ": "test_ffill_bfill_non_unique_multilevel","func arg: ": "(func, expected_status)","comments: ": ""},"func36": {"source file: ": "test_transform1.py","line number: ": "945","func name: ": "test_any_all_np_func","func arg: ": "(func)","comments: ": ""},"func37": {"source file: ": "test_transform1.py","line number: ": "957","func name: ": "test_groupby_transform_rename","func arg: ": "()","comments: ": ""},"func38": {"source file: ": "test_transform1.py","line number: ": "979","func name: ": "test_groupby_transform_timezone_column","func arg: ": "(func)","comments: ": ""},"func39": {"source file: ": "test_transform1.py","line number: ": "995","func name: ": "test_groupby_transform_with_datetimes","func arg: ": "(func, values)","comments: ": ""},"func40": {"source file: ": "test_transform1.py","line number: ": "1010","func name: ": "test_transform_absent_categories","func arg: ": "(func)","comments: ": ""},"func41": {"source file: ": "test_transform1.py","line number: ": "1024","func name: ": "test_ffill_not_in_axis","func arg: ": "(func, key, val)","comments: ": ""},"func42": {"source file: ": "test_transform1.py","line number: ": "1033","func name: ": "test_transform_invalid_name_raises","func arg: ": "()","comments: ": ""},"func43": {"source file: ": "test_transform1.py","line number: ": "1060","func name: ": "test_transform_agg_by_name","func arg: ": "(reduction_func, obj)","comments: ": ""},"func44": {"source file: ": "test_transform1.py","line number: ": "1082","func name: ": "test_transform_lambda_with_datetimetz","func arg: ": "()","comments: ": ""},"func45": {"source file: ": "test_transform1.py","line number: ": "1106","func name: ": "test_transform_fastpath_raises","func arg: ": "()","comments: ": ""},"func46": {"source file: ": "test_transform1.py","line number: ": "1136","func name: ": "test_transform_lambda_indexing","func arg: ": "()","comments: ": ""}}{}{}{}{}{"func1": {"source file: ": "test_ufunc1.py","line number: ": "19","func name: ": "arrays_for_binary_ufunc","func arg: ": "()","comments: ": "A pair of random, length-100 integer-dtype arrays, that are mostly 0.\n\n\n"},"func2": {"source file: ": "test_ufunc1.py","line number: ": "32","func name: ": "test_unary_ufunc","func arg: ": "(ufunc, sparse)","comments: ": ""},"func3": {"source file: ": "test_ufunc1.py","line number: ": "51","func name: ": "test_binary_ufunc_with_array","func arg: ": "(flip, sparse, ufunc, arrays_for_binary_ufunc)","comments: ": ""},"func4": {"source file: ": "test_ufunc1.py","line number: ": "77","func name: ": "test_binary_ufunc_with_index","func arg: ": "(flip, sparse, ufunc, arrays_for_binary_ufunc)","comments: ": ""},"func5": {"source file: ": "test_ufunc1.py","line number: ": "106","func name: ": "test_binary_ufunc_with_series","func arg: ": "(flip, shuffle, sparse, ufunc, arrays_for_binary_ufunc)","comments: ": ""},"func6": {"source file: ": "test_ufunc1.py","line number: ": "147","func name: ": "test_binary_ufunc_scalar","func arg: ": "(ufunc, sparse, flip, arrays_for_binary_ufunc)","comments: ": ""},"func7": {"source file: ": "test_ufunc1.py","line number: ": "174","func name: ": "test_multiple_ouput_binary_ufuncs","func arg: ": "(ufunc, sparse, shuffle, arrays_for_binary_ufunc)","comments: ": ""},"func8": {"source file: ": "test_ufunc1.py","line number: ": "207","func name: ": "test_multiple_ouput_ufunc","func arg: ": "(sparse, arrays_for_binary_ufunc)","comments: ": ""},"func9": {"source file: ": "test_ufunc1.py","line number: ": "228","func name: ": "test_binary_ufunc_drops_series_name","func arg: ": "(ufunc, sparse, arrays_for_binary_ufunc)","comments: ": ""},"func10": {"source file: ": "test_ufunc1.py","line number: ": "238","func name: ": "test_object_series_ok","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_ufunc1.py","line number: ": "262","func name: ": "test_reduce","func arg: ": "(values)","comments: ": ""},"func12": {"source file: ": "test_ufunc1.py","line number: ": "268","func name: ": "test_binary_ufunc_other_types","func arg: ": "(type_)","comments: ": ""},"func13": {"source file: ": "test_ufunc1.py","line number: ": "277","func name: ": "test_object_dtype_ok","func arg: ": "()","comments: ": ""},"func14": {"source file: ": "test_ufunc1.py","line number: ": "298","func name: ": "test_outer","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_ujson1.py","line number: ": "23","func name: ": "_clean_dict","func arg: ": "(d)","comments: ": "Sanitize dictionary for JSON by converting all keys to strings.\n\nParameters ---------- d : dict The dictionary to convert.\n##### Returns\n* **cleaned_dict **: dict\n\n"},"func2": {"source file: ": "test_ujson1.py","line number: ": "43","func name: ": "orient","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_ujson1.py","line number: ": "48","func name: ": "numpy","func arg: ": "(request)","comments: ": ""}}{}{}{"func1": {"source file: ": "test_unsupported1.py","line number: ": "22","func name: ": "python_engine","func arg: ": "(request)","comments: ": ""}}{"func1": {"source file: ": "test_upcast1.py","line number: ": "11","func name: ": "test_upcast_error","func arg: ": "(result)","comments: ": ""},"func2": {"source file: ": "test_upcast1.py","line number: ": "36","func name: ": "test_upcast_scalar_other","func arg: ": "(arr, other)","comments: ": ""},"func3": {"source file: ": "test_upcast1.py","line number: ": "43","func name: ": "test_upcast","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_upcast1.py","line number: ": "54","func name: ": "test_upcast_datetime","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_usecols1.py","line number: ": "25","func name: ": "test_raise_on_mixed_dtype_usecols","func arg: ": "(all_parsers)","comments: ": ""},"func2": {"source file: ": "test_usecols1.py","line number: ": "39","func name: ": "test_usecols","func arg: ": "(all_parsers, usecols)","comments: ": ""},"func3": {"source file: ": "test_usecols1.py","line number: ": "53","func name: ": "test_usecols_with_names","func arg: ": "(all_parsers)","comments: ": ""},"func4": {"source file: ": "test_usecols1.py","line number: ": "71","func name: ": "test_usecols_relative_to_names","func arg: ": "(all_parsers, names, usecols)","comments: ": ""},"func5": {"source file: ": "test_usecols1.py","line number: ": "84","func name: ": "test_usecols_relative_to_names2","func arg: ": "(all_parsers)","comments: ": ""},"func6": {"source file: ": "test_usecols1.py","line number: ": "100","func name: ": "test_usecols_name_length_conflict","func arg: ": "(all_parsers)","comments: ": ""},"func7": {"source file: ": "test_usecols1.py","line number: ": "117","func name: ": "test_usecols_single_string","func arg: ": "(all_parsers)","comments: ": ""},"func8": {"source file: ": "test_usecols1.py","line number: ": "131","func name: ": "test_usecols_index_col_false","func arg: ": "(all_parsers, data)","comments: ": ""},"func9": {"source file: ": "test_usecols1.py","line number: ": "143","func name: ": "test_usecols_index_col_conflict","func arg: ": "(all_parsers, usecols, index_col)","comments: ": ""},"func10": {"source file: ": "test_usecols1.py","line number: ": "153","func name: ": "test_usecols_index_col_conflict2","func arg: ": "(all_parsers)","comments: ": ""},"func11": {"source file: ": "test_usecols1.py","line number: ": "167","func name: ": "test_usecols_implicit_index_col","func arg: ": "(all_parsers)","comments: ": ""},"func12": {"source file: ": "test_usecols1.py","line number: ": "177","func name: ": "test_usecols_regex_sep","func arg: ": "(all_parsers)","comments: ": ""},"func13": {"source file: ": "test_usecols1.py","line number: ": "187","func name: ": "test_usecols_with_whitespace","func arg: ": "(all_parsers)","comments: ": ""},"func14": {"source file: ": "test_usecols1.py","line number: ": "205","func name: ": "test_usecols_with_integer_like_header","func arg: ": "(all_parsers, usecols, expected)","comments: ": ""},"func15": {"source file: ": "test_usecols1.py","line number: ": "216","func name: ": "test_usecols_with_parse_dates","func arg: ": "(all_parsers, usecols)","comments: ": ""},"func16": {"source file: ": "test_usecols1.py","line number: ": "233","func name: ": "test_usecols_with_parse_dates2","func arg: ": "(all_parsers)","comments: ": ""},"func17": {"source file: ": "test_usecols1.py","line number: ": "266","func name: ": "test_usecols_with_parse_dates3","func arg: ": "(all_parsers)","comments: ": ""},"func18": {"source file: ": "test_usecols1.py","line number: ": "293","func name: ": "test_usecols_with_parse_dates4","func arg: ": "(all_parsers)","comments: ": ""},"func19": {"source file: ": "test_usecols1.py","line number: ": "324","func name: ": "test_usecols_with_parse_dates_and_names","func arg: ": "(all_parsers, usecols, names)","comments: ": ""},"func20": {"source file: ": "test_usecols1.py","line number: ": "343","func name: ": "test_usecols_with_unicode_strings","func arg: ": "(all_parsers)","comments: ": ""},"func21": {"source file: ": "test_usecols1.py","line number: ": "361","func name: ": "test_usecols_with_single_byte_unicode_strings","func arg: ": "(all_parsers)","comments: ": ""},"func22": {"source file: ": "test_usecols1.py","line number: ": "380","func name: ": "test_usecols_with_mixed_encoding_strings","func arg: ": "(all_parsers, usecols)","comments: ": ""},"func23": {"source file: ": "test_usecols1.py","line number: ": "392","func name: ": "test_usecols_with_multi_byte_characters","func arg: ": "(all_parsers, usecols)","comments: ": ""},"func24": {"source file: ": "test_usecols1.py","line number: ": "409","func name: ": "test_empty_usecols","func arg: ": "(all_parsers)","comments: ": ""},"func25": {"source file: ": "test_usecols1.py","line number: ": "418","func name: ": "test_np_array_usecols","func arg: ": "(all_parsers)","comments: ": ""},"func26": {"source file: ": "test_usecols1.py","line number: ": "449","func name: ": "test_callable_usecols","func arg: ": "(all_parsers, usecols, expected)","comments: ": ""},"func27": {"source file: ": "test_usecols1.py","line number: ": "462","func name: ": "test_incomplete_first_row","func arg: ": "(all_parsers, usecols)","comments: ": ""},"func28": {"source file: ": "test_usecols1.py","line number: ": "498","func name: ": "test_uneven_length_cols","func arg: ": "(all_parsers, data, usecols, kwargs, expected)","comments: ": ""},"func29": {"source file: ": "test_usecols1.py","line number: ": "548","func name: ": "test_raises_on_usecols_names_mismatch","func arg: ": "(all_parsers, usecols, kwargs, expected, msg)","comments: ": ""},"func30": {"source file: ": "test_usecols1.py","line number: ": "565","func name: ": "test_usecols_subset_names_mismatch_orig_columns","func arg: ": "(all_parsers, usecols)","comments: ": ""}}{"func1": {"source file: ": "test_util1.py","line number: ": "10","func name: ": "test_rands","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_util1.py","line number: ": "15","func name: ": "test_rands_array_1d","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_util1.py","line number: ": "21","func name: ": "test_rands_array_2d","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_util1.py","line number: ": "27","func name: ": "test_numpy_err_state_is_default","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_util1.py","line number: ": "35","func name: ": "test_convert_rows_list_to_csv_str","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_util1.py","line number: ": "47","func name: ": "test_create_temp_directory","func arg: ": "()","comments: ": ""},"func7": {"source file: ": "test_util1.py","line number: ": "55","func name: ": "test_datapath_missing","func arg: ": "(datapath)","comments: ": ""},"func8": {"source file: ": "test_util1.py","line number: ": "60","func name: ": "test_datapath","func arg: ": "(datapath)","comments: ": ""},"func9": {"source file: ": "test_util1.py","line number: ": "69","func name: ": "test_rng_context","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_validate_args_and_kwargs1.py","line number: ": "8","func name: ": "test_invalid_total_length_max_length_one","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_validate_args_and_kwargs1.py","line number: ": "26","func name: ": "test_invalid_total_length_max_length_multiple","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_validate_args_and_kwargs1.py","line number: ": "45","func name: ": "test_missing_args_or_kwargs","func arg: ": "(args, kwargs)","comments: ": ""},"func4": {"source file: ": "test_validate_args_and_kwargs1.py","line number: ": "60","func name: ": "test_duplicate_argument","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_validate_args_and_kwargs1.py","line number: ": "73","func name: ": "test_validation","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_validate_args1.py","line number: ": "8","func name: ": "test_bad_min_fname_arg_count","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_validate_args1.py","line number: ": "15","func name: ": "test_bad_arg_length_max_value_single","func arg: ": "()","comments: ": ""},"func3": {"source file: ": "test_validate_args1.py","line number: ": "31","func name: ": "test_bad_arg_length_max_value_multiple","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_validate_args1.py","line number: ": "48","func name: ": "test_not_all_defaults","func arg: ": "(i)","comments: ": ""},"func5": {"source file: ": "test_validate_args1.py","line number: ": "62","func name: ": "test_validation","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_validate_kwargs1.py","line number: ": "8","func name: ": "test_bad_kwarg","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_validate_kwargs1.py","line number: ": "22","func name: ": "test_not_all_none","func arg: ": "(i)","comments: ": ""},"func3": {"source file: ": "test_validate_kwargs1.py","line number: ": "40","func name: ": "test_validation","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_validate_kwargs1.py","line number: ": "50","func name: ": "test_validate_bool_kwarg_fail","func arg: ": "(name, value)","comments: ": ""},"func5": {"source file: ": "test_validate_kwargs1.py","line number: ": "62","func name: ": "test_validate_bool_kwarg","func arg: ": "(name, value)","comments: ": ""}}{}{"func1": {"source file: ": "test_validate2.py","line number: ": "7","func name: ": "dataframe","func arg: ": "()","comments: ": ""}}{}{"func1": {"source file: ": "test_value_counts2.py","line number: ": "17","func name: ": "seed_df","func arg: ": "(seed_nans, n, m)","comments: ": ""},"func2": {"source file: ": "test_value_counts2.py","line number: ": "60","func name: ": "test_series_groupby_value_counts","func arg: ": "(df, keys, bins, n, m, isort, normalize, sort, ascending, dropna)","comments: ": ""},"func3": {"source file: ": "test_value_counts2.py","line number: ": "84","func name: ": "test_series_groupby_value_counts_with_grouper","func arg: ": "()","comments: ": ""}}{}{}{"func1": {"source file: ": "test_whitelist1.py","line number: ": "54","func name: ": "df_whitelist_fixture","func arg: ": "(request)","comments: ": ""},"func2": {"source file: ": "test_whitelist1.py","line number: ": "82","func name: ": "s_whitelist_fixture","func arg: ": "(request)","comments: ": ""},"func3": {"source file: ": "test_whitelist1.py","line number: ": "87","func name: ": "mframe","func arg: ": "()","comments: ": ""},"func4": {"source file: ": "test_whitelist1.py","line number: ": "97","func name: ": "df","func arg: ": "()","comments: ": ""},"func5": {"source file: ": "test_whitelist1.py","line number: ": "109","func name: ": "df_letters","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_whitelist1.py","line number: ": "123","func name: ": "test_groupby_whitelist","func arg: ": "(df_letters, whitelist)","comments: ": ""},"func7": {"source file: ": "test_whitelist1.py","line number: ": "136","func name: ": "check_whitelist","func arg: ": "(obj, df, m)","comments: ": ""},"func8": {"source file: ": "test_whitelist1.py","line number: ": "158","func name: ": "test_groupby_series_whitelist","func arg: ": "(df_letters, s_whitelist_fixture)","comments: ": ""},"func9": {"source file: ": "test_whitelist1.py","line number: ": "164","func name: ": "test_groupby_frame_whitelist","func arg: ": "(df_letters, df_whitelist_fixture)","comments: ": ""},"func10": {"source file: ": "test_whitelist1.py","line number: ": "171","func name: ": "raw_frame","func arg: ": "()","comments: ": ""},"func11": {"source file: ": "test_whitelist1.py","line number: ": "190","func name: ": "test_regression_whitelist_methods","func arg: ": "(raw_frame, op, level, axis, skipna, sort)","comments: ": ""},"func12": {"source file: ": "test_whitelist1.py","line number: ": "216","func name: ": "test_groupby_blacklist","func arg: ": "(df_letters)","comments: ": ""},"func13": {"source file: ": "test_whitelist1.py","line number: ": "260","func name: ": "test_tab_completion","func arg: ": "(mframe)","comments: ": ""},"func14": {"source file: ": "test_whitelist1.py","line number: ": "335","func name: ": "test_groupby_function_rename","func arg: ": "(mframe)","comments: ": ""},"func15": {"source file: ": "test_whitelist1.py","line number: ": "342","func name: ": "test_groupby_selection_with_methods","func arg: ": "(df)","comments: ": ""},"func16": {"source file: ": "test_whitelist1.py","line number: ": "393","func name: ": "test_all_methods_categorized","func arg: ": "(mframe)","comments: ": ""}}{}{"func1": {"source file: ": "test_writers1.py","line number: ": "26","func name: ": "path","func arg: ": "(ext)","comments: ": "Fixture to open file for use in each test case.\n\n\n"},"func2": {"source file: ": "test_writers1.py","line number: ": "35","func name: ": "set_engine","func arg: ": "(engine, ext)","comments: ": "Fixture to set engine for use in each test case.\n\nRather than requiring `engine=...` to be provided explicitly as an argument in each test, this fixture sets a global option to dictate which engine should be used to write Excel files. After executing the test it rolls back said change to the global option.\n"}}{"func1": {"source file: ": "test_xlrd1.py","line number: ": "13","func name: ": "skip_ods_and_xlsb_files","func arg: ": "(read_ext)","comments: ": ""},"func2": {"source file: ": "test_xlrd1.py","line number: ": "20","func name: ": "test_read_xlrd_book","func arg: ": "(read_ext, frame)","comments: ": ""},"func3": {"source file: ": "test_xlrd1.py","line number: ": "39","func name: ": "test_excel_table_sheet_by_index","func arg: ": "(datapath, read_ext)","comments: ": ""}}{"func1": {"source file: ": "test_xlsxwriter1.py","line number: ": "15","func name: ": "test_column_format","func arg: ": "(ext)","comments: ": ""},"func2": {"source file: ": "test_xlsxwriter1.py","line number: ": "59","func name: ": "test_write_append_mode_raises","func arg: ": "(ext)","comments: ": ""}}{"func1": {"source file: ": "test_xlwt1.py","line number: ": "15","func name: ": "test_excel_raise_error_on_multiindex_columns_and_no_index","func arg: ": "(ext)","comments: ": ""},"func2": {"source file: ": "test_xlwt1.py","line number: ": "26","func name: ": "test_excel_multiindex_columns_and_index_true","func arg: ": "(ext)","comments: ": ""},"func3": {"source file: ": "test_xlwt1.py","line number: ": "35","func name: ": "test_excel_multiindex_index","func arg: ": "(ext)","comments: ": ""},"func4": {"source file: ": "test_xlwt1.py","line number: ": "45","func name: ": "test_to_excel_styleconverter","func arg: ": "(ext)","comments: ": ""},"func5": {"source file: ": "test_xlwt1.py","line number: ": "62","func name: ": "test_write_append_mode_raises","func arg: ": "(ext)","comments: ": ""}}{"func1": {"source file: ": "test_xport1.py","line number: ": "17","func name: ": "numeric_as_float","func arg: ": "(data)","comments: ": ""}}{"func1": {"source file: ": "test_xs1.py","line number: ": "10","func name: ": "four_level_index_dataframe","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_xs1.py","line number: ": "33","func name: ": "test_xs_named_levels_axis_eq_1","func arg: ": "(key, level, exp_arr, exp_index)","comments: ": ""},"func3": {"source file: ": "test_xs1.py","line number: ": "47","func name: ": "test_xs_values","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func4": {"source file: ": "test_xs1.py","line number: ": "54","func name: ": "test_xs_loc_equality","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func5": {"source file: ": "test_xs1.py","line number: ": "61","func name: ": "test_xs_missing_values_in_index","func arg: ": "()","comments: ": ""},"func6": {"source file: ": "test_xs1.py","line number: ": "84","func name: ": "test_xs_with_duplicates","func arg: ": "(key, level, multiindex_dataframe_random_data)","comments: ": ""},"func7": {"source file: ": "test_xs1.py","line number: ": "95","func name: ": "test_xs_level","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func8": {"source file: ": "test_xs1.py","line number: ": "103","func name: ": "test_xs_level_eq_2","func arg: ": "()","comments: ": ""},"func9": {"source file: ": "test_xs1.py","line number: ": "122","func name: ": "test_xs_level_multiple","func arg: ": "(indexer, four_level_index_dataframe)","comments: ": ""},"func10": {"source file: ": "test_xs1.py","line number: ": "133","func name: ": "test_xs_setting_with_copy_error","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func11": {"source file: ": "test_xs1.py","line number: ": "145","func name: ": "test_xs_setting_with_copy_error_multiple","func arg: ": "(four_level_index_dataframe)","comments: ": ""},"func12": {"source file: ": "test_xs1.py","line number: ": "157","func name: ": "test_xs_integer_key","func arg: ": "()","comments: ": ""},"func13": {"source file: ": "test_xs1.py","line number: ": "172","func name: ": "test_xs_level0","func arg: ": "(indexer, four_level_index_dataframe)","comments: ": ""},"func14": {"source file: ": "test_xs1.py","line number: ": "189","func name: ": "test_xs_level_series","func arg: ": "(multiindex_dataframe_random_data)","comments: ": ""},"func15": {"source file: ": "test_xs1.py","line number: ": "199","func name: ": "test_xs_level_series_ymd","func arg: ": "(multiindex_year_month_day_dataframe_random_data)","comments: ": ""},"func16": {"source file: ": "test_xs1.py","line number: ": "209","func name: ": "test_xs_level_series_slice_not_implemented","func arg: ": "(multiindex_year_month_day_dataframe_random_data)","comments: ": ""},"func17": {"source file: ": "test_xs1.py","line number: ": "223","func name: ": "test_series_getitem_multiindex_xs","func arg: ": "()","comments: ": ""},"func18": {"source file: ": "test_xs1.py","line number: ": "234","func name: ": "test_series_getitem_multiindex_xs_by_label","func arg: ": "()","comments: ": ""}}{"func1": {"source file: ": "test_yqm_offsets1.py","line number: ": "33","func name: ": "test_quarterly_dont_normalize","func arg: ": "()","comments: ": ""},"func2": {"source file: ": "test_yqm_offsets1.py","line number: ": "61","func name: ": "test_apply_index","func arg: ": "(cls, n)","comments: ": ""},"func3": {"source file: ": "test_yqm_offsets1.py","line number: ": "80","func name: ": "test_on_offset","func arg: ": "(offset)","comments: ": ""}}{"func1": {"source file: ": "tile1.py","line number: ": "32","func name: ": "cut","func arg: ": "(x, bins, right, labels, retbins, precision, include_lowest, duplicates)","comments: ": "Bin values into discrete intervals.\n\nUse `cut` when you need to segment and sort data values into bins. This function is also useful for going from a continuous variable to a categorical variable. For example, `cut` could convert ages to groups of age ranges. Supports binning into an equal number of bins, or a pre-specified array of bins.\n\nParameters ---------- x : array-like The input array to be binned. Must be 1-dimensional. bins : int, sequence of scalars, or IntervalIndex The criteria to bin by.\n\n* int : Defines the number of equal-width bins in the range of `x`. The range of `x` is extended by .1% on each side to include the minimum and maximum values of `x`. * sequence of scalars : Defines the bin edges allowing for non-uniform width. No extension of the range of `x` is done. * IntervalIndex : Defines the exact bins to be used. Note that IntervalIndex for `bins` must be non-overlapping.\n\nright : bool, default True Indicates whether `bins` includes the rightmost edge or not. If ``right == True`` (the default), then the `bins` ``[1, 2, 3, 4]`` indicate (1,2], (2,3], (3,4]. This argument is ignored when `bins` is an IntervalIndex. labels : array or False, default None Specifies the labels for the returned bins. Must be the same length as the resulting bins. If False, returns only integer indicators of the bins. This affects the type of the output container (see below). This argument is ignored when `bins` is an IntervalIndex. If True, raises an error. retbins : bool, default False Whether to return the bins or not. Useful when bins is provided as a scalar. precision : int, default 3 The precision at which to store and display the bins labels. include_lowest : bool, default False Whether the first interval should be left-inclusive or not. duplicates : {default 'raise', 'drop'}, optional If bin edges are not unique, raise ValueError or drop non-uniques.\n\n.. versionadded:: 0.23.0\n##### Returns\n* **out **: Categorical, Series, or ndarray\nAn array-like object representing the respective bin for each value\nof `x`. The type depends on the value of `labels`.\n* True (default)\n\n* **bins **: numpy.ndarray or IntervalIndex.\nThe computed or specified bins. Only returned when `retbins=True`.\nFor scalar or sequence `bins`, this is an ndarray with the computed\nbins. If set `duplicates=drop`, `bins` will drop non-unique bin. For\nan IntervalIndex `bins`, this is equal to `bins`.\n\n* **qcut **: Discretize variable into equal-sized buckets based on rank\nor based on sample quantiles.\n\n* **Categorical **: Array type for storing data that come from a\nfixed set of values.\n\n* **Series **: One-dimensional array with axis labels (including time series).\n\n* **IntervalIndex **: Immutable Index implementing an ordered, sliceable set.\n\n* **... # doctest**: +ELLIPSIS\n\n* **Categories (3, interval[float64])**: [(1.992, 4.667] < (4.667, ...\n\n* **Categories (3, object)**: [bad < medium < good]\n\n* **Passing a Series as an input returns a Series with categorical dtype**: \n\n* **dtype**: category\n\n* **(a0.0\n b1.0\n c2.0\n d3.0\n e4.0\n dtype**: float64, array([0, 2, 4, 6, 8]))\n\n* **(a0.0\n b1.0\n c2.0\n d3.0\n e3.0\n dtype**: float64, array([0, 2, 4, 6, 8]))\n\n* **Categories (3, interval[int64])**: [(0, 1] < (2, 3] < (4, 5]]\n\n"},"func2": {"source file: ": "tile1.py","line number: ": "271","func name: ": "qcut","func arg: ": "(x, q, labels, retbins, precision, duplicates)","comments: ": "Quantile-based discretization function.\n\nDiscretize variable into equal-sized buckets based on rank or based on sample quantiles. For example 1000 values for 10 quantiles would produce a Categorical object indicating quantile membership for each data point.\n\nParameters ---------- x : 1d ndarray or Series q : int or list-like of int Number of quantiles. 10 for deciles, 4 for quartiles, etc. Alternately array of quantiles, e.g. [0, .25, .5, .75, 1.] for quartiles. labels : array or False, default None Used as labels for the resulting bins. Must be of the same length as the resulting bins. If False, return only integer indicators of the bins. If True, raises an error. retbins : bool, optional Whether to return the (bins, labels) or not. Can be useful if bins is given as a scalar. precision : int, optional The precision at which to store and display the bins labels. duplicates : {default 'raise', 'drop'}, optional If bin edges are not unique, raise ValueError or drop non-uniques.\n##### Returns\n* **out **: Categorical or Series or array of integers if labels is False\nThe return type (Categorical or Series) depends on the input\n\n* **bins **: ndarray of floats\nReturned only if `retbins` is True.\n\n* **... # doctest**: +SKIP\n\n* **Categories (4, interval[float64])**: [(-0.001, 1.0] < (1.0, 2.0] ...\n\n* **Categories (3, object)**: [good < medium < bad]\n\n"},"func3": {"source file: ": "tile1.py","line number: ": "354","func name: ": "_bins_to_cuts","func arg: ": "(x, bins, right, labels, precision, include_lowest, dtype, duplicates)","comments: ": ""},"func4": {"source file: ": "tile1.py","line number: ": "429","func name: ": "_coerce_to_type","func arg: ": "(x)","comments: ": "if the passed data is of datetime/timedelta, bool or nullable int type, this method converts it to numeric so that cut or qcut method can handle it\n\n\n"},"func5": {"source file: ": "tile1.py","line number: ": "462","func name: ": "_convert_bin_to_numeric_type","func arg: ": "(bins, dtype)","comments: ": "if the passed bin is of datetime/timedelta type, this method converts it to integer\n\nParameters ---------- bins : list-like of bins dtype : dtype of data\n"},"func6": {"source file: ": "tile1.py","line number: ": "491","func name: ": "_convert_bin_to_datelike_type","func arg: ": "(bins, dtype)","comments: ": "Convert bins to a DatetimeIndex or TimedeltaIndex if the original dtype is datelike\n\nParameters ---------- bins : list-like of bins dtype : dtype of data\n##### Returns\n* **bins **: Array-like of bins, DatetimeIndex or TimedeltaIndex if dtype is\n   datelike\n\n"},"func7": {"source file: ": "tile1.py","line number: ": "513","func name: ": "_format_labels","func arg: ": "(bins, precision, right, include_lowest, dtype)","comments: ": "based on the dtype, return our labels\n\n\n"},"func8": {"source file: ": "tile1.py","line number: ": "542","func name: ": "_preprocess_for_cut","func arg: ": "(x)","comments: ": "handles preprocessing for cut where we convert passed input to array, strip the index information and store it separately\n\n\n"},"func9": {"source file: ": "tile1.py","line number: ": "560","func name: ": "_postprocess_for_cut","func arg: ": "(fac, bins, retbins, dtype, original)","comments: ": "handles post processing for the cut method where we combine the index information if the originally passed datatype was a series\n\n\n"},"func10": {"source file: ": "tile1.py","line number: ": "577","func name: ": "_round_frac","func arg: ": "(x, precision)","comments: ": "Round the fractional part of the given number\n\n\n"},"func11": {"source file: ": "tile1.py","line number: ": "592","func name: ": "_infer_precision","func arg: ": "(base_precision, bins)","comments: ": "Infer an appropriate precision for _round_frac\n\n\n"}}{"func1": {"source file: ": "tile2.py","line number: ": "23","func name: ": "cut","func arg: ": "(x, bins, right, labels, retbins, precision, include_lowest, duplicates)","comments: ": "Bin values into discrete intervals.\n\nUse `cut` when you need to segment and sort data values into bins. This function is also useful for going from a continuous variable to a categorical variable. For example, `cut` could convert ages to groups of age ranges. Supports binning into an equal number of bins, or a pre-specified array of bins.\n\nParameters ---------- x : array-like The input array to be binned. Must be 1-dimensional. bins : int, sequence of scalars, or pandas.IntervalIndex The criteria to bin by.\n\n* int : Defines the number of equal-width bins in the range of `x`. The range of `x` is extended by .1% on each side to include the minimum and maximum values of `x`. * sequence of scalars : Defines the bin edges allowing for non-uniform width. No extension of the range of `x` is done. * IntervalIndex : Defines the exact bins to be used. Note that IntervalIndex for `bins` must be non-overlapping.\n\nright : bool, default True Indicates whether `bins` includes the rightmost edge or not. If ``right == True`` (the default), then the `bins` ``[1, 2, 3, 4]`` indicate (1,2], (2,3], (3,4]. This argument is ignored when `bins` is an IntervalIndex. labels : array or bool, optional Specifies the labels for the returned bins. Must be the same length as the resulting bins. If False, returns only integer indicators of the bins. This affects the type of the output container (see below). This argument is ignored when `bins` is an IntervalIndex. retbins : bool, default False Whether to return the bins or not. Useful when bins is provided as a scalar. precision : int, default 3 The precision at which to store and display the bins labels. include_lowest : bool, default False Whether the first interval should be left-inclusive or not. duplicates : {default 'raise', 'drop'}, optional If bin edges are not unique, raise ValueError or drop non-uniques.\n\n.. versionadded:: 0.23.0\n##### Returns\n* **out **: pandas.Categorical, Series, or ndarray\nAn array-like object representing the respective bin for each value\nof `x`. The type depends on the value of `labels`.\n* True (default)\n\n* **bins **: numpy.ndarray or IntervalIndex.\nThe computed or specified bins. Only returned when `retbins=True`.\nFor scalar or sequence `bins`, this is an ndarray with the computed\nbins. If set `duplicates=drop`, `bins` will drop non-unique bin. For\nan IntervalIndex `bins`, this is equal to `bins`.\n\n* **qcut **: Discretize variable into equal-sized buckets based on rank\nor based on sample quantiles.\n\n* **pandas.Categorical **: Array type for storing data that come from a\nfixed set of values.\n\n* **Series **: One-dimensional array with axis labels (including time series).\n\n* **pandas.IntervalIndex **: Immutable Index implementing an ordered,\nsliceable set.\n\n* **... # doctest**: +ELLIPSIS\n\n* **Categories (3, interval[float64])**: [(1.992, 4.667] < (4.667, ...\n\n* **Categories (3, object)**: [bad < medium < good]\n\n* **Passing a Series as an input returns a Series with categorical dtype**: \n\n* **dtype**: category\n\n* **(a0.0\n b1.0\n c2.0\n d3.0\n e4.0\n dtype**: float64, array([0, 2, 4, 6, 8]))\n\n* **(a0.0\n b1.0\n c2.0\n d3.0\n e3.0\n dtype**: float64, array([0, 2, 4, 6, 8]))\n\n* **Categories (3, interval[int64])**: [(0, 1] < (2, 3] < (4, 5]]\n\n"},"func2": {"source file: ": "tile2.py","line number: ": "247","func name: ": "qcut","func arg: ": "(x, q, labels, retbins, precision, duplicates)","comments: ": "Quantile-based discretization function. Discretize variable into equal-sized buckets based on rank or based on sample quantiles. For example 1000 values for 10 quantiles would produce a Categorical object indicating quantile membership for each data point.\n\nParameters ---------- x : 1d ndarray or Series q : integer or array of quantiles Number of quantiles. 10 for deciles, 4 for quartiles, etc. Alternately array of quantiles, e.g. [0, .25, .5, .75, 1.] for quartiles labels : array or boolean, default None Used as labels for the resulting bins. Must be of the same length as the resulting bins. If False, return only integer indicators of the bins. retbins : bool, optional Whether to return the (bins, labels) or not. Can be useful if bins is given as a scalar. precision : int, optional The precision at which to store and display the bins labels duplicates : {default 'raise', 'drop'}, optional If bin edges are not unique, raise ValueError or drop non-uniques.\n\n.. versionadded:: 0.20.0\n##### Returns\n* **out **: Categorical or Series or array of integers if labels is False\nThe return type (Categorical or Series) depends on the input\n\n* **bins **: ndarray of floats\nReturned only if `retbins` is True.\n\n* **... # doctest**: +SKIP\n\n* **Categories (4, interval[float64])**: [(-0.001, 1.0] < (1.0, 2.0] ...\n\n* **Categories (3, object)**: [good < medium < bad]\n\n"},"func3": {"source file: ": "tile2.py","line number: ": "319","func name: ": "_bins_to_cuts","func arg: ": "(x, bins, right, labels, precision, include_lowest, dtype, duplicates)","comments: ": ""},"func4": {"source file: ": "tile2.py","line number: ": "376","func name: ": "_trim_zeros","func arg: ": "(x)","comments: ": ""},"func5": {"source file: ": "tile2.py","line number: ": "384","func name: ": "_coerce_to_type","func arg: ": "(x)","comments: ": "if the passed data is of datetime/timedelta type, this method converts it to numeric so that cut method can handle it\n\n\n"},"func6": {"source file: ": "tile2.py","line number: ": "408","func name: ": "_convert_bin_to_numeric_type","func arg: ": "(bins, dtype)","comments: ": "if the passed bin is of datetime/timedelta type, this method converts it to integer\n\nParameters ---------- bins : list-like of bins dtype : dtype of data\n"},"func7": {"source file: ": "tile2.py","line number: ": "437","func name: ": "_convert_bin_to_datelike_type","func arg: ": "(bins, dtype)","comments: ": "Convert bins to a DatetimeIndex or TimedeltaIndex if the orginal dtype is datelike\n\nParameters ---------- bins : list-like of bins dtype : dtype of data\n##### Returns\n* **bins **: Array-like of bins, DatetimeIndex or TimedeltaIndex if dtype is\n   datelike\n\n"},"func8": {"source file: ": "tile2.py","line number: ": "460","func name: ": "_format_labels","func arg: ": "(bins, precision, right, include_lowest, dtype)","comments: ": "based on the dtype, return our labels\n\n\n"},"func9": {"source file: ": "tile2.py","line number: ": "494","func name: ": "_preprocess_for_cut","func arg: ": "(x)","comments: ": "handles preprocessing for cut where we convert passed input to array, strip the index information and store it separately\n\n\n"},"func10": {"source file: ": "tile2.py","line number: ": "519","func name: ": "_postprocess_for_cut","func arg: ": "(fac, bins, retbins, x_is_series, series_index, name, dtype)","comments: ": "handles post processing for the cut method where we combine the index information if the originally passed datatype was a series\n\n\n"},"func11": {"source file: ": "tile2.py","line number: ": "537","func name: ": "_round_frac","func arg: ": "(x, precision)","comments: ": "Round the fractional part of the given number\n\n\n"},"func12": {"source file: ": "tile2.py","line number: ": "552","func name: ": "_infer_precision","func arg: ": "(base_precision, bins)","comments: ": "Infer an appropriate precision for _round_frac\n\n\n"}}{"func1": {"source file: ": "timedeltas1.py","line number: ": "16","func name: ": "to_timedelta","func arg: ": "(arg, unit, errors)","comments: ": "Convert argument to timedelta.\n\nTimedeltas are absolute differences in times, expressed in difference units (e.g. days, hours, minutes, seconds). This method converts an argument from a recognized timedelta format / value into a Timedelta type.\n\nParameters ---------- arg : str, timedelta, list-like or Series The data to be converted to timedelta. unit : str, default 'ns' Denotes the unit of the arg. Possible values: ('Y', 'M', 'W', 'D', 'days', 'day', 'hours', hour', 'hr', 'h', 'm', 'minute', 'min', 'minutes', 'T', 'S', 'seconds', 'sec', 'second', 'ms', 'milliseconds', 'millisecond', 'milli', 'millis', 'L', 'us', 'microseconds', 'microsecond', 'micro', 'micros', 'U', 'ns', 'nanoseconds', 'nano', 'nanos', 'nanosecond', 'N').\n\nerrors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n- If 'raise', then invalid parsing will raise an exception.\n\n- If 'coerce', then invalid parsing will be set as NaT.\n\n- If 'ignore', then invalid parsing will return the input.\n##### Returns\n* **DataFrame.astype **: Cast argument to a specified dtype.\n\n* **to_datetime **: Convert argument to datetime.\n\n* **convert_dtypes **: Convert dtypes.\n\n* **Parsing a single string to a Timedelta**: \n\n* **>>> pd.to_timedelta('1 days 06**: 05\n\n* **Timedelta('1 days 06**: 05\n\n* **Timedelta('0 days 00**: 00\n\n* **Parsing a list or array of strings**: \n\n* **>>> pd.to_timedelta(['1 days 06**: 05\n\n* **TimedeltaIndex(['1 days 06**: 05\n\n* **Converting numbers by specifying the `unit` keyword argument**: \n\n* **TimedeltaIndex(['00**: 00\n\n"},"func2": {"source file: ": "timedeltas1.py","line number: ": "112","func name: ": "_coerce_scalar_to_timedelta_type","func arg: ": "(r, unit, errors)","comments: ": "Convert string 'r' to a timedelta object.\n\n\n"},"func3": {"source file: ": "timedeltas1.py","line number: ": "129","func name: ": "_convert_listlike","func arg: ": "(arg, unit, errors, name)","comments: ": "Convert a list of objects to a timedelta index object.\n\n\n"}}{"func1": {"source file: ": "timedeltas2.py","line number: ": "49","func name: ": "_is_convertible_to_td","func arg: ": "(key)","comments: ": ""},"func2": {"source file: ": "timedeltas2.py","line number: ": "53","func name: ": "_field_accessor","func arg: ": "(name, alias, docstring)","comments: ": ""},"func3": {"source file: ": "timedeltas2.py","line number: ": "895","func name: ": "sequence_to_td64ns","func arg: ": "(data, copy, unit, errors)","comments: ": "Parameters ---------- array : list-like copy : bool, default False unit : str, default \"ns\" The timedelta unit to treat integers as multiples of. errors : {\"raise\", \"coerce\", \"ignore\"}, default \"raise\" How to handle elements that cannot be converted to timedelta64[ns]. See ``pandas.to_timedelta`` for details.\n\n\n##### Returns\n* **converted **: numpy.ndarray\nThe sequence converted to a numpy array with dtype ``timedelta64[ns]``.\n\n* **inferred_freq **: Tick or None\nThe inferred frequency of the sequence.\n\n"},"func4": {"source file: ": "timedeltas2.py","line number: ": "981","func name: ": "ints_to_td64ns","func arg: ": "(data, unit)","comments: ": "Convert an ndarray with integer-dtype to timedelta64[ns] dtype, treating the integers as multiples of the given timedelta unit.\n\nParameters ---------- data : numpy.ndarray with integer-dtype unit : str, default \"ns\" The timedelta unit to treat integers as multiples of.\n##### Returns\n* **numpy.ndarray **: timedelta64[ns] array converted from data\n\n* **bool **: whether a copy was made\n\n"},"func5": {"source file: ": "timedeltas2.py","line number: ": "1021","func name: ": "objects_to_td64ns","func arg: ": "(data, unit, errors)","comments: ": "Convert a object-dtyped or string-dtyped array into an timedelta64[ns]-dtyped array.\n\nParameters ---------- data : ndarray or Index unit : str, default \"ns\" The timedelta unit to treat integers as multiples of. errors : {\"raise\", \"coerce\", \"ignore\"}, default \"raise\" How to handle elements that cannot be converted to timedelta64[ns]. See ``pandas.to_timedelta`` for details.\n##### Returns\n* **numpy.ndarray **: timedelta64[ns] array converted from data\n\n"},"func6": {"source file: ": "timedeltas2.py","line number: ": "1056","func name: ": "_validate_td64_dtype","func arg: ": "(dtype)","comments: ": ""},"func7": {"source file: ": "timedeltas2.py","line number: ": "1072","func name: ": "_generate_regular_range","func arg: ": "(start, end, periods, offset)","comments: ": ""}}{"func1": {"source file: ": "timedeltas3.py","line number: ": "436","func name: ": "timedelta_range","func arg: ": "(start, end, periods, freq, name, closed)","comments: ": "Return a fixed frequency TimedeltaIndex, with day as the default frequency.\n\nParameters ---------- start : str or timedelta-like, default None Left bound for generating timedeltas. end : str or timedelta-like, default None Right bound for generating timedeltas. periods : int, default None Number of periods to generate. freq : str or DateOffset, default 'D' Frequency strings can have multiples, e.g. '5H'. name : str, default None Name of the resulting TimedeltaIndex. closed : str, default None Make the interval closed with respect to the given frequency to the 'left', 'right', or both sides (None).\n##### Returns\n* **rng **: TimedeltaIndex\n\n* **<https**: //pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n* **TimedeltaIndex(['1 days 00**: 00\n\n"}}{"func1": {"source file: ": "timeseries1.py","line number: ": "35","func name: ": "_maybe_resample","func arg: ": "(series, ax, kwargs)","comments: ": ""},"func2": {"source file: ": "timeseries1.py","line number: ": "63","func name: ": "_is_sub","func arg: ": "(f1, f2)","comments: ": ""},"func3": {"source file: ": "timeseries1.py","line number: ": "69","func name: ": "_is_sup","func arg: ": "(f1, f2)","comments: ": ""},"func4": {"source file: ": "timeseries1.py","line number: ": "75","func name: ": "_upsample_others","func arg: ": "(ax, freq, kwargs)","comments: ": ""},"func5": {"source file: ": "timeseries1.py","line number: ": "98","func name: ": "_replot_ax","func arg: ": "(ax, freq, kwargs)","comments: ": ""},"func6": {"source file: ": "timeseries1.py","line number: ": "128","func name: ": "_decorate_axes","func arg: ": "(ax, freq, kwargs)","comments: ": "Initialize axes for time-series plotting\n\n\n"},"func7": {"source file: ": "timeseries1.py","line number: ": "144","func name: ": "_get_ax_freq","func arg: ": "(ax)","comments: ": "Get the freq attribute of the ax object if set. Also checks shared axes (eg when using secondary yaxis, sharex=True or twinx)\n\n\n"},"func8": {"source file: ": "timeseries1.py","line number: ": "168","func name: ": "_get_freq","func arg: ": "(ax, series)","comments: ": ""},"func9": {"source file: ": "timeseries1.py","line number: ": "190","func name: ": "_use_dynamic_x","func arg: ": "(ax, data)","comments: ": ""},"func10": {"source file: ": "timeseries1.py","line number: ": "222","func name: ": "_get_index_freq","func arg: ": "(data)","comments: ": ""},"func11": {"source file: ": "timeseries1.py","line number: ": "233","func name: ": "_maybe_convert_index","func arg: ": "(ax, data)","comments: ": ""},"func12": {"source file: ": "timeseries1.py","line number: ": "264","func name: ": "_format_coord","func arg: ": "(freq, t, y)","comments: ": ""},"func13": {"source file: ": "timeseries1.py","line number: ": "269","func name: ": "format_dateaxis","func arg: ": "(subplot, freq, index)","comments: ": "Pretty-formats the date axis (x-axis).\n\nMajor and minor ticks are automatically set for the frequency of the current underlying series.\n\nAs the dynamic mode is activated by default, changing the limits of the x axis will intelligently change the positions of the ticks.\n"}}{"func1": {"source file: ": "tools1.py","line number: ": "15","func name: ": "format_date_labels","func arg: ": "(ax, rot)","comments: ": ""},"func2": {"source file: ": "tools1.py","line number: ": "24","func name: ": "table","func arg: ": "(ax, data, rowLabels, colLabels, **kwargs)","comments: ": ""},"func3": {"source file: ": "tools1.py","line number: ": "46","func name: ": "_get_layout","func arg: ": "(nplots, layout, layout_type)","comments: ": ""},"func4": {"source file: ": "tools1.py","line number: ": "94","func name: ": "_subplots","func arg: ": "(naxes, sharex, sharey, squeeze, subplot_kw, ax, layout, layout_type, **fig_kw)","comments: ": "Create a figure with a set of subplots already made.\n\nThis utility wrapper makes it convenient to create common layouts of subplots, including the enclosing figure object, in a single call.\n\nKeyword arguments:\n\nnaxes : int Number of required axes. Exceeded axes are set invisible. Default is nrows * ncols.\n\nsharex : bool If True, the X axis will be shared amongst all subplots.\n\nsharey : bool If True, the Y axis will be shared amongst all subplots.\n\nsqueeze : bool\n\nIf True, extra dimensions are squeezed out from the returned axis object:\n\n- if only one subplot is constructed (nrows=ncols=1), the resulting single Axis object is returned as a scalar.\n\n- for Nx1 or 1xN subplots, the returned object is a 1-d numpy object array of Axis objects are returned as numpy 1-d arrays.\n\n- for NxM subplots with N>1 and M>1 are returned as a 2d array.\n\nIf False, no squeezing is done: the returned axis object is always a 2-d array containing Axis instances, even if it ends up being 1x1.\n\nsubplot_kw : dict Dict with keywords passed to the add_subplot() call used to create each subplots.\n\nax : Matplotlib axis object, optional\n\nlayout : tuple Number of rows and columns of the subplot grid. If not specified, calculated from naxes and layout_type\n\nlayout_type : {'box', 'horizontal', 'vertical'}, default 'box' Specify how to layout the subplot grid.\n\nfig_kw : Other keyword arguments to be passed to the figure() call. Note that all keywords not recognized above will be automatically included here.\n##### Returns\n* **fig, ax **: tuple\n  - fig is the Matplotlib Figure object\n  - ax can be either a single axis object or an array of axis objects if\n  more than one subplot was created.  The dimensions of the resulting array\n  can be controlled with the squeeze keyword, see above.\n\n* ****Examples**: **\n\n"},"func5": {"source file: ": "tools1.py","line number: ": "275","func name: ": "_remove_labels_from_axis","func arg: ": "(axis)","comments: ": ""},"func6": {"source file: ": "tools1.py","line number: ": "291","func name: ": "_handle_shared_axes","func arg: ": "(axarr, nplots, naxes, nrows, ncols, sharex, sharey)","comments: ": ""},"func7": {"source file: ": "tools1.py","line number: ": "337","func name: ": "_flatten","func arg: ": "(axes)","comments: ": ""},"func8": {"source file: ": "tools1.py","line number: ": "345","func name: ": "_set_ticks_props","func arg: ": "(axes, xlabelsize, xrot, ylabelsize, yrot)","comments: ": ""},"func9": {"source file: ": "tools1.py","line number: ": "360","func name: ": "_get_all_lines","func arg: ": "(ax)","comments: ": ""},"func10": {"source file: ": "tools1.py","line number: ": "372","func name: ": "_get_xlim","func arg: ": "(lines)","comments: ": ""}}{"func1": {"source file: ": "util1.py","line number: ": "8","func name: ": "cartesian_product","func arg: ": "(X)","comments: ": "Numpy version of itertools.product. Sometimes faster (for large inputs)...\n\nParameters ---------- X : list-like of list-likes\n##### Returns\n* **product **: list of ndarrays\n\n* **itertools.product **: Cartesian product of input iterables.  Equivalent to\nnested for-loops.\n\n"}}