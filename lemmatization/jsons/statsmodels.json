{"function":
[{
    "source file": "_adnorm.py",
    "line number": "76",
    "func name": "normal_ad",
    "func arg": "(x, axis)",
    "comments": "Anderson-Darling test for normal distribution unknown mean and variance.\n\nParameters ---------- x : array_like The data array. axis : int The axis to perform the test along.\n##### Returns\n* **ad2 **: float\n    Anderson Darling test statistic.\n\n* **pval **: float\n    The pvalue for hypothesis that the data comes from a normal\n    distribution with unknown mean and variance.\n\n"
},{
    "source file": "_analytic_rotation.py",
    "line number": "106",
    "func name": "promax",
    "func arg": "(A, k)",
    "comments": "Performs promax rotation of the matrix :math:`A`.\n\nThis method was not very clear to me from the literature, this implementation is as I understand it should work.\n\nPromax rotation is performed in the following steps:\n\n* Determine varimax rotated patterns :math:`V`.\n\n* Construct a rotation target matrix :math:`|V_{ij}|^k/V_{ij}`\n\n* Perform procrustes rotation towards the target to obtain T\n\n* Determine the patterns\n\nFirst, varimax rotation a target matrix :math:`H` is determined with orthogonal varimax rotation. Then, oblique target rotation is performed towards the target.\n\nParameters ---------- A : numpy matrix non rotated factors k : float parameter, should be positive\n\nReferences ---------- [1] Browne (2001)\n\n- An overview of analytic rotation in exploratory factor analysis\n\n[2] Navarra, Simoncini (2010)\n\n- A guide to empirical orthogonal functions for climate data analysis\n"
},{
    "source file": "_bds.py",
    "line number": "166",
    "func name": "bds",
    "func arg": "(x, max_dim, epsilon, distance)",
    "comments": "BDS Test Statistic for Independence of a Time Series\n\nParameters ---------- x : ndarray Observations of time series for which bds statistics is calculated. max_dim : int The maximum embedding dimension. epsilon : {float, None}, optional The threshold distance to use in calculating the correlation sum. distance : float, optional Specifies the distance multiplier to use when computing the test statistic if epsilon is omitted.\n##### Returns\n* **bds_stat **: float\n    The BDS statistic.\n\n* **pvalue **: float\n    The p-values associated with the BDS statistic.\n\n* **required to calculate the m-histories**: \n\n"
},{
    "source file": "_constraints.py",
    "line number": "344",
    "func name": "fit_constrained_wrap",
    "func arg": "(model, constraints, start_params, **fit_kwds)",
    "comments": "fit_constraint that returns a results instance\n\nThis is a development version for fit_constrained methods or fit_constrained as standalone function.\n\nIt will not work correctly for all models because creating a new results instance is not standardized for use outside the `fit` methods, and might need adjustements for this.\n\nThis is the prototype for the fit_constrained method that has been added to Poisson and GLM.\n"
},{
    "source file": "_diagnostic_other.py",
    "line number": "904",
    "func name": "conditional_moment_test_regression",
    "func arg": "(mom_test, mom_test_deriv, mom_incl, mom_incl_deriv, var_mom_all, demean, cov_type, cov_kwds)",
    "comments": "generic conditional moment test based artificial regression\n\nthis is very experimental, no options implemented yet\n\nso far OPG regression, or artificial regression with Robust Wald test\n\nThe latter is (as far as I can see) the same as an overidentifying test in GMM where the test statistic is the value of the GMM objective function and it is assumed that parameters were estimated with optimial GMM, i.e. the weight matrix equal to the expectation of the score variance.\n"
},{
    "source file": "_diagnostics_count.py",
    "line number": "280",
    "func name": "test_poisson_zeroinflation_brock",
    "func arg": "(results_poisson)",
    "comments": "score test for zero modification in Poisson, special case\n\nThis assumes that the Poisson model has a constant and that the zero modification probability is constant.\n\nThis is a special case of test_poisson_zeroinflation derived by van den Brock 1995.\n\nThe test reports two sided and one sided alternatives based on the normal distribution of the test statistic.\n"
},{
    "source file": "_est_fit.py",
    "line number": "34",
    "func name": "check_cont_fit",
    "func arg": "(distname, arg)",
    "comments": ""
},{
    "source file": "_gpa_rotation.py",
    "line number": "555",
    "func name": "ff_partial_target",
    "func arg": "(H, W, L, A, T)",
    "comments": "Subroutine for the value of vgQ using orthogonal rotation towards a partial target matrix, i.e., we minimize\n\n.. math:: \\phi(L) =\\frac{1},{2}\\|W\\circ(L-H)\\|^2,\n\nwhere :math:`\\circ` is the element-wise product or Hadamard product and :math:`W` is a matrix whose entries can only be one or zero. Either :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\n\nFor orthogonal rotations :math:`L` satisfies\n\n.. math:: L =\n\nAT,\n\nwhere :math:`T` is an orthogonal matrix.\n\nParameters ---------- H : numpy matrix target matrix W : numpy matrix (default matrix with equal weight one for all entries) matrix with weights, entries can either be one or zero L : numpy matrix (default None) rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT` A : numpy matrix (default None) non rotated factors T : numpy matrix (default None) rotation matrix\n"
},{
    "source file": "_kernel_base.py",
    "line number": "456",
    "func name": "gpke",
    "func arg": "(bw, data, data_predict, var_type, ckertype, okertype, ukertype, tosum)",
    "comments": "Returns the non-normalized Generalized Product Kernel Estimator\n\nParameters ---------- bw : 1-D ndarray The user-specified bandwidth parameters. data : 1D or 2-D ndarray The training data. data_predict : 1-D ndarray The evaluation points at which the kernel estimation is performed. var_type : str, optional The variable type (continuous, ordered, unordered). ckertype : str, optional The kernel used for the continuous variables. okertype : str, optional The kernel used for the ordered discrete variables. ukertype : str, optional The kernel used for the unordered discrete variables. tosum : bool, optional Whether or not to sum the calculated array of densities.\n\nDefault is True.\n##### Returns\n* **dens **: array_like\n    The generalized product kernel density estimator.\n\n* **The formula for the multivariate kernel estimator for the pdf is**: \n\n* **.. math**: \n\n"
},{
    "source file": "_kernel_estimates.py",
    "line number": "119",
    "func name": "_kernel_survfunc",
    "func arg": "(time, status, exog, kfunc, freq_weights)",
    "comments": "Estimate the marginal survival function under dependent censoring.\n\nParameters ---------- time : array_like The observed times for each subject status : array_like The status for each subject (1 indicates event, 0 indicates censoring) exog : array_like Covariates such that censoring is independent conditional on exog kfunc : function Kernel function freq_weights : array_like Optional frequency weights\n##### Returns\n* **probs **: array_like\n    The estimated survival probabilities\n\n* **times **: array_like\n    The times at which the survival probabilities are estimated\n\n* **Annals of Statistics 32 (4)**: 1533 55.\n\n* **doi**: 10.1214/009053604000000508.\n\n* **https**: //arxiv.org/pdf/math/0409180.pdf\n\n"
},{
    "source file": "_knockoff.py",
    "line number": "234",
    "func name": "_get_knmat",
    "func arg": "(exog, xcov, sl)",
    "comments": ""
},{
    "source file": "_lilliefors.py",
    "line number": "222",
    "func name": "kstest_fit",
    "func arg": "(x, dist, pvalmethod)",
    "comments": "Test assumed normal or exponential distribution using Lilliefors' test.\n\nLilliefors' test is a Kolmogorov-Smirnov test with estimated parameters.\n\nParameters ---------- x : array_like, 1d Data to test. dist : {'norm', 'exp'}, optional The assumed distribution. pvalmethod : {'approx', 'table'}, optional The method used to compute the p-value of the test statistic. In general, 'table' is preferred and makes use of a very large simulation. 'approx' is only valid for normality. if `dist = 'exp'` `table` is always used. 'approx' uses the approximation formula of Dalal and Wilkinson, valid for pvalues < 0.1. If the pvalue is larger than 0.1, then the result of `table` is returned.\n##### Returns\n* **ksstat **: float\n    Kolmogorov-Smirnov test statistic with estimated mean and variance.\n\n* **pvalue **: float\n    If the pvalue is lower than some threshold, e.g. 0.05, then we can\n    reject the Null hypothesis that the sample comes from a normal\n    distribution.\n\n"
},{
    "source file": "_parameter_inference.py",
    "line number": "80",
    "func name": "score_test",
    "func arg": "(exog_extra, params_constrained, hypothesis, cov_type, cov_kwds, k_constraints, observed)",
    "comments": "score test for restrictions or for omitted variables\n\nNull Hypothesis : constraints are satisfied\n\nAlternative Hypothesis : at least one of the constraints does not hold\n\nThis allows to specify restricted and unrestricted model properties in three different ways\n\n- fit_constrained result: model contains score and hessian function for the full, unrestricted model, but the parameter estimate in the results instance is for the restricted model. This is the case if the model was estimated with fit_constrained.\n\n- restricted model with variable addition: If exog_extra is not None, then it is assumed that the current model is a model with zero restrictions and the unrestricted model is given by adding exog_extra as additional explanatory variables.\n\n- unrestricted model with restricted parameters explicitly provided. If params_constrained is not None, then the model is assumed to be for the unrestricted model, but the provided parameters are for the restricted model. TODO: This case will currently only work for `nonrobust` cov_type, otherwise we will also need the restriction matrix provided by the user.\n\n Parameters ---------- exog_extra : None or array_like Explanatory variables that are jointly tested for inclusion in the model, i.e. omitted variables. params_constrained : array_like estimated parameter of the restricted model. This can be the parameter estimate for the current when testing for omitted variables. hypothesis : str, 'joint' (default) or 'separate' If hypothesis is 'joint', then the chisquare test results for the joint hypothesis that all constraints hold is returned. If hypothesis is 'joint', then z-test results for each constraint is returned. This is currently only implemented for cov_type=\"nonrobust\". cov_type : str Warning: only partially implemented so far, currently only \"nonrobust\" and \"HC0\" are supported. If cov_type is None, then the cov_type specified in fit for the Wald tests is used. If the cov_type argument is not None, then it will be used instead of the Wald cov_type given in fit. k_constraints : int or None Number of constraints that were used in the estimation of params restricted relative to the number of exog in the model. This must be provided if no exog_extra are given. If exog_extra is not None, then k_constraints is assumed to be zero if it is None. observed : bool If True, then the observed Hessian is used in calculating the covariance matrix of the score. If false then the expected information matrix is used. This currently only applies to GLM where EIM is available. Warning: This option might still change.\n##### Returns\n* **chi2_stat **: float\n    chisquare statistic for the score test\n\n* **p-value **: float\n    P-value of the score test based on the chisquare distribution.\n\n* **df **: int\n    Degrees of freedom used in the p-value calculation. This is equal\n    to the number of constraints.\n\n* **Status**: experimental, several options are not implemented yet or are not\n\n* **cov_type is 'nonrobust'**: \n\n"
},{
    "source file": "_prediction.py",
    "line number": "235",
    "func name": "params_transform_univariate",
    "func arg": "(params, cov_params, link, transform, row_labels)",
    "comments": "results for univariate, nonlinear, monotonicaly transformed parameters\n\nThis provides transformed values, standard errors and confidence interval for transformations of parameters, for example in calculating rates with `exp(params)` in the case of Poisson or other models with exponential mean function.\n"
},{
    "source file": "_prediction1.py",
    "line number": "111",
    "func name": "get_prediction",
    "func arg": "(exog, transform, weights, row_labels, pred_kwds)",
    "comments": "Compute prediction results.\n\nParameters ---------- exog : array_like, optional The values for which you want to predict. transform : bool, optional If the model was fit via a formula, do you want to pass exog through the formula. Default is True. E.g., if you fit a model y ~ log(x1) + log(x2), and transform is True, then you can pass a data structure that contains x1 and x2 in their original form. Otherwise, you'd need to log the data first. weights : array_like, optional Weights interpreted as in WLS, used for the variance of the predicted residual. row_labels : list A list of row labels to use.\n\nIf not provided, read `exog` is available. **kwargs Some models can take additional keyword arguments, see the predict method of the model for the details.\n##### Returns\n"
},{
    "source file": "_testing.py",
    "line number": "140",
    "func name": "check_predict_types",
    "func arg": "(results)",
    "comments": "Check that the `predict` method of the given results object produces the correct output type.\n\nParameters ---------- results : Results\n"
},{
    "source file": "_tweedie_compound_poisson.py",
    "line number": "78",
    "func name": "series_density",
    "func arg": "(y, mu, p, phi)",
    "comments": ""
},{
    "source file": "_utils.py",
    "line number": "67",
    "func name": "pandas_wrapper_freq",
    "func arg": "(func, trim_head, trim_tail, freq_kw, columns, **kwargs)",
    "comments": "Return a new function that catches the incoming X, checks if it's pandas, calls the functions as is. Then wraps the results in the incoming index.\n\nDeals with frequencies. Expects that the function returns a tuple, a Bunch object, or a pandas-object.\n"
},{
    "source file": "_version.py",
    "line number": "477",
    "func name": "get_versions",
    "func arg": "()",
    "comments": "Get version information or return default if unable to do so.\n\n\n"
},{
    "source file": "_wrappers.py",
    "line number": "13",
    "func name": "rotate_factors",
    "func arg": "(A, method, **algorithm_kwargs)",
    "comments": "Subroutine for orthogonal and oblique rotation of the matrix :math:`A`. For orthogonal rotations :math:`A` is rotated to :math:`L` according to\n\n.. math::\n\nL =\n\nAT,\n\nwhere :math:`T` is an orthogonal matrix. And, for oblique rotations :math:`A` is rotated to :math:`L` according to\n\n.. math::\n\nL =\n\nA(T^*)^{-1},\n\nwhere :math:`T` is a normal matrix.\n\nParameters ---------- A : numpy matrix (default None) non rotated factors method : str should be one of the methods listed below method_args : list additional arguments that should be provided with each method algorithm_kwargs : dictionary algorithm : str (default gpa) should be one of:\n\n* 'gpa': a numerical method * 'gpa_der_free': a derivative free numerical method * 'analytic' : an analytic method\n\nDepending on the algorithm, there are algorithm specific keyword arguments. For the gpa and gpa_der_free, the following keyword arguments are available:\n\nmax_tries : int (default 501) maximum number of iterations\n\ntol : float stop criterion, algorithm stops if Frobenius norm of gradient is smaller then tol\n\nFor analytic, the supported arguments depend on the method, see above.\n\nSee the lower level functions for more details.\n##### Returns\n* **The tuple **: math\n\n* **Below,\n    * **: math\n\n* **oblimin **: orthogonal or oblique rotation that minimizes\n    .. math\n\n* **orthomax **: orthogonal rotation that minimizes\n    .. math\n\n* **CF **: Crawford-Ferguson family for orthogonal and oblique rotation which\n\n* **minimizes**: .. math\n\n* **quartimax **: orthogonal rotation method\n    minimizes the orthomax objective with\n\n* **biquartimax **: orthogonal rotation method\n    minimizes the orthomax objective with\n\n* **varimax **: orthogonal rotation method\n    minimizes the orthomax objective with\n\n* **equamax **: orthogonal rotation method\n    minimizes the orthomax objective with\n\n* **parsimax **: orthogonal rotation method\n    minimizes the Crawford-Ferguson family objective with\n\n* **parsimony **: orthogonal rotation method\n    minimizes the Crawford-Ferguson family objective with\n\n* **quartimin **: oblique rotation method that minimizes\n    minimizes the oblimin objective with\n\n* **target **: orthogonal or oblique rotation that rotates towards a target\n\n* **matrix **: math\n\n* **partial_target **: orthogonal (default) or oblique rotation that partially\n\n* **rotates towards a target matrix **: math\n\n"
},{
    "source file": "adfvalues.py",
    "line number": "407",
    "func name": "mackinnoncrit",
    "func arg": "(N, regression, nobs)",
    "comments": "Returns the critical values for cointegrating and the ADF test.\n\nIn 2010 MacKinnon updated the values of his 1994 paper with critical values for the augmented Dickey-Fuller tests.\n\nThese new values are to be preferred and are used here.\n\nParameters ---------- N : int The number of series of I(1) series for which the null of non-cointegration is being tested.\n\nFor N > 12, the critical values are linearly interpolated (not yet implemented).\n\nFor the ADF test, N = 1. reg : str {'c', 'tc', 'ctt', 'nc'} Following MacKinnon (1996), these stand for the type of regression run. 'c' for constant and no trend, 'tc' for constant with a linear trend, 'ctt' for constant with a linear and quadratic trend, and 'nc' for no constant.\n\nThe values for the no constant case are taken from the 1996 paper, as they were not updated for 2010 due to the unrealistic assumptions that would underlie such a case. nobs : int or np.inf This is the sample size.\n\nIf the sample size is numpy.inf, then the asymptotic critical values are returned.\n\nReferences ---------- .. [*] MacKinnon, J.G. 1994\n\n\"Approximate Asymptotic Distribution Functions for Unit-Root and Cointegration Tests.\" Journal of Business & Economics Statistics, 12.2, 167-76. .. [*] MacKinnon, J.G. 2010.\n\n\"Critical Values for Cointegration Tests.\" Queen's University, Dept of Economics Working Papers 1227. http://ideas.repec.org/p/qed/wpaper/1227.html\n"
},{
    "source file": "agreement.py",
    "line number": "12",
    "func name": "mean_diff_plot",
    "func arg": "(m1, m2, sd_limit, ax, scatter_kwds, mean_line_kwds, limit_lines_kwds)",
    "comments": "Construct a Tukey/Bland-Altman Mean Difference Plot.\n\nTukey's Mean Difference Plot (also known as a Bland-Altman plot) is a graphical method to analyze the differences between two methods of measurement. The mean of the measures is plotted against their difference.\n\nFor more information see https://en.wikipedia.org/wiki/Bland-Altman_plot\n\nParameters ---------- m1 : array_like A 1-d array. m2 : array_like A 1-d array. sd_limit : float The limit of agreements expressed in terms of the standard deviation of the differences. If `md` is the mean of the differences, and `sd` is the standard deviation of those differences, then the limits of agreement that will be plotted are md +/- sd_limit * sd. The default of 1.96 will produce 95% confidence intervals for the means of the differences. If sd_limit = 0, no limits will be plotted, and the ylimit of the plot defaults to 3 standard deviations on either side of the mean. ax : AxesSubplot If `ax` is None, then a figure is created. If an axis instance is given, the mean difference plot is drawn on the axis. scatter_kwds : dict Options to to style the scatter plot. Accepts any keywords for the matplotlib Axes.scatter plotting method mean_line_kwds : dict Options to to style the scatter plot. Accepts any keywords for the matplotlib Axes.axhline plotting method limit_lines_kwds : dict Options to to style the scatter plot. Accepts any keywords for the matplotlib Axes.axhline plotting method\n##### Returns\n* **.. plot**: \n\n"
},{
    "source file": "anova_nistcertified.py",
    "line number": "84",
    "func name": "anova_ols",
    "func arg": "(y, x)",
    "comments": ""
},{
    "source file": "anova.py",
    "line number": "387",
    "func name": "_ssr_reduced_model",
    "func arg": "(y, x, term_slices, params, keys)",
    "comments": "Residual sum of squares of OLS model excluding factors in `keys` Assumes x matrix is orthogonal\n\nParameters ---------- y : array_like dependent variable x : array_like independent variables term_slices : a dict of slices term_slices[key] is a boolean array specifies the parameters associated with the factor `key` params : ndarray OLS solution of y = x * params keys : keys for term_slices factors to be excluded\n##### Returns\n* **rss **: float\n    residual sum of squares\n\n* **df **: int\n    degrees of freedom\n\n"
},{
    "source file": "ar_model.py",
    "line number": "2342",
    "func name": "ar_select_order",
    "func arg": "(endog, maxlag, ic, glob, trend, seasonal, exog, hold_back, period, missing, old_names)",
    "comments": "Autoregressive AR-X(p) model order selection.\n\nParameters ---------- endog : array_like A 1-d endogenous response variable. The independent variable. maxlag : int The maximum lag to consider. ic : {'aic', 'hqic', 'bic'} The information criterion to use in the selection. glob : bool Flag indicating where to use a global search\n\nacross all combinations of lags.\n\nIn practice, this option is not computational feasible when maxlag is larger than 15 (or perhaps 20) since the global search requires fitting 2**maxlag models. %(auto_reg_params)s\n##### Returns\n"
},{
    "source file": "ar1cholesky.py",
    "line number": "11",
    "func name": "tiny2zero",
    "func arg": "(x, eps)",
    "comments": "replace abs values smaller than eps by zero, makes copy\n\n\n"
},{
    "source file": "arima_model.py",
    "line number": "457",
    "func name": "_check_estimable",
    "func arg": "(nobs, n_params)",
    "comments": ""
},{
    "source file": "arima_process.py",
    "line number": "585",
    "func name": "deconvolve",
    "func arg": "(num, den, n)",
    "comments": "Deconvolves divisor out of signal, division of polynomials for n terms\n\ncalculates den^{-1} * num\n\nParameters ---------- num : array_like signal or lag polynomial denom : array_like coefficients of lag polynomial (linear filter) n : None or int number of terms of quotient\n##### Returns\n* **quot **: ndarray\n    quotient or filtered series\n\n* **rem **: ndarray\n    remainder\n\n"
},{
    "source file": "arma_innovations.py",
    "line number": "230",
    "func name": "arma_scoreobs",
    "func arg": "(endog, ar_params, ma_params, sigma2, prefix)",
    "comments": "Compute the score (gradient) per observation.\n\nParameters ---------- endog : ndarray The observed time-series process. ar_params : ndarray, optional Autoregressive coefficients, not including the zero lag. ma_params : ndarray, optional Moving average coefficients, not including the zero lag, where the sign convention assumes the coefficients are part of the lag polynomial on the right-hand-side of the ARMA definition (i.e. they have the same sign from the usual econometrics convention in which the coefficients are on the right-hand-side of the ARMA definition). sigma2 : ndarray, optional The ARMA innovation variance. Default is 1. prefix : str, optional The BLAS prefix associated with the datatype. Default is to find the best datatype based on given input. This argument is typically only used internally.\n##### Returns\n"
},{
    "source file": "arma.py",
    "line number": "45",
    "func name": "mc_summary",
    "func arg": "(res, rt)",
    "comments": ""
},{
    "source file": "bandwidths.py",
    "line number": "153",
    "func name": "select_bandwidth",
    "func arg": "(x, bw, kernel)",
    "comments": "Selects bandwidth for a selection rule bw\n\nthis is a wrapper around existing bandwidth selection rules\n\nParameters ---------- x : array_like Array for which to get the bandwidth bw : str name of bandwidth selection rule, currently supported are: %s kernel : not used yet\n##### Returns\n* **bw **: float\n    The estimate of the bandwidth\n\n"
},{
    "source file": "bk_filter.py",
    "line number": "8",
    "func name": "bkfilter",
    "func arg": "(x, low, high, K)",
    "comments": "Filter a time series using the Baxter-King bandpass filter.\n\nParameters ---------- x : array_like A 1 or 2d ndarray. If 2d, variables are assumed to be in columns. low : float Minimum period for oscillations, ie., Baxter and King suggest that the Burns-Mitchell U.S. business cycle has 6 for quarterly data and 1.5 for annual data. high : float Maximum period for oscillations BK suggest that the U.S. business cycle has 32 for quarterly data and 8 for annual data. K : int Lead-lag length of the filter. Baxter and King propose a truncation length of 12 for quarterly data and 3 for annual data.\n##### Returns\n* **the weights a[j] are computed **: \n\n* **and theta is a normalizing constant **: \n\n* **Baxter, M. and R. G. King. \"Measuring Business Cycles**: Approximate\n    Band-Pass Filters for Economic Time Series.\" *Review of Economics and\n    Statistics*, 1999, 81(4), 575-593.\n\n* **.. plot**: \n\n"
},{
    "source file": "boxplots.py",
    "line number": "410",
    "func name": "_show_legend",
    "func arg": "(ax)",
    "comments": "Utility function to show legend.\n\n\n"
},{
    "source file": "bspline.py",
    "line number": "163",
    "func name": "_zero_triband",
    "func arg": "(a, lower)",
    "comments": "Explicitly zero out unused elements of a real symmetric banded matrix.\n\nINPUTS: a\n\n -- a real symmetric banded matrix (either upper or lower hald) lower\n\n -- if True, a is assumed to be the lower half\n"
},{
    "source file": "burg.py",
    "line number": "16",
    "func name": "burg",
    "func arg": "(endog, ar_order, demean)",
    "comments": "Estimate AR parameters using Burg technique.\n\nParameters ---------- endog : array_like or SARIMAXSpecification Input time series array, assumed to be stationary. ar_order : int, optional Autoregressive order. Default is 0. demean : bool, optional Whether to estimate and remove the mean from the process prior to fitting the autoregressive coefficients.\n##### Returns\n* **parameters **: SARIMAXParams object\n    Contains the parameter estimates from the final iteration.\n\n* **other_results **: Bunch\n    Includes one component, `spec`, which is the `SARIMAXSpecification`\n    instance corresponding to the input arguments.\n\n"
},{
    "source file": "catadd.py",
    "line number": "4",
    "func name": "add_indep",
    "func arg": "(x, varnames, dtype)",
    "comments": "construct array with independent columns\n\nx is either iterable (list, tuple) or instance of ndarray or a subclass of it.\n\nIf x is an ndarray, then each column is assumed to represent a variable with observations in rows.\n"
},{
    "source file": "cf_filter.py",
    "line number": "16",
    "func name": "cffilter",
    "func arg": "(x, low, high, drift)",
    "comments": "Christiano Fitzgerald asymmetric, random walk filter.\n\nParameters ---------- x : array_like The 1 or 2d array to filter. If 2d, variables are assumed to be in columns. low : float Minimum period of oscillations. Features below low periodicity are filtered out. Default is 6 for quarterly data, giving a 1.5 year periodicity. high : float Maximum period of oscillations. Features above high periodicity are filtered out. Default is 32 for quarterly data, giving an 8 year periodicity. drift : bool Whether or not to remove a trend from the data. The trend is estimated as np.arange(nobs)*(x[-1]\n\n- x[0])/(len(x)-1).\n##### Returns\n* **cycle **: array_like\n    The features of x between the periodicities low and high.\n\n* **trend **: array_like\n    The trend in the data with the cycles removed.\n\n* **.. plot**: \n\n"
},{
    "source file": "check_moments.py",
    "line number": "113",
    "func name": "nct_kurt_bug",
    "func arg": "()",
    "comments": "test for incorrect kurtosis of nct\n\nD. Hogben, R. S. Pinkham, M. B. Wilk: The Moments of the Non-Central t-DistributionAuthor(s): Biometrika, Vol. 48, No. 3/4 (Dec., 1961), pp. 465-468\n"
},{
    "source file": "chi2_fitting.py",
    "line number": "130",
    "func name": "chi2",
    "func arg": "(pars)",
    "comments": "Cost function.\n\n\n"
},{
    "source file": "coint_tables.py",
    "line number": "204",
    "func name": "c_sjt",
    "func arg": "(n, p)",
    "comments": ""
},{
    "source file": "conf.py",
    "line number": "447",
    "func name": "setup",
    "func arg": "(app)",
    "comments": ""
},{
    "source file": "conftest.py",
    "line number": "107",
    "func name": "reset_randomstate",
    "func arg": "()",
    "comments": "Fixture that set the global RandomState to the fixed seed 1\n\nNotes ----- Used by passing as an argument to the function that uses the global RandomState\n\ndef test_some_plot(reset_randomstate): <test code>\n"
},{
    "source file": "contingency_tables.py",
    "line number": "1356",
    "func name": "cochrans_q",
    "func arg": "(x, return_object)",
    "comments": "Cochran's Q test for identical binomial proportions.\n\nParameters ---------- x : array_like, 2d (N, k) data with N cases and k variables return_object : bool Return values as bunch instead of as individual values.\n##### Returns\n* **statistic **: float\n   test statistic\n\n* **pvalue **: float\n   pvalue from the chisquare distribution\n\n* **https**: //en.wikipedia.org/wiki/Cochran_test\n\n"
},{
    "source file": "contrast_tools.py",
    "line number": "418",
    "func name": "groupmean_d",
    "func arg": "(x, d)",
    "comments": "groupmeans using dummy variables\n\nParameters ---------- x : array_like, ndim data array, tested for 1,2 and 3 dimensions d : ndarray, 1d dummy variable, needs to have the same length as x in axis 0.\n##### Returns\n* **groupmeans **: ndarray, ndim-1\n    means for each group along axis 0, the levels\n    of the groups are the last axis\n\n"
},{
    "source file": "contrast.py",
    "line number": "743",
    "func name": "wald_test_noncent_generic",
    "func arg": "(params, r_matrix, value, cov_params, diff, joint)",
    "comments": "noncentrality parameter for a wald test\n\nThe null hypothesis is ``diff = r_matrix @ params\n\n- value = 0``\n\nParameters ---------- params : ndarray parameters of the model at which to evaluate noncentrality. This can be estimated parameters or parameters under an alternative. r_matrix : ndarray Restriction matrix or contrasts for the Null hypothesis\n\nvalue : None or ndarray Value of the linear combination of parameters under the null hypothesis. If value is None, then it will be replace by zero. cov_params : ndarray covariance matrix of the parameter estimates diff : None or ndarray If diff is not None, then it will be used instead of ``diff = r_matrix @ params\n\n- value`` joint : bool If joint is True, then the noncentrality parameter for the joint hypothesis will be returned. If joint is True, then an array of noncentrality parameters will be returned, where elements correspond to rows of the restriction matrix. This correspond to the `t_test` in models and is not a quadratic form.\n##### Returns\n* **nc **: float or ndarray\n    Noncentrality parameter for Wald tests, correspondig to `wald_test`\n    or `t_test` depending on whether `joint` is true or not.\n    It needs to be divided by nobs to obtain effect size.\n\n* **Status **: experimental, API will likely change\n\n"
},{
    "source file": "contrasts.py",
    "line number": "108",
    "func name": "_name_levels",
    "func arg": "(prefix, levels)",
    "comments": ""
},{
    "source file": "copula.py",
    "line number": "363",
    "func name": "transform_tev",
    "func arg": "(t, rho, x)",
    "comments": "t-EV model of Demarta and McNeil 2005\n\nrestrictions:\n\n- rho in (-1,1)\n\n- x > 0\n"
},{
    "source file": "correlation_structures.py",
    "line number": "145",
    "func name": "yule_walker_acov",
    "func arg": "(acov, order, method, df, inv)",
    "comments": "Estimate AR(p) parameters from acovf using Yule-Walker equation.\n\nParameters ---------- acov : array_like, 1d auto-covariance order : int, optional The order of the autoregressive process.\n\nDefault is 1. inv : bool If inv is True the inverse of R is also returned.\n\nDefault is False.\n##### Returns\n* **rho **: ndarray\n    The estimated autoregressive coefficients\n\n* **Rinv **: ndarray\n    inverse of the Toepliz matrix\n\n"
},{
    "source file": "correlation_tools.py",
    "line number": "934",
    "func name": "kernel_covariance",
    "func arg": "(exog, loc, groups, kernel, bw)",
    "comments": "Use kernel averaging to estimate a multivariate covariance function.\n\nThe goal is to estimate a covariance function C(x, y) = cov(Z(x), Z(y)) where x, y are vectors in R^p (e.g. representing locations in time or space), and Z(.) represents a multivariate process on R^p.\n\nThe data used for estimation can be observed at arbitrary values of the position vector, and there can be multiple independent observations from the process.\n\nParameters ---------- exog : array_like The rows of exog are realizations of the process obtained at specified points. loc : array_like The rows of loc are the locations (e.g. in space or time) at which the rows of exog are observed. groups : array_like The values of groups are labels for distinct independent copies of the process. kernel : MultivariateKernel instance, optional An instance of MultivariateKernel, defaults to GaussianMultivariateKernel. bw : array_like or scalar A bandwidth vector, or bandwidth multiplier.\n\nIf a 1d array, it contains kernel bandwidths for each component of the process, and must have length equal to the number of columns of exog.\n\nIf a scalar, bw is a bandwidth multiplier used to adjust the default bandwidth; if None, a default bandwidth is used.\n##### Returns\n* **.. [1] Genton M, W Kleiber (2015).  Cross covariance functions for\n    multivariate geostatics.  Statistical Science 30(2).\n    https**: //arxiv.org/pdf/1507.08017.pdf\n\n"
},{
    "source file": "correlation.py",
    "line number": "125",
    "func name": "plot_corr_grid",
    "func arg": "(dcorrs, titles, ncols, normcolor, xnames, ynames, fig, cmap)",
    "comments": "Create a grid of correlation plots.\n\nThe individual correlation plots are assumed to all have the same variables, axis labels can be specified only once.\n\nParameters ---------- dcorrs : list or iterable of ndarrays List of correlation matrices. titles : list[str], optional List of titles for the subplots.\n\nBy default no title are shown. ncols : int, optional Number of columns in the subplot grid.\n\nIf not given, the number of columns is determined automatically. normcolor : bool or tuple, optional If False (default), then the color coding range corresponds to the range of `dcorr`.\n\nIf True, then the color range is normalized to (-1, 1).\n\nIf this is a tuple of two numbers, then they define the range for the color bar. xnames : list[str], optional Labels for the horizontal axis.\n\nIf not given (None), then the matplotlib defaults (integers) are used.\n\nIf it is an empty list, [], then no ticks and labels are added. ynames : list[str], optional Labels for the vertical axis.\n\nWorks the same way as `xnames`. If not given, the same names as for `xnames` are re-used. fig : Figure, optional If given, this figure is simply returned.\n\nOtherwise a new figure is created. cmap : str or Matplotlib Colormap instance, optional The colormap for the plot.\n\nCan be any valid Matplotlib Colormap instance or name.\n##### Returns\n* **..plot **: \n\n"
},{
    "source file": "count.py",
    "line number": "40",
    "func name": "maxabsrel",
    "func arg": "(arr1, arr2)",
    "comments": ""
},{
    "source file": "covtype.py",
    "line number": "67",
    "func name": "get_robustcov_results",
    "func arg": "(cov_type, use_t, **kwds)",
    "comments": "create new results instance with robust covariance as default\n\nParameters ---------- cov_type : str the type of robust sandwich estimator to use. see Notes below use_t : bool If true, then the t distribution is used for inference. If false, then the normal distribution is used. kwds : depends on cov_type Required or optional arguments for robust covariance calculation. see Notes below\n##### Returns\n* **results **: results instance\n    This method creates a new results instance with the requested\n    robust covariance as the default covariance of the parameters.\n    Inferential statistics like p-values and hypothesis tests will be\n    based on this covariance matrix.\n\n* **Warning**: Some of the options and defaults in cov_kwds may be changed in a\n\n* **currently available**: \n\n* **- 'HC0', 'HC1', 'HC2', 'HC3' and no keyword arguments**: heteroscedasticity robust covariance\n\n* **- 'HAC' and keywords\n    - `maxlag` integer (required) **: number of lags to use\n    - `kernel` callable or str (optional)\n\n* **- 'cluster' and required keyword `groups`, integer group indicator\n    - `groups` array_like, integer (required) **: index of clusters or groups\n    - `use_correction` bool (optional)\n\n* **- 'hac-groupsum' Driscoll and Kraay, heteroscedasticity and\n    autocorrelation robust standard errors in panel data\n    keywords\n    - `time` array_like (required) **: index of time periods\n    - `maxlag` integer (required)\n\n* **- 'hac-panel' heteroscedasticity and autocorrelation robust standard\n    errors in panel data.\n    The data needs to be sorted in this case, the time series for\n    each panel unit or cluster need to be stacked. The membership to\n    a timeseries of an individual or group can be either specified by\n    group indicators or by increasing time periods.\n    keywords\n    - either `groups` or `time` **: array_like (required)\n      `groups`\n\n* **Reminder**: \n\n* **TODO**: Currently there is no check for extra or misspelled keywords,\n\n"
},{
    "source file": "cross_val.py",
    "line number": "256",
    "func name": "split",
    "func arg": "(train_indexes, test_indexes)",
    "comments": "For each arg return a train and test subsets defined by indexes provided in train_indexes and test_indexes\n\n\n"
},{
    "source file": "data.py",
    "line number": "663",
    "func name": "handle_data",
    "func arg": "(endog, exog, missing, hasconst, **kwargs)",
    "comments": ""
},{
    "source file": "data20.py",
    "line number": "122",
    "func name": "_is_recarray",
    "func arg": "(data)",
    "comments": "Returns true if data is a recarray\n\n\n"
},{
    "source file": "data21.py",
    "line number": "65",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data22.py",
    "line number": "80",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data23.py",
    "line number": "72",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data24.py",
    "line number": "72",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data25.py",
    "line number": "69",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data26.py",
    "line number": "47",
    "func name": "load",
    "func arg": "(as_pandas)",
    "comments": "Load the China smoking/lung cancer data and return a Dataset class.\n\nParameters ---------- as_pandas : bool Flag indicating whether to return pandas DataFrames and Series or numpy recarrays and arrays.\n\nIf True, returns pandas.\n##### Returns\n* **Dataset instance**: See DATASET_PROPOSAL.txt for more information.\n\n"
},{
    "source file": "data27.py",
    "line number": "63",
    "func name": "load",
    "func arg": "(as_pandas)",
    "comments": "Load the copper data and returns a Dataset class.\n\nParameters ---------- as_pandas : bool Flag indicating whether to return pandas DataFrames and Series or numpy recarrays and arrays.\n\nIf True, returns pandas.\n##### Returns\n* **Dataset instance**: See DATASET_PROPOSAL.txt for more information.\n\n"
},{
    "source file": "data28.py",
    "line number": "60",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data29.py",
    "line number": "54",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data30.py",
    "line number": "121",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data31.py",
    "line number": "73",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data32.py",
    "line number": "78",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data33.py",
    "line number": "66",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data34.py",
    "line number": "89",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data35.py",
    "line number": "69",
    "func name": "__str__",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data36.py",
    "line number": "56",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data37.py",
    "line number": "76",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data38.py",
    "line number": "85",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data39.py",
    "line number": "58",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data40.py",
    "line number": "92",
    "func name": "__str__",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data41.py",
    "line number": "60",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data42.py",
    "line number": "76",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data43.py",
    "line number": "69",
    "func name": "__str__",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data44.py",
    "line number": "90",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data45.py",
    "line number": "65",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data46.py",
    "line number": "93",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data47.py",
    "line number": "68",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "data48.py",
    "line number": "87",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "datetools.py",
    "line number": "166",
    "func name": "dates_from_range",
    "func arg": "(start, end, length)",
    "comments": "Turns a sequence of date strings and returns a list of datetime.\n\nParameters ---------- start : str The first abbreviated date, for instance, '1965q1' or '1965m1' end : str, optional The last abbreviated date if length is None. length : int, optional The length of the returned array of end is None.\n\nExamples -------- >>> import statsmodels.api as sm >>> import pandas as pd >>> dates = pd.date_range('1960m1', length=nobs)\n##### Returns\n* **date_list **: ndarray\n    A list of datetime types.\n\n"
},{
    "source file": "decorators.py",
    "line number": "8",
    "func name": "array_like",
    "func arg": "(pos, name, dtype, ndim, maxdim, shape, order, contiguous)",
    "comments": ""
},{
    "source file": "decorators49.py",
    "line number": "153",
    "func name": "nottest",
    "func arg": "(fn)",
    "comments": ""
},{
    "source file": "demo.py",
    "line number": "324",
    "func name": "get_exog",
    "func arg": "(N, num_nonconst_covariates, cor_length)",
    "comments": "Returns an exog array with correlations determined by cor_length. The covariance matrix of exog will have (asymptotically, as :math:'N\\to\\inf') .. math:: Cov[i,j] = \\exp(-|i-j| / cor_length)\n\nHigher cor_length makes the problem more ill-posed, and easier to screw up with noise. BEWARE:\n\nWith very long correlation lengths, you often get a singular KKT matrix (during the l1_cvxopt_cp fit)\n"
},{
    "source file": "densityorthopoly.py",
    "line number": "395",
    "func name": "density_orthopoly",
    "func arg": "(x, polybase, order, xeval)",
    "comments": ""
},{
    "source file": "denton.py",
    "line number": "87",
    "func name": "dentonm",
    "func arg": "(indicator, benchmark, freq, **kwargs)",
    "comments": "Modified Denton's method to convert low-frequency to high-frequency data.\n\nUses proportionate first-differences as the penalty function.\n\nSee notes.\n\nParameters ---------- indicator : array_like A low-frequency indicator series.\n\nIt is assumed that there are no pre-sample indicators.\n\nIe., the first indicators line up with the first benchmark. benchmark : array_like The higher frequency benchmark.\n\nA 1d or 2d data series in columns. If 2d, then M series are assumed. freq : str {\"aq\",\"qm\", \"other\"} The frequency to use in the conversion.\n\n* \"aq\"\n\n- Benchmarking an annual series to quarterly. * \"mq\"\n\n- Benchmarking a quarterly series to monthly. * \"other\"\n\n- Custom stride.\n\nA kwarg, k, must be supplied. **kwargs Additional keyword argument. For example:\n\n* k, an int, the number of high-frequency observations that sum to make an aggregate low-frequency observation. `k` is used with `freq` == \"other\".\n##### Returns\n* **transformed **: ndarray\n    The transformed series.\n\n* **Bloem, A.M, Dippelsman, R.J. and Maehle, N.O.  2001 Quarterly National\n    Accounts Manual--Concepts, Data Sources, and Compilation. IMF.\n    http**: //www.imf.org/external/pubs/ft/qna/2000/Textbook/index.htm\n\n* **Denton, F.T. 1971. \"Adjustment of monthly or quarterly series to annual\n    totals**: an approach based on quadratic minimization.\" Journal of the\n    American Statistical Association. 99-102.\n\n"
},{
    "source file": "descriptive.py",
    "line number": "26",
    "func name": "DescStat",
    "func arg": "(endog)",
    "comments": "Returns an instance to conduct inference on descriptive statistics via empirical likelihood.  See DescStatUV and DescStatMV for more information.\n\nParameters ---------- endog : ndarray Array of data\n##### Returns\n"
},{
    "source file": "descriptivestats50.py",
    "line number": "35",
    "func name": "sign_test",
    "func arg": "(samp, mu0)",
    "comments": "Signs test.\n\nParameters ---------- samp : array_like 1d array. The sample for which you want to perform the signs test. mu0 : float See Notes for the definition of the sign test. mu0 is 0 by default, but it is common to set it to the median.\n##### Returns\n"
},{
    "source file": "descstats.py",
    "line number": "16",
    "func name": "descstats",
    "func arg": "(data, cols, axis)",
    "comments": "Prints descriptive statistics for one or multiple variables.\n\nParameters ---------- data: numpy array `x` is the data\n\nv: list, optional A list of the column number or field names (for a recarray) of variables. Default is all columns.\n\naxis: 1 or 0 axis order of data.\n\nDefault is 0 for column-ordered data.\n\nExamples -------- >>> descstats(data.exog,v=['x_1','x_2','x_3'])\n"
},{
    "source file": "dgp_examples.py",
    "line number": "31",
    "func name": "func1",
    "func arg": "(x)",
    "comments": "made up example with sin, square\n\n\n"
},{
    "source file": "diagnostic51.py",
    "line number": "1778",
    "func name": "breaks_cusumolsresid",
    "func arg": "(resid, ddof)",
    "comments": "Cusum test for parameter stability based on ols residuals.\n\nParameters ---------- resid : ndarray An array of residuals from an OLS estimation. ddof : int The number of parameters in the OLS estimation, used as degrees of freedom correction for error variance.\n##### Returns\n* **sup_b **: float\n    The test statistic, maximum of absolute value of scaled cumulative OLS\n    residuals.\n\n* **pval **: float\n    Probability of observing the data under the null hypothesis of no\n    structural change, based on asymptotic distribution which is a Brownian\n    Bridge\n\n* **crit**: list\n    The tabulated critical values, for alpha = 1%, 5% and 10%.\n\n* **Tested against R**: structchange.\n\n* **Not clear**: Assumption 2 in Ploberger, Kramer assumes that exog x have\n\n* **Econometrica 60, no. 2 (March 1992)**: 271-285.\n\n"
},{
    "source file": "diffusion2.py",
    "line number": "354",
    "func name": "schout2contank",
    "func arg": "(a, b, d)",
    "comments": ""
},{
    "source file": "dimred.py",
    "line number": "452",
    "func name": "_grass_opt",
    "func arg": "(params, fun, grad, maxiter, gtol)",
    "comments": "Minimize a function on a Grassmann manifold.\n\nParameters ---------- params : array_like Starting value for the optimization. fun : function The function to be minimized. grad : function The gradient of fun. maxiter : int The maximum number of iterations. gtol : float Convergence occurs when the gradient norm falls below this value.\n##### Returns\n* **params **: array_like\n    The minimizing value for the objective function.\n\n* **fval **: float\n    The smallest achieved value of the objective function.\n\n* **cnvrg **: bool\n    True if the algorithm converged to a limit point.\n\n* **http**: //math.mit.edu/~edelman/publications/geometry_of_algorithms.pdf\n\n"
},{
    "source file": "discrete_margins.py",
    "line number": "351",
    "func name": "_check_at_is_all",
    "func arg": "(method)",
    "comments": ""
},{
    "source file": "discrete_model.py",
    "line number": "141",
    "func name": "_validate_l1_method",
    "func arg": "(method)",
    "comments": "As of 0.10.0, the supported values for `method` in `fit_regularized` are \"l1\" and \"l1_cvxopt_cp\".  If an invalid value is passed, raise with a helpful error message\n\nParameters ---------- method : str\n"
},{
    "source file": "dist_dependence_measures.py",
    "line number": "464",
    "func name": "distance_correlation",
    "func arg": "(x, y)",
    "comments": "Distance correlation.\n\nCalculate the empirical distance correlation as described in [1]_. This statistic is analogous to product-moment correlation and describes the dependence between `x` and `y`, which are random vectors of arbitrary length. The statistics' values range between 0 (implies independence) and 1 (implies complete dependence).\n\nParameters ---------- x : array_like, 1-D or 2-D If `x` is 1-D than it is assumed to be a vector of observations of a single random variable. If `x` is 2-D than the rows should be observations and the columns are treated as the components of a random vector, i.e., each column represents a different component of the random vector `x`. y : array_like, 1-D or 2-D Same as `x`, but only the number of observation has to match that of `x`. If `y` is 2-D note that the number of columns of `y` (i.e., the number of components in the random vector) does not need to match the number of columns in `x`.\n##### Returns\n"
},{
    "source file": "distributed_estimation.py",
    "line number": "328",
    "func name": "_helper_fit_partition",
    "func arg": "(pnum, endog, exog, fit_kwds, init_kwds_e)",
    "comments": "handles the model fitting for each machine. NOTE: this is primarily handled outside of DistributedModel because joblib cannot handle class methods.\n\nParameters ---------- self : DistributedModel class instance An instance of DistributedModel. pnum : scalar index of current partition. endog : array_like endogenous data for current partition. exog : array_like exogenous data for current partition. fit_kwds : dict-like Keywords needed for the model fitting. init_kwds_e : dict-like Additional init_kwds to add for each partition.\n##### Returns\n"
},{
    "source file": "distributed_estimation52.py",
    "line number": "32",
    "func name": "_endog_gen",
    "func arg": "(endog, partitions)",
    "comments": "partitions endog data\n\n\n"
},{
    "source file": "docstring.py",
    "line number": "654",
    "func name": "remove_parameters",
    "func arg": "(docstring, parameters)",
    "comments": "Parameters ---------- docstring : str The docstring to modify. parameters : str, list[str] The names of the parameters to remove.\n\n\n##### Returns\n"
},{
    "source file": "dotplots.py",
    "line number": "5",
    "func name": "dot_plot",
    "func arg": "(points, intervals, lines, sections, styles, marker_props, line_props, split_names, section_order, line_order, stacked, styles_order, striped, horizontal, show_names, fmt_left_name, fmt_right_name, show_section_titles, ax)",
    "comments": "Dot plotting (also known as forest and blobbogram).\n\nProduce a dotplot similar in style to those in Cleveland's \"Visualizing Data\" book ([1]_).\n\nThese are also known as \"forest plots\".\n\nParameters ---------- points : array_like The quantitative values to be plotted as markers. intervals : array_like The intervals to be plotted around the points.\n\nThe elements of `intervals` are either scalars or sequences of length 2.\n\nA scalar indicates the half width of a symmetric interval.\n\nA sequence of length 2 contains the left and right half-widths (respectively) of a nonsymmetric interval.\n\nIf None, no intervals are drawn. lines : array_like A grouping variable indicating which points/intervals are drawn on a common line.\n\nIf None, each point/interval appears on its own line. sections : array_like A grouping variable indicating which lines are grouped into sections.\n\nIf None, everything is drawn in a single section. styles : array_like A grouping label defining the plotting style of the markers and intervals. marker_props : dict A dictionary mapping style codes (the values in `styles`) to dictionaries defining key/value pairs to be passed as keyword arguments to `plot` when plotting markers.\n\nUseful keyword arguments are \"color\", \"marker\", and \"ms\" (marker size). line_props : dict A dictionary mapping style codes (the values in `styles`) to dictionaries defining key/value pairs to be passed as keyword arguments to `plot` when plotting interval lines.\n\nUseful keyword arguments are \"color\", \"linestyle\", \"solid_capstyle\", and \"linewidth\". split_names : str If not None, this is used to split the values of `lines` into substrings that are drawn in the left and right margins, respectively.\n\nIf None, the values of `lines` are drawn in the left margin. section_order : array_like The section labels in the order in which they appear in the dotplot. line_order : array_like The line labels in the order in which they appear in the dotplot. stacked : bool If True, when multiple points or intervals are drawn on the same line, they are offset from each other. styles_order : array_like If stacked=True, this is the order in which the point styles on a given line are drawn from top to bottom (if horizontal is True) or from left to right (if horizontal is False).\n\nIf None (default), the order is lexical. striped : bool If True, every other line is enclosed in a shaded box. horizontal : bool If True (default), the lines are drawn horizontally, otherwise they are drawn vertically. show_names : str Determines whether labels (names) are shown in the left and/or right margins (top/bottom margins if `horizontal` is True). If `both`, labels are drawn in both margins, if 'left', labels are drawn in the left or top margin.\n\nIf `right`, labels are drawn in the right or bottom margin. fmt_left_name : callable The left/top margin names are passed through this function before drawing on the plot. fmt_right_name : callable The right/bottom marginnames are passed through this function before drawing on the plot. show_section_titles : bool or None If None, section titles are drawn only if there is more than one section.\n\nIf False/True, section titles are never/always drawn, respectively. ax : matplotlib.axes The axes on which the dotplot is drawn.\n\nIf None, a new axes is created.\n##### Returns\n* **fig **: Figure\n    The figure given by `ax.figure` or a new instance.\n\n* **.. [2] Jacoby, William G. (2006) \"The Dot Plot**: A Graphical Display\n   for Labeled Quantitative Values.\" The Political Methodologist\n   14(1)\n\n* **This is a simple dotplot with one point per line**: \n\n* **the same line)**: \n\n"
},{
    "source file": "durbin_levinson.py",
    "line number": "18",
    "func name": "durbin_levinson",
    "func arg": "(endog, ar_order, demean, adjusted)",
    "comments": "Estimate AR parameters at multiple orders using Durbin-Levinson recursions.\n\nParameters ---------- endog : array_like or SARIMAXSpecification Input time series array, assumed to be stationary. ar_order : int, optional Autoregressive order. Default is 0. demean : bool, optional Whether to estimate and remove the mean from the process prior to fitting the autoregressive coefficients. Default is True. adjusted : bool, optional Whether to use the \"adjusted\" autocovariance estimator, which uses n\n\n- h degrees of freedom rather than n. This option can result in a non-positive definite autocovariance matrix. Default is False.\n##### Returns\n* **parameters **: list of SARIMAXParams objects\n    List elements correspond to estimates at different `ar_order`. For\n    example, parameters[0] is an `SARIMAXParams` instance corresponding to\n    `ar_order=0`.\n\n* **other_results **: Bunch\n    Includes one component, `spec`, containing the `SARIMAXSpecification`\n    instance corresponding to the input arguments.\n\n"
},{
    "source file": "edgeworth.py",
    "line number": "97",
    "func name": "_norm_sf",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "elastic_net.py",
    "line number": "272",
    "func name": "_opt_1d",
    "func arg": "(func, grad, hess, model, start, L1_wt, tol, check_step)",
    "comments": "One-dimensional helper for elastic net.\n\nParameters ---------- func : function A smooth function of a single variable to be optimized with L1 penaty. grad : function The gradient of `func`. hess : function The Hessian of `func`. model : statsmodels model The model being fit. start : real A starting value for the function argument L1_wt : non-negative real The weight for the L1 penalty function. tol : non-negative real A convergence threshold. check_step : bool If True, check that the first step is an improvement and use bisection if it is not.\n\nIf False, return after the first step regardless.\n\nNotes ----- ``func``, ``grad``, and ``hess`` have argument signature (x, model), where ``x`` is a point in the parameter space and ``model`` is the model being fit.\n\nIf the log-likelihood for the model is exactly quadratic, the global minimum is returned in one step.\n\nOtherwise numerical bisection is used.\n##### Returns\n"
},{
    "source file": "empirical_distribution.py",
    "line number": "148",
    "func name": "monotone_fn_inverter",
    "func arg": "(fn, x, vectorized, **keywords)",
    "comments": "Given a monotone function fn (no checking is done to verify monotonicity) and a set of x values, return an linearly interpolated approximation to its inverse from its values on x.\n\n\n"
},{
    "source file": "estimators.py",
    "line number": "403",
    "func name": "fit_mps",
    "func arg": "(dist, data, x0)",
    "comments": "Estimate distribution parameters with Maximum Product-of-Spacings\n\nParameters ---------- params : array_like, tuple ? parameters of the distribution funciton xsorted : array_like data that is already sorted dist : instance of a distribution class only cdf method is used\n##### Returns\n* **x **: ndarray\n    estimates for the parameters of the distribution given the data,\n    including loc and scale\n\n"
},{
    "source file": "eval_measures.py",
    "line number": "528",
    "func name": "hqic_sigma",
    "func arg": "(sigma2, nobs, df_modelwc, islog)",
    "comments": "Hannan-Quinn information criterion (HQC)\n\nParameters ---------- sigma2 : float estimate of the residual variance or determinant of Sigma_hat in the multivariate case. If islog is true, then it is assumed that sigma is already log-ed, for example logdetSigma. nobs : int number of observations df_modelwc : int number of parameters including constant\n##### Returns\n* **hqic **: float\n    information criterion\n\n"
},{
    "source file": "ex_extras.py",
    "line number": "80",
    "func name": "examples_transf",
    "func arg": "()",
    "comments": ""
},{
    "source file": "ex_generic_mle_t.py",
    "line number": "25",
    "func name": "maxabsrel",
    "func arg": "(arr1, arr2)",
    "comments": ""
},{
    "source file": "ex_generic_mle_tdist.py",
    "line number": "30",
    "func name": "maxabsrel",
    "func arg": "(arr1, arr2)",
    "comments": ""
},{
    "source file": "ex_generic_mle.py",
    "line number": "22",
    "func name": "probitloglike",
    "func arg": "(params, endog, exog)",
    "comments": "Log likelihood for the probit\n\n\n"
},{
    "source file": "ex_kde_normalreference.py",
    "line number": "33",
    "func name": "true_pdf",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "ex_onewaygls.py",
    "line number": "106",
    "func name": "print_results2",
    "func arg": "(res)",
    "comments": ""
},{
    "source file": "ex_pandas.py",
    "line number": "47",
    "func name": "plot_acf_multiple",
    "func arg": "(ys, lags)",
    "comments": "\n\n\n"
},{
    "source file": "ex_ratereturn.py",
    "line number": "87",
    "func name": "cov2corr",
    "func arg": "(cov)",
    "comments": ""
},{
    "source file": "ex_rootfinding.py",
    "line number": "43",
    "func name": "func2",
    "func arg": "(x, a)",
    "comments": ""
},{
    "source file": "ex_transf2.py",
    "line number": "146",
    "func name": "test_squared_normal_chi2",
    "func arg": "()",
    "comments": ""
},{
    "source file": "example_arma.py",
    "line number": "269",
    "func name": "pltxcorr",
    "func arg": "(x, y, normed, detrend, usevlines, maxlags, **kwargs)",
    "comments": "call signature\n\ndef xcorr(self, x, y, normed=True, detrend=detrend_none, usevlines=True, maxlags=10, **kwargs):\n\nPlot the cross correlation between *x* and *y*.\n\nIf *normed* = *True*, normalize the data by the cross correlation at 0-th lag.\n\n*x* and y are detrended by the *detrend* callable (default no normalization).\n\n*x* and *y* must be equal length.\n\nData are plotted as ``plot(lags, c, **kwargs)``\n\nReturn value is a tuple (*lags*, *c*, *line*) where:\n\n- *lags* are a length ``2*maxlags+1`` lag vector\n\n- *c* is the ``2*maxlags+1`` auto correlation vector\n\n- *line* is a :class:`~matplotlib.lines.Line2D` instance returned by :func:`~matplotlib.pyplot.plot`.\n\nThe default *linestyle* is *None* and the default *marker* is 'o', though these can be overridden with keyword args.\n\nThe cross correlation is performed with :func:`numpy.correlate` with *mode* = 2.\n\nIf *usevlines* is *True*:\n\n:func:`~matplotlib.pyplot.vlines` rather than :func:`~matplotlib.pyplot.plot` is used to draw vertical lines from the origin to the xcorr.\n\nOtherwise the plotstyle is determined by the kwargs, which are :class:`~matplotlib.lines.Line2D` properties.\n\nThe return value is a tuple (*lags*, *c*, *linecol*, *b*) where *linecol* is the :class:`matplotlib.collections.LineCollection` instance and *b* is the *x*-axis.\n\n*maxlags* is a positive integer detailing the number of lags to show. The default value of *None* will return all ``(2*len(x)-1)`` lags.\n\n**Example:**\n\n:func:`~matplotlib.pyplot.xcorr` above, and :func:`~matplotlib.pyplot.acorr` below.\n\n**Example:**\n\n.. plot:: mpl_examples/pylab_examples/xcorr_demo.py\n"
},{
    "source file": "example_maxent.py",
    "line number": "14",
    "func name": "meanp",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "example_nbin.py",
    "line number": "296",
    "func name": "test_nb2",
    "func arg": "()",
    "comments": ""
},{
    "source file": "export_notebooks_to_python.py",
    "line number": "77",
    "func name": "main",
    "func arg": "()",
    "comments": ""
},{
    "source file": "extras.py",
    "line number": "1080",
    "func name": "mvnormcdf",
    "func arg": "(upper, mu, cov, lower, **kwds)",
    "comments": "multivariate normal cumulative distribution function\n\nThis is a wrapper for scipy.stats.kde.mvn.mvndst which calculates a rectangular integral over a multivariate normal distribution.\n\nParameters ---------- lower, upper : array_like, 1d lower and upper integration limits with length equal to the number of dimensions of the multivariate normal distribution. It can contain -np.inf or np.inf for open integration intervals mu : array_lik, 1d list or array of means cov : array_like, 2d specifies covariance matrix optional keyword parameters to influence integration * maxpts : int, maximum number of function values allowed. This parameter can be used to limit the time. A sensible strategy is to start with `maxpts` = 1000*N, and then increase `maxpts` if ERROR is too large. * abseps : float absolute error tolerance. * releps : float relative error tolerance.\n##### Returns\n* **cdfvalue **: float\n    value of the integral\n\n* **mvstdnormcdf **: location and scale standardized multivariate normal cdf\n\n"
},{
    "source file": "factor.py",
    "line number": "38",
    "func name": "_check_args_2",
    "func arg": "(endog, n_factor, corr, nobs, k_endog)",
    "comments": ""
},{
    "source file": "factorplots.py",
    "line number": "160",
    "func name": "_recode",
    "func arg": "(x, levels)",
    "comments": "Recode categorial data to int factor.\n\nParameters ---------- x : array_like array like object supporting with numpy array methods of categorially coded data. levels : dict mapping of labels to integer-codings\n##### Returns\n* **out **: instance numpy.ndarray\n\n"
},{
    "source file": "feasible_gls.py",
    "line number": "15",
    "func name": "atleast_2dcols",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "fftarma.py",
    "line number": "400",
    "func name": "spdar1",
    "func arg": "(ar, w)",
    "comments": ""
},{
    "source file": "filtertools.py",
    "line number": "302",
    "func name": "miso_lfilter",
    "func arg": "(ar, ma, x, useic)",
    "comments": "Filter multiple time series into a single time series.\n\nUses a convolution to merge inputs, and then lfilter to produce output.\n\nParameters ---------- ar : array_like The coefficients of autoregressive lag polynomial including lag zero, ar(L) in the expression ar(L)y_t. ma : array_like, same ndim as x, currently 2d The coefficient of the moving average lag polynomial, ma(L) in ma(L)x_t. x : array_like The 2-d input data series, time in rows, variables in columns. useic : bool Flag indicating whether to use initial conditions.\n##### Returns\n* **y **: ndarray\n    The filtered output series.\n\n* **inp **: ndarray, 1d\n    The combined input series.\n\n* **miso_lfilter find array y such that**: ar(L)y_t = ma(L)x_t\n\n"
},{
    "source file": "findow_1.py",
    "line number": "29",
    "func name": "getquotes",
    "func arg": "(symbol, start, end)",
    "comments": ""
},{
    "source file": "foreign.py",
    "line number": "1058",
    "func name": "savetxt",
    "func arg": "(fname, X, names, fmt, delimiter)",
    "comments": "Save an array to a text file.\n\nThis is just a copy of numpy.savetxt patched to support structured arrays or a header of names.\n\nDoes not include py3 support now in savetxt.\n\nParameters ---------- fname : filename or file handle If the filename ends in ``.gz``, the file is automatically saved in compressed gzip format.\n\n`loadtxt` understands gzipped files transparently. X : array_like Data to be saved to a text file. names : list, optional If given names will be the column header in the text file.\n\nIf None and X is a structured or recarray then the names are taken from X.dtype.names. fmt : str or sequence of strs A single format (%10.5f), a sequence of formats, or a multi-format string, e.g. 'Iteration %d -- %10.5f', in which case `delimiter` is ignored. delimiter : str Character separating columns.\n\nSee Also -------- save : Save an array to a binary file in NumPy ``.npy`` format savez : Save several arrays into a ``.npz`` compressed archive\n\nNotes ----- Further explanation of the `fmt` parameter (``%[flag]width[.precision]specifier``):\n\nflags: ``-`` : left justify\n\n``+`` : Forces to preceed result with + or -.\n\n``0`` : Left pad the number with zeros instead of space (see width).\n\nwidth: Minimum number of characters to be printed. The value is not truncated if it has more characters.\n\nprecision:\n\n- For integer specifiers (eg. ``d,i,o,x``), the minimum number of digits.\n\n- For ``e, E`` and ``f`` specifiers, the number of digits to print after the decimal point.\n\n- For ``g`` and ``G``, the maximum number of significant digits.\n\n- For ``s``, the maximum number of characters.\n\nspecifiers: ``c`` : character\n\n``d`` or ``i`` : signed decimal integer\n\n``e`` or ``E`` : scientific notation with ``e`` or ``E``.\n\n``f`` : decimal floating point\n\n``g,G`` : use the shorter of ``e,E`` or ``f``\n\n``o`` : signed octal\n\n``s`` : str of characters\n\n``u`` : unsigned decimal integer\n\n``x,X`` : unsigned hexadecimal integer\n\nThis explanation of ``fmt`` is not complete, for an exhaustive specification see [1]_.\n\nReferences ---------- .. [1] `Format Specification Mini-Language <http://docs.python.org/library/string.html# format-specification-mini-language>`_, Python Documentation.\n\nExamples -------- >>> savetxt('test.out', x, delimiter=',')\n\n # x is an array >>> savetxt('test.out', (x,y,z))\n\n # x,y,z equal sized 1D arrays >>> savetxt('test.out', x, fmt='%1.4e')\n\n # use exponential notation\n"
},{
    "source file": "formulas.py",
    "line number": "133",
    "func name": "log_plus_1",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "formulatools.py",
    "line number": "106",
    "func name": "make_hypotheses_matrices",
    "func arg": "(model_results, test_formula)",
    "comments": "\n\n\n"
},{
    "source file": "functional.py",
    "line number": "767",
    "func name": "banddepth",
    "func arg": "(data, method)",
    "comments": "Calculate the band depth for a set of functional curves.\n\nBand depth is an order statistic for functional data (see `fboxplot`), with a higher band depth indicating larger \"centrality\".\n\nIn analog to scalar data, the functional curve with highest band depth is called the median curve, and the band made up from the first N/2 of N curves is the 50% central region.\n\nParameters ---------- data : ndarray The vectors of functions to create a functional boxplot from. The first axis is the function index, the second axis the one along which the function is defined.\n\nSo ``data[0, :]`` is the first functional curve. method : {'MBD', 'BD2'}, optional Whether to use the original band depth (with J=2) of [1]_ or the modified band depth.\n\nSee Notes for details.\n##### Returns\n* **.. [3] Y. Sun, M. G. Gentonb and D. W. Nychkac, \"Exact fast computation\n       of band depth for large functional datasets**: How quickly can one\n       million curves be ranked?\", Journal for the Rapid Dissemination\n       of Statistics Research, vol. 1, pp. 68-74, 2012.\n\n"
},{
    "source file": "gam_cross_validation.py",
    "line number": "51",
    "func name": "_split_train_test_smoothers",
    "func arg": "(x, smoother, train_index, test_index)",
    "comments": "split smoothers in test and train sets and create GenericSmoothers\n\nNote: this does not take exog_linear into account\n"
},{
    "source file": "gam.py",
    "line number": "60",
    "func name": "default_smoother",
    "func arg": "(x, s_arg)",
    "comments": "\n\n\n"
},{
    "source file": "gee_categorical_simulation_check.py",
    "line number": "160",
    "func name": "gendat_nominal",
    "func arg": "()",
    "comments": ""
},{
    "source file": "gee_gaussian_simulation_check.py",
    "line number": "228",
    "func name": "gendat_nested1",
    "func arg": "()",
    "comments": ""
},{
    "source file": "gee_generate_tests.py",
    "line number": "197",
    "func name": "generate_poisson",
    "func arg": "()",
    "comments": ""
},{
    "source file": "gee_poisson_simulation_check.py",
    "line number": "166",
    "func name": "gendat_overdispersed",
    "func arg": "()",
    "comments": ""
},{
    "source file": "gee_simulation_check.py",
    "line number": "244",
    "func name": "gendat_nested1",
    "func arg": "()",
    "comments": ""
},{
    "source file": "generalized_additive_model.py",
    "line number": "976",
    "func name": "make_augmented_matrix",
    "func arg": "(endog, exog, penalty_matrix, weights)",
    "comments": "augment endog, exog and weights with stochastic restriction matrix\n\nParameters ---------- endog : ndarray response or endogenous variable exog : ndarray design matrix, matrix of exogenous or explanatory variables penalty_matrix : ndarray, 2-Dim square penality matrix for quadratic penalization weights : ndarray weights for WLS\n##### Returns\n* **endog_aug **: ndarray\n    augmented response variable\n\n* **exog_aug **: ndarray\n    augmented design matrix\n\n* **weights_aug **: ndarray\n    augmented weights for WLS\n\n"
},{
    "source file": "generalized_estimating_equations.py",
    "line number": "2489",
    "func name": "_score_test_submodel",
    "func arg": "(par, sub)",
    "comments": "Return transformation matrices for design matrices.\n\nParameters ---------- par : instance The parent model sub : instance The sub-model\n"
},{
    "source file": "generalized_linear_model.py",
    "line number": "53",
    "func name": "_check_convergence",
    "func arg": "(criterion, iteration, atol, rtol)",
    "comments": ""
},{
    "source file": "generate_formula_api.py",
    "line number": "45",
    "func name": "write_formula_api",
    "func arg": "(directory)",
    "comments": ""
},{
    "source file": "generic_mle.py",
    "line number": "103",
    "func name": "_ll_nb2",
    "func arg": "(y, X, beta, alph)",
    "comments": ""
},{
    "source file": "genpareto.py",
    "line number": "139",
    "func name": "meanexcess_dist",
    "func arg": "(lb, **kwds)",
    "comments": ""
},{
    "source file": "glm_formula.py",
    "line number": "40",
    "func name": "double_it",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "glm_weights.py",
    "line number": "88",
    "func name": "merge_tuple",
    "func arg": "(tpl)",
    "comments": ""
},{
    "source file": "gls.py",
    "line number": "26",
    "func name": "gls",
    "func arg": "(endog, exog, order, seasonal_order, include_constant, n_iter, max_iter, tolerance, arma_estimator, arma_estimator_kwargs)",
    "comments": "Estimate ARMAX parameters by GLS.\n\nParameters ---------- endog : array_like Input time series array. exog : array_like, optional Array of exogenous regressors. If not included, then `include_constant` must be True, and then `exog` will only include the constant column. order : tuple, optional The (p,d,q) order of the ARIMA model. Default is (0, 0, 0). seasonal_order : tuple, optional The (P,D,Q,s) order of the seasonal ARIMA model. Default is (0, 0, 0, 0). include_constant : bool, optional Whether to add a constant term in `exog` if it's not already there. The estimate of the constant will then appear as one of the `exog` parameters. If `exog` is None, then the constant will represent the mean of the process. Default is True if the specified model does not include integration and False otherwise. n_iter : int, optional Optionally iterate feasible GSL a specific number of times. Default is to iterate to convergence. If set, this argument overrides the `max_iter` and `tolerance` arguments. max_iter : int, optional Maximum number of feasible GLS iterations. Default is 50. If `n_iter` is set, it overrides this argument. tolerance : float, optional Tolerance for determining convergence of feasible GSL iterations. If `iter` is set, this argument has no effect. Default is 1e-8. arma_estimator : str, optional The estimator used for estimating the ARMA model. This option should not generally be used, unless the default method is failing or is otherwise unsuitable. Not all values will be valid, depending on the specified model orders (`order` and `seasonal_order`). Possible values are: * 'innovations_mle'\n\n- can be used with any specification * 'statespace'\n\n- can be used with any specification * 'hannan_rissanen'\n\n- can be used with any ARMA non-seasonal model * 'yule_walker'\n\n- only non-seasonal consecutive autoregressive (AR) models * 'burg'\n\n- only non-seasonal, consecutive autoregressive (AR) models * 'innovations'\n\n- only non-seasonal, consecutive moving average (MA) models. The default is 'innovations_mle'. arma_estimator_kwargs : dict, optional Arguments to pass to the ARMA estimator.\n##### Returns\n* **parameters **: SARIMAXParams object\n    Contains the parameter estimates from the final iteration.\n\n* **other_results **: Bunch\n    Includes eight components\n\n"
},{
    "source file": "gmm.py",
    "line number": "1630",
    "func name": "spec_hausman",
    "func arg": "(params_e, params_i, cov_params_e, cov_params_i, dof)",
    "comments": "Hausmans specification test\n\nParameters ---------- params_e : ndarray efficient and consistent under Null hypothesis, inconsistent under alternative hypothesis params_i: ndarray consistent under Null hypothesis, consistent under alternative hypothesis cov_params_e : ndarray, 2d covariance matrix of parameter estimates for params_e cov_params_i : ndarray, 2d covariance matrix of parameter estimates for params_i\n\nexample instrumental variables OLS estimator is `e`, IV estimator is `i`\n\n Notes -----\n\nTodos,Issues\n\n- check dof calculations and verify for linear case\n\n- check one-sided hypothesis\n\n References ---------- Greene section 5.5 p.82/83\n"
},{
    "source file": "gof_new.py",
    "line number": "591",
    "func name": "bootstrap2",
    "func arg": "(value, distr, args, nobs, nrep)",
    "comments": "Monte Carlo (or parametric bootstrap) p-values for gof\n\ncurrently hardcoded for A^2 only\n\nnon vectorized, loops over all parametric bootstrap replications and calculates and returns specific p-value,\n\nrename function to less generic\n"
},{
    "source file": "gof.py",
    "line number": "440",
    "func name": "chisquare_effectsize",
    "func arg": "(probs0, probs1, correction, cohen, axis)",
    "comments": "effect size for a chisquare goodness-of-fit test\n\nParameters ---------- probs0 : array_like probabilities or cell frequencies under the Null hypothesis probs1 : array_like probabilities or cell frequencies under the Alternative hypothesis probs0 and probs1 need to have the same length in the ``axis`` dimension. and broadcast in the other dimensions Both probs0 and probs1 are normalized to add to one (in the ``axis`` dimension). correction : None or tuple If None, then the effect size is the chisquare statistic divide by the number of observations. If the correction is a tuple (nobs, df), then the effectsize is corrected to have less bias and a smaller variance. However, the correction can make the effectsize negative. In that case, the effectsize is set to zero. Pederson and Johnson (1990) as referenced in McLaren et all. (1994) cohen : bool If True, then the square root is returned as in the definition of the effect size by Cohen (1977), If False, then the original effect size is returned. axis : int If the probability arrays broadcast to more than 1 dimension, then this is the axis over which the sums are taken.\n##### Returns\n* **effectsize **: float\n    effect size of chisquare test\n\n"
},{
    "source file": "gofplots.py",
    "line number": "870",
    "func name": "_check_for_ppf",
    "func arg": "(dist)",
    "comments": ""
},{
    "source file": "graphics_mosaicplot_mosaic.py",
    "line number": "46",
    "func name": "labelizer",
    "func arg": "(key)",
    "comments": ""
},{
    "source file": "grouputils.py",
    "line number": "305",
    "func name": "_make_generic_names",
    "func arg": "(index)",
    "comments": ""
},{
    "source file": "hannan_rissanen.py",
    "line number": "18",
    "func name": "hannan_rissanen",
    "func arg": "(endog, ar_order, ma_order, demean, initial_ar_order, unbiased)",
    "comments": "Estimate ARMA parameters using Hannan-Rissanen procedure.\n\nParameters ---------- endog : array_like Input time series array, assumed to be stationary. ar_order : int Autoregressive order ma_order : int Moving average order demean : bool, optional Whether to estimate and remove the mean from the process prior to fitting the ARMA coefficients. Default is True. initial_ar_order : int, optional Order of long autoregressive process used for initial computation of residuals. unbiased: bool, optional Whether or not to apply the bias correction step. Default is True if the estimated coefficients from the previous step imply a stationary and invertible process and False otherwise.\n##### Returns\n* **parameters **: SARIMAXParams object\n\n* **other_results **: Bunch\n    Includes three components\n\n* **possible. See test_hannan_rissanen**: \n\n"
},{
    "source file": "holtwinters.py",
    "line number": "212",
    "func name": "_holt_win_mul_add_dam",
    "func arg": "(x, xi, p, y, l, b, s, m, n, max_seen)",
    "comments": "Multiplicative and Multiplicative Damped with Additive Seasonal Minimization Function (M,A) & (M,Ad)\n\n\n"
},{
    "source file": "hp_filter.py",
    "line number": "8",
    "func name": "hpfilter",
    "func arg": "(x, lamb)",
    "comments": "Hodrick-Prescott filter.\n\nParameters ---------- x : array_like The time series to filter, 1-d. lamb : float The Hodrick-Prescott smoothing parameter. A value of 1600 is suggested for quarterly data. Ravn and Uhlig suggest using a value of 6.25 (1600/4**4) for annual data and 129600 (1600*3**4) for monthly data.\n##### Returns\n* **cycle **: ndarray\n    The estimated cycle in the data given lamb.\n\n* **trend **: ndarray\n    The estimated trend in the data given lamb.\n\n* **Hodrick, R.J, and E. C. Prescott. 1980. \"Postwar U.S. Business Cycles**: An\n    Empirical Investigation.\" `Carnegie Mellon University discussion\n    paper no. 451`.\n\n* **>>> gdp_decomp[[\"realgdp\", \"trend\"]][\"2000-03-31\"**: ].plot(ax=ax,\n\n* **.. plot**: \n\n"
},{
    "source file": "infotheo.py",
    "line number": "414",
    "func name": "gencrossentropy",
    "func arg": "(px, py, pxpy, alpha, logbase, measure)",
    "comments": "Generalized cross-entropy measures.\n\nParameters ---------- px : array_like Discrete probability distribution of random variable X py : array_like Discrete probability distribution of random variable Y pxpy : 2d array_like, optional Joint probability distribution of X and Y.\n\nIf pxpy is None, X and Y are assumed to be independent. logbase : int or np.e, optional Default is 2 (bits) measure : str, optional The measure is the type of generalized cross-entropy desired. 'T' is the cross-entropy version of the Tsallis measure.\n\n'CR' is Cressie-Read measure.\n"
},{
    "source file": "initialization56.py",
    "line number": "37",
    "func name": "_initialization_heuristic",
    "func arg": "(endog, trend, seasonal, seasonal_periods)",
    "comments": ""
},{
    "source file": "innovations.py",
    "line number": "89",
    "func name": "innovations_mle",
    "func arg": "(endog, order, seasonal_order, demean, enforce_invertibility, start_params, minimize_kwargs)",
    "comments": "Estimate SARIMA parameters by MLE using innovations algorithm.\n\nParameters ---------- endog : array_like Input time series array. order : tuple, optional The (p,d,q) order of the model for the number of AR parameters, differences, and MA parameters. Default is (0, 0, 0). seasonal_order : tuple, optional The (P,D,Q,s) order of the seasonal component of the model for the AR parameters, differences, MA parameters, and periodicity. Default is (0, 0, 0, 0). demean : bool, optional Whether to estimate and remove the mean from the process prior to fitting the SARIMA coefficients. Default is True. enforce_invertibility : bool, optional Whether or not to transform the MA parameters to enforce invertibility in the moving average component of the model. Default is True. start_params : array_like, optional Initial guess of the solution for the loglikelihood maximization. The AR polynomial must be stationary. If `enforce_invertibility=True` the MA poylnomial must be invertible. If not provided, default starting parameters are computed using the Hannan-Rissanen method. minimize_kwargs : dict, optional Arguments to pass to scipy.optimize.minimize.\n##### Returns\n* **parameters **: SARIMAXParams object\n\n* **other_results **: Bunch\n    Includes four components\n\n* **Note**: we do not include `enforce_stationarity` as an argument, because this\n\n* **TODO**: add support for secondary optimization that does not enforce\n      stationarity / invertibility, starting from first step's parameters\n\n"
},{
    "source file": "inter_rater.py",
    "line number": "268",
    "func name": "cohens_kappa",
    "func arg": "(table, weights, return_results, wt)",
    "comments": "Compute Cohen's kappa with variance and equal-zero test\n\nParameters ---------- table : array_like, 2-Dim square array with results of two raters, one rater in rows, second rater in columns weights : array_like The interpretation of weights depends on the wt argument. If both are None, then the simple kappa is computed. see wt for the case when wt is not None If weights is two dimensional, then it is directly used as a weight matrix. For computing the variance of kappa, the maximum of the weights is assumed to be smaller or equal to one. TODO: fix conflicting definitions in the 2-Dim case for wt : {None, str} If wt and weights are None, then the simple kappa is computed. If wt is given, but weights is None, then the weights are set to be [0, 1, 2, ..., k]. If weights is a one-dimensional array, then it is used to construct the weight matrix given the following options.\n\nwt in ['linear', 'ca' or None] : use linear weights, Cicchetti-Allison actual weights are linear in the score \"weights\" difference wt in ['quadratic', 'fc'] : use linear weights, Fleiss-Cohen actual weights are squared in the score \"weights\" difference wt = 'toeplitz' : weight matrix is constructed as a toeplitz matrix from the one dimensional weights.\n\nreturn_results : bool If True (default), then an instance of KappaResults is returned. If False, then only kappa is computed and returned.\n##### Returns\n* **example**: \n\n"
},{
    "source file": "kde.py",
    "line number": "373",
    "func name": "kdensityfft",
    "func arg": "(X, kernel, bw, weights, gridsize, adjust, clip, cut, retgrid)",
    "comments": "Rosenblatt-Parzen univariate kernel density estimator\n\nParameters ---------- X : array_like The variable for which the density estimate is desired. kernel : str ONLY GAUSSIAN IS CURRENTLY IMPLEMENTED. \"bi\" for biweight \"cos\" for cosine \"epa\" for Epanechnikov, default \"epa2\" for alternative Epanechnikov \"gau\" for Gaussian. \"par\" for Parzen \"rect\" for rectangular \"tri\" for triangular bw : str, float \"scott\"\n\n- 1.059 * A * nobs ** (-1/5.), where A is min(std(X),IQR/1.34) \"silverman\"\n\n- .9 * A * nobs ** (-1/5.), where A is min(std(X),IQR/1.34) If a float is given, it is the bandwidth. weights : array or None WEIGHTS ARE NOT CURRENTLY IMPLEMENTED. Optional\n\nweights. If the X value is clipped, then this weight is also dropped. gridsize : int If gridsize is None, min(len(X), 512) is used. Note that the provided number is rounded up to the next highest power of 2. adjust : float An adjustment factor for the bw. Bandwidth becomes bw * adjust. clip : tuple Observations in X that are outside of the range given by clip are dropped. The number of observations in X is then shortened. cut : float Defines the length of the grid past the lowest and highest values of X so that the kernel goes to zero. The end points are -/+ cut*bw*{X.min() or X.max()} retgrid : bool Whether or not to return the grid over which the density is estimated.\n##### Returns\n* **density **: ndarray\n    The densities estimated at the grid points.\n\n* **grid **: ndarray, optional\n    The grid points at which the density is estimated.\n\n* **Jones, M.C. and H.W. Lotwick. (1984) `Remark AS R50**: A Remark on Algorithm\n    AS 176. Kernal Density Estimation Using the Fast Fourier Transform`.\n    Journal of the Royal Statistical Society. Series C. 33.1, 120-2.\n\n"
},{
    "source file": "kdecovclass.py",
    "line number": "68",
    "func name": "test_kde_1d",
    "func arg": "()",
    "comments": ""
},{
    "source file": "kdetools.py",
    "line number": "54",
    "func name": "kdesum",
    "func arg": "(x, axis)",
    "comments": ""
},{
    "source file": "kernels58.py",
    "line number": "220",
    "func name": "wang_ryzin_reg",
    "func arg": "(h, Xi, x)",
    "comments": "A version for the Wang-Ryzin kernel for nonparametric regression.\n\nSuggested by Li and Racine in [1] ch.4\n"
},{
    "source file": "kernridgeregress_class.py",
    "line number": "167",
    "func name": "example2",
    "func arg": "(m, scale, stride)",
    "comments": ""
},{
    "source file": "kfas_helpers.py",
    "line number": "8",
    "func name": "parse",
    "func arg": "(path, ssm)",
    "comments": ""
},{
    "source file": "l1_cvxopt.py",
    "line number": "180",
    "func name": "_hessian_wrapper",
    "func arg": "(hess, x, z, k_params)",
    "comments": "Wraps the hessian up in the form for cvxopt.\n\ncvxopt wants the hessian of the objective function and the constraints. Since our constraints are linear, this part is all zeros.\n"
},{
    "source file": "l1_slsqp.py",
    "line number": "159",
    "func name": "_fprime_ieqcons",
    "func arg": "(x_full, k_params)",
    "comments": "Derivative of the inequality constraints\n\n\n"
},{
    "source file": "l1_solvers_common.py",
    "line number": "93",
    "func name": "do_trim_params",
    "func arg": "(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol)",
    "comments": "Trims (set to zero) params that are zero at the theoretical minimum. Uses heuristics to account for the solver not actually finding the minimum.\n\nIn all cases, if alpha[i] == 0, then do not trim the ith param. In all cases, do nothing with the added variables.\n\nParameters ---------- params : ndarray model parameters.\n\nNot including added variables. k_params : Int Number of parameters alpha : ndarray regularization coefficients score : Function. score(params) should return a 1-d vector of derivatives of the unpenalized objective function. passed : bool True if the QC check passed trim_mode : 'auto, 'size', or 'off' If not 'off', trim (set to zero) parameters that would have been zero if the solver reached the theoretical minimum. If 'auto', trim params using the Theory above. If 'size', trim params if they have very small absolute value size_trim_tol : float or 'auto' (default = 'auto') For use when trim_mode === 'size' auto_trim_tol : float For sue when trim_mode == 'auto'.\n\nUse qc_tol : float Print warning and do not allow auto trim when (ii) in \"Theory\" (above) is violated by this much.\n##### Returns\n* **params **: ndarray\n    Trimmed model parameters\n\n* **trimmed **: ndarray of booleans\n    trimmed[i] == True if the ith parameter was trimmed.\n\n"
},{
    "source file": "lilliefors_critical_value_simulation.py",
    "line number": "32",
    "func name": "simulations",
    "func arg": "(sim_type, save)",
    "comments": ""
},{
    "source file": "linalg_covmat.py",
    "line number": "187",
    "func name": "mvn_nloglike_obs",
    "func arg": "(x, sigma)",
    "comments": "loglike multivariate normal\n\nassumes x is 1d, (nobs,) and sigma is 2d (nobs, nobs)\n\nbrute force from formula no checking of correct inputs use of inv and log-det should be replace with something more efficient\n"
},{
    "source file": "linalg_decomp_1.py",
    "line number": "227",
    "func name": "maxabs",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "linalg.py",
    "line number": "116",
    "func name": "matrix_sqrt",
    "func arg": "(mat, inverse, full, nullspace, threshold)",
    "comments": "matrix square root for symmetric matrices\n\nUsage is for decomposing a covariance function S into a square root R such that\n\nR' R = S if inverse is False, or R' R = pinv(S) if inverse is True\n\nParameters ---------- mat : array_like, 2-d square symmetric square matrix for which square root or inverse square root is computed. There is no checking for whether the matrix is symmetric. A warning is issued if some singular values are negative, i.e. below the negative of the threshold. inverse : bool If False (default), then the matrix square root is returned. If inverse is True, then the matrix square root of the inverse matrix is returned. full : bool If full is False (default, then the square root has reduce number of rows if the matrix is singular, i.e. has singular values below the threshold. nullspace: bool If nullspace is true, then the matrix square root of the null space of the matrix is returned. threshold : float Singular values below the threshold are dropped.\n##### Returns\n* **msqrt **: ndarray\n    matrix square root or square root of inverse matrix.\n\n"
},{
    "source file": "linear_model.py",
    "line number": "1437",
    "func name": "burg",
    "func arg": "(endog, order, demean)",
    "comments": "Compute Burg's AP(p) parameter estimator.\n\nParameters ---------- endog : array_like The endogenous variable. order : int, optional Order of the AR.\n\nDefault is 1. demean : bool, optional Flag indicating to subtract the mean from endog before estimation.\n##### Returns\n* **rho **: ndarray\n    The AR(p) coefficients computed using Burg's algorithm.\n\n* **sigma2 **: float\n    The estimate of the residual variance.\n\n* **yule_walker **: Estimate AR parameters using the Yule-Walker method.\n\n"
},{
    "source file": "make_tbls.py",
    "line number": "423",
    "func name": "qhat",
    "func arg": "(a, p, r, v)",
    "comments": ""
},{
    "source file": "maketests_mlabwrap.py",
    "line number": "191",
    "func name": "exampletest",
    "func arg": "(res_armarep)",
    "comments": ""
},{
    "source file": "markov_switching.py",
    "line number": "227",
    "func name": "cy_kim_smoother_log",
    "func arg": "(regime_transition, predicted_joint_probabilities, filtered_joint_probabilities)",
    "comments": "Kim smoother in log space using Cython inner loop.\n\nParameters ---------- regime_transition : ndarray Matrix of regime transition probabilities, shaped either (k_regimes, k_regimes, 1) or if there are time-varying transition probabilities (k_regimes, k_regimes, nobs). predicted_joint_probabilities : ndarray Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}]\n\n- the joint probability of the current and previous `order` periods being in each combination of regimes conditional on time t-1 information. Shaped (k_regimes,) * (order + 1) + (nobs,). filtered_joint_probabilities : ndarray Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}]\n\n- the joint probability of the current and previous `order` periods being in each combination of regimes conditional on time t information. Shaped (k_regimes,) * (order + 1) + (nobs,).\n##### Returns\n* **smoothed_joint_probabilities **: ndarray\n    Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_T] -\n    the joint probability of the current and previous `order` periods\n    being in each combination of regimes conditional on all information.\n    Shaped (k_regimes,) * (order + 1) + (nobs,).\n\n* **smoothed_marginal_probabilities **: ndarray\n    Array containing Pr[S_t=s_t | Y_T] - the probability of being in each\n    regime conditional on all information. Shaped (k_regimes, nobs).\n\n"
},{
    "source file": "matchdist.py",
    "line number": "24",
    "func name": "plothist",
    "func arg": "(x, distfn, args, loc, scale, right)",
    "comments": ""
},{
    "source file": "mediation.py",
    "line number": "340",
    "func name": "_pvalue",
    "func arg": "(vec)",
    "comments": ""
},{
    "source file": "meta_analysis.py",
    "line number": "695",
    "func name": "_fit_tau_iter_mm",
    "func arg": "(eff, var_eff, tau2_start, atol, maxiter)",
    "comments": "iterated method of moment estimate of between random effect variance\n\nThis repeatedly estimates tau, updating weights in each iteration see two-step estimators in DerSimonian and Kacker 2007\n\nParameters ---------- eff : ndarray effect sizes var_eff : ndarray variance of effect sizes tau2_start : float starting value for iteration atol : float, default: 1e-5 convergence tolerance for change in tau2 estimate between iterations maxiter : int maximum number of iterations\n##### Returns\n* **tau2 **: float\n    estimate of random effects variance tau squared\n\n* **converged **: bool\n    True if iteration has converged.\n\n"
},{
    "source file": "mixed_linear_model.py",
    "line number": "2848",
    "func name": "_handle_missing",
    "func arg": "(data, groups, formula, re_formula, vc_formula)",
    "comments": ""
},{
    "source file": "mixture_rvs.py",
    "line number": "185",
    "func name": "mv_mixture_rvs",
    "func arg": "(prob, size, dist, nvars, **kwargs)",
    "comments": "Sample from a mixture of multivariate distributions.\n\nParameters ---------- prob : array_like Probability of sampling from each distribution in dist size : int The length of the returned sample. dist : array_like An iterable of distributions instances with callable method rvs. nvargs : int dimension of the multivariate distribution, could be inferred instead kwargs : tuple of dicts, optional ignored\n\nExamples -------- Say we want 2000 random variables from mixture of normals with two multivariate normal distributions, and we want to sample from the first with probability .4 and the second with probability .6.\n\nimport statsmodels.sandbox.distributions.mv_normal as mvd\n\ncov3 = np.array([[ 1.\n\n,\n\n0.5 ,\n\n0.75], [ 0.5 ,\n\n1.5 ,\n\n0.6 ], [ 0.75,\n\n0.6 ,\n\n2.\n\n]])\n\nmu = np.array([-1, 0.0, 2.0]) mu2 = np.array([4, 2.0, 2.0]) mvn3 = mvd.MVNormal(mu, cov3) mvn32 = mvd.MVNormal(mu2, cov3/2., 4) rvs = mix.mv_mixture_rvs([0.4, 0.6], 2000, [mvn3, mvn32], 3)\n"
},{
    "source file": "mle.py",
    "line number": "24",
    "func name": "Rpp",
    "func arg": "(v)",
    "comments": "Hessian\n\n\n"
},{
    "source file": "mlemodel61.py",
    "line number": "64",
    "func name": "_check_index",
    "func arg": "(desired_index, dta, title)",
    "comments": ""
},{
    "source file": "moment_helpers.py",
    "line number": "287",
    "func name": "se_cov",
    "func arg": "(cov)",
    "comments": "get standard deviation from covariance matrix\n\njust a shorthand function np.sqrt(np.diag(cov))\n\nParameters ---------- cov : array_like, square covariance matrix\n##### Returns\n* **std **: ndarray\n    standard deviation from diagonal of cov\n\n"
},{
    "source file": "mosaicplot.py",
    "line number": "468",
    "func name": "mosaic",
    "func arg": "(data, index, ax, horizontal, gap, properties, labelizer, title, statistic, axes_label, label_rotation)",
    "comments": "Create a mosaic plot from a contingency table.\n\nIt allows to visualize multivariate categorical data in a rigorous and informative way.\n\nParameters ---------- data : {dict, Series, ndarray, DataFrame} The contingency table that contains the data. Each category should contain a non-negative number with a tuple as index.\n\nIt expects that all the combination of keys to be represents; if that is not true, will automatically consider the missing values as 0.\n\nThe order of the keys will be the same as the one of insertion. If a dict of a Series (or any other dict like object) is used, it will take the keys as labels.\n\nIf a np.ndarray is provided, it will generate a simple numerical labels. index : list, optional Gives the preferred order for the category ordering. If not specified will default to the given order.\n\nIt does not support named indexes for hierarchical Series.\n\nIf a DataFrame is provided, it expects a list with the name of the columns. ax : Axes, optional The graph where display the mosaic. If not given, will create a new figure horizontal : bool, optional The starting direction of the split (by default along the horizontal axis) gap : {float, sequence[float]} The list of gaps to be applied on each subdivision. If the length of the given array is less of the number of subcategories (or if it's a single number) it will extend it with exponentially decreasing gaps properties : dict[str, callable], optional A function that for each tile in the mosaic take the key of the tile and returns the dictionary of properties of the generated Rectangle, like color, hatch or similar. A default properties set will be provided fot the keys whose color has not been defined, and will use color variation to help visually separates the various categories. It should return None to indicate that it should use the default property for the tile. A dictionary of the properties for each key can be passed, and it will be internally converted to the correct function labelizer : dict[str, callable], optional A function that generate the text to display at the center of each tile base on the key of that tile title : str, optional The title of the axis statistic : bool, optional If true will use a crude statistical model to give colors to the plot. If the tile has a constraint that is more than 2 standard deviation from the expected value under independence hypothesis, it will go from green to red (for positive deviations, blue otherwise) and will acquire an hatching when crosses the 3 sigma. axes_label : bool, optional Show the name of each value of each category on the axis (default) or hide them. label_rotation : {float, list[float]} The rotation of the axis label (if present). If a list is given each axis can have a different rotation\n##### Returns\n* **fig **: Figure\n    The figure containing the plot.\n\n* **rects **: dict\n    A dictionary that has the same keys of the original\n    dataset, that holds a reference to the coordinates of the\n    tile and the Rectangle that represent it.\n\n* **>>> data = {'a'**: 10, 'b'\n\n* **>>> data = {('a', 'b')**: 1, ('a', 'c')\n\n* **>>> props = lambda key**: {'color'\n\n* **>>> labelizer = lambda k**: {('a',)\n\n* **...                        ('c',)**: 'third'}[k]\n\n* **>>> data = pd.DataFrame({'gender'**: gender, 'pet'\n\n* **.. plot **: \n\n"
},{
    "source file": "movstat.py",
    "line number": "208",
    "func name": "movmoment",
    "func arg": "(x, k, windowsize, lag)",
    "comments": "non-central moment\n\nParameters ---------- x : ndarray time series data windsize : int window size lag : 'lagged', 'centered', or 'leading' location of window relative to current position\n##### Returns\n* **mk **: ndarray\n    k-th moving non-central moment, with same shape as x\n\n"
},{
    "source file": "multicomp.py",
    "line number": "1745",
    "func name": "set_remove_subs",
    "func arg": "(ssli)",
    "comments": "remove sets that are subsets of another set from a list of tuples\n\nParameters ---------- ssli : list of tuples each tuple is considered as a set\n##### Returns\n* **part **: list of tuples\n    new list with subset tuples removed, it is sorted by set-length of tuples. The\n    list contains original tuples, duplicate elements are not removed.\n\n"
},{
    "source file": "multicomp63.py",
    "line number": "14",
    "func name": "pairwise_tukeyhsd",
    "func arg": "(endog, groups, alpha)",
    "comments": "Calculate all pairwise comparisons with TukeyHSD confidence intervals\n\nParameters ---------- endog : ndarray, float, 1d response variable groups : ndarray, 1d array with groups, can be string or integers alpha : float significance level for the test\n##### Returns\n* **results **: TukeyHSDResults instance\n    A results class containing relevant data and some post-hoc\n    calculations, including adjusted p-value\n\n"
},{
    "source file": "multilinear.py",
    "line number": "225",
    "func name": "multigroup",
    "func arg": "(pvals, groups, exact, keep_all, alpha)",
    "comments": "Test if the given groups are different from the total partition.\n\nGiven a boolean array test if each group has a proportion of positives different than the complexive proportion. The test can be done as an exact Fisher test or approximated as a Chi squared test for more speed.\n\nParameters ---------- pvals: pandas series of boolean the significativity of the variables under analysis groups: dict of list the name of each category of variables under exam. each one is a list of the variables included exact: bool, optional If True (default) use the fisher exact test, otherwise use the chi squared test for contingencies tables. For high number of elements in the array the fisher test can be significantly slower than the chi squared. keep_all: bool, optional if False it will drop those groups where the fraction of positive is below the expected result. If True (default) it will keep all the significant results. alpha: float, optional the significativity level for the pvalue correction on the whole set of groups (not inside the groups themselves).\n##### Returns\n* **result_df**: pandas dataframe\n    for each group returns\n\n* **>>> url = \"https**: //raw.githubusercontent.com/vincentarelbundock/\"\n\n"
},{
    "source file": "multitest.py",
    "line number": "456",
    "func name": "local_fdr",
    "func arg": "(zscores, null_proportion, null_pdf, deg, nbins, alpha)",
    "comments": "Calculate local FDR values for a list of Z-scores.\n\nParameters ---------- zscores : array_like A vector of Z-scores null_proportion : float The assumed proportion of true null hypotheses null_pdf : function mapping reals to positive reals The density of null Z-scores; if None, use standard normal deg : int The maximum exponent in the polynomial expansion of the density of non-null Z-scores nbins : int The number of bins for estimating the marginal density of Z-scores. alpha : float Use Poisson ridge regression with parameter alpha to estimate the density of non-null Z-scores.\n##### Returns\n* **fdr **: array_like\n    A vector of FDR values\n\n* **Model.  Statistical Science 23**: 1, 1-22.\n\n* **Basic use (the null Z-scores are taken to be standard normal)**: \n\n* **Use a Gaussian null distribution estimated from the data**: \n\n"
},{
    "source file": "multivariate_ols.py",
    "line number": "266",
    "func name": "_multivariate_test",
    "func arg": "(hypotheses, exog_names, endog_names, fn)",
    "comments": "Multivariate linear model hypotheses testing\n\nFor y = x * params, where y are the dependent variables and x are the independent variables, testing L * params * M = 0 where L is the contrast matrix for hypotheses testing and M is the transformation matrix for transforming the dependent variables in y.\n\nAlgorithm: T = L*inv(X'X)*L' H = M'B'L'*inv(T)*LBM E =\n\nM'(Y'Y\n\n- B'X'XB)M And then finding the eigenvalues of inv(H + E)*H\n\n.. [*] https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_introreg_sect012.htm\n\nParameters ---------- %(hypotheses_doc)s k_xvar : int The number of independent variables k_yvar : int The number of dependent variables fn : function a function fn(contrast_L, transform_M) that returns E, H, q, df_resid where q is the rank of T matrix\n##### Returns\n* **results **: MANOVAResults\n\n"
},{
    "source file": "multivariate_tools.py",
    "line number": "184",
    "func name": "cc_stats",
    "func arg": "(x1, x2, demean)",
    "comments": "MANOVA statistics based on canonical correlation coefficient\n\nCalculates Pillai's Trace, Wilk's Lambda, Hotelling's Trace and Roy's Largest Root.\n\nParameters ---------- x1, x2 : ndarrays, 2_D two 2-dimensional data arrays, observations in rows, variables in columns demean : bool If demean is true, then the mean is subtracted from each variable.\n##### Returns\n* **res **: dict\n    Dictionary containing the test statistics.\n\n* **missing**: F-statistics and p-values\n\n* **TODO**: should return a results class instead\n\n"
},{
    "source file": "multivariate.py",
    "line number": "88",
    "func name": "multivariate_t_rvs",
    "func arg": "(m, S, df, n)",
    "comments": "generate random variables of multivariate t distribution\n\nParameters ---------- m : array_like mean of random variable, length determines dimension of random variable S : array_like square array of covariance\n\nmatrix df : int or float degrees of freedom n : int number of observations, return random array will be (n, len(m))\n##### Returns\n* **rvs **: ndarray, (n, len(m))\n    each row is an independent draw of a multivariate t distributed\n    random variable\n\n"
},{
    "source file": "multivariate64.py",
    "line number": "506",
    "func name": "test_cov_oneway",
    "func arg": "(cov_list, nobs_list)",
    "comments": "Multiple sample hypothesis test that covariance matrices are equal.\n\nThis is commonly known as Box-M test.\n\nThe Null and alternative hypotheses are\n\n.. math::\n\nH0 &: \\Sigma_i = \\Sigma_j\n\n\\text{ for all i and j} \\\\ H1 &: \\Sigma_i \\neq \\Sigma_j \\text{ for at least one i and j}\n\nwhere :math:`\\Sigma_i` is the covariance of sample `i`.\n\nParameters ---------- cov_list : list of array_like Covariance matrices of the sample, estimated with denominator ``(N\n\n- 1)``, i.e. `ddof=1`. nobs_list : list List of the number of observations used in the estimation of the covariance for each sample.\n##### Attributes\n* **Multivariate Analysis**: Rencher/Methods. Wiley Series in Probability and\n\n* **Statistics. Hoboken, NJ, USA**: John Wiley & Sons, Inc.\n\n* **https**: //doi.org/10.1002/9781118391686.\n\n* **StataCorp, L. P. Stata Multivariate Statistics**: Reference Manual.\n\n##### Returns\n* **res **: instance of HolderTuple\n    Results contains test statistic and pvalues for both chisquare and F\n    distribution based tests, identified by the name ending \"_chi2\" and\n    \"_f\".\n\n"
},{
    "source file": "mv_measures.py",
    "line number": "74",
    "func name": "mutualinfo_binned",
    "func arg": "(y, x, bins, normed)",
    "comments": "mutual information of two random variables estimated with kde\n\nNotes ----- bins='auto' selects the number of bins so that approximately 5 observations are expected to be in each bin under the assumption of independence. This follows roughly the description in Kahn et al. 2007\n"
},{
    "source file": "mv_normal.py",
    "line number": "1176",
    "func name": "quad2d",
    "func arg": "(func, lower, upper)",
    "comments": ""
},{
    "source file": "nbgenerate.py",
    "line number": "254",
    "func name": "main",
    "func arg": "()",
    "comments": ""
},{
    "source file": "norms.py",
    "line number": "827",
    "func name": "estimate_location",
    "func arg": "(a, scale, norm, axis, initial, maxiter, tol)",
    "comments": "M-estimator of location using self.norm and a current estimator of scale.\n\nThis iteratively finds a solution to\n\nnorm.psi((a-mu)/scale).sum() == 0\n\nParameters ---------- a : ndarray Array over which the location parameter is to be estimated scale : ndarray Scale parameter to be used in M-estimator norm : RobustNorm, optional Robust norm used in the M-estimator.\n\nThe default is HuberT(). axis : int, optional Axis along which to estimate the location parameter.\n\nThe default is 0. initial : ndarray, optional Initial condition for the location parameter.\n\nDefault is None, which uses the median of a. niter : int, optional Maximum number of iterations.\n\nThe default is 30. tol : float, optional Toleration for convergence.\n\nThe default is 1e-06.\n##### Returns\n* **mu **: ndarray\n    Estimate of location\n\n"
},{
    "source file": "numdiff.py",
    "line number": "344",
    "func name": "approx_hess3",
    "func arg": "(x, f, epsilon, args, kwargs)",
    "comments": ""
},{
    "source file": "numpy.py",
    "line number": "68",
    "func name": "lstsq",
    "func arg": "(a, b, rcond)",
    "comments": "Shim that allows modern rcond setting with backward compat for NumPY earlier than 1.14\n\n\n"
},{
    "source file": "ols_anova_original.py",
    "line number": "270",
    "func name": "dropname",
    "func arg": "(ss, li)",
    "comments": "drop names from a list of strings, names to drop are in space delimited list does not change original list\n\n\n"
},{
    "source file": "oneway.py",
    "line number": "886",
    "func name": "equivalence_scale_oneway",
    "func arg": "(data, equiv_margin, method, center, transform, trim_frac_mean, trim_frac_anova)",
    "comments": "Oneway Anova test for equivalence of scale, variance or dispersion\n\nThis hypothesis test performs a oneway equivalence anova test on transformed data.\n\nNote, the interpretation of the equivalence margin `equiv_margin` will depend on the transformation of the data. Transformations like absolute deviation are not scaled to correspond to the variance under normal distribution.\n"
},{
    "source file": "openfile.py",
    "line number": "35",
    "func name": "get_file_obj",
    "func arg": "(fname, mode, encoding)",
    "comments": "Light wrapper to handle strings, path objects and let files (anything else) pass through.\n\nIt also handle '.gz' files.\n\nParameters ---------- fname : str, path object or file-like object File to open / forward mode : str Argument passed to the 'open' or 'gzip.open' function encoding : str For Python 3 only, specify the encoding of the file\n##### Returns\n"
},{
    "source file": "optimizer.py",
    "line number": "595",
    "func name": "_fit_basinhopping",
    "func arg": "(f, score, start_params, fargs, kwargs, disp, maxiter, callback, retall, full_output, hess)",
    "comments": ""
},{
    "source file": "outliers_influence.py",
    "line number": "1063",
    "func name": "summary_table",
    "func arg": "(res, alpha)",
    "comments": "Generate summary table of outlier and influence similar to SAS\n\nParameters ---------- alpha : float significance level for confidence interval\n##### Returns\n* **st **: SimpleTable\n   table with results that can be printed\n\n* **data **: ndarray\n   calculated measures and statistics for the table\n\n* **ss2 **: list[str]\n   column_names for table (Note\n\n"
},{
    "source file": "output.py",
    "line number": "239",
    "func name": "_pfixed",
    "func arg": "(s, space, nanRep, float_format)",
    "comments": ""
},{
    "source file": "pandas.py",
    "line number": "136",
    "func name": "to_numpy",
    "func arg": "(po)",
    "comments": "Workaround legacy pandas lacking to_numpy\n\nParameters ---------- po : Pandas obkect\n##### Returns\n"
},{
    "source file": "panel_short.py",
    "line number": "63",
    "func name": "whiten_individuals_loop",
    "func arg": "(x, transform, group_iter)",
    "comments": "apply linear transform for each individual\n\nloop version\n"
},{
    "source file": "panelmod.py",
    "line number": "39",
    "func name": "repanel_cov",
    "func arg": "(groups, sigmas)",
    "comments": "calculate error covariance matrix for random effects model\n\nParameters ---------- groups : ndarray, (nobs, nre) or (nobs,) array of group/category observations sigma : ndarray, (nre+1,) array of standard deviations of random effects, last element is the standard deviation of the idiosyncratic error\n##### Returns\n* **omega **: ndarray, (nobs, nobs)\n    covariance matrix of error\n\n* **omegainv **: ndarray, (nobs, nobs)\n    inverse covariance matrix of error\n\n* **omegainvsqrt **: ndarray, (nobs, nobs)\n    squareroot inverse covariance matrix of error\n    such that omega = omegainvsqrt * omegainvsqrt.T\n\n"
},{
    "source file": "parallel.py",
    "line number": "17",
    "func name": "parallel_func",
    "func arg": "(func, n_jobs, verbose)",
    "comments": "Return parallel instance with delayed function\n\nUtil function to use joblib only if available\n\nParameters ---------- func: callable A function n_jobs: int Number of jobs to run in parallel verbose: int Verbosity level\n##### Returns\n* **parallel**: instance of joblib.Parallel or list\n    The parallel object\n\n* **my_func**: callable\n    func if not parallel or delayed(func)\n\n* **n_jobs**: int\n    Number of jobs >= 0\n\n"
},{
    "source file": "parse_jmulti_var_output.py",
    "line number": "59",
    "func name": "load_results_jmulti",
    "func arg": "(dataset, dt_s_list)",
    "comments": "Parameters ---------- dataset : module A data module in the statsmodels/datasets directory that defines a __str__() method returning the dataset's name. dt_s_list : list A list of strings where each string represents a combination of deterministic terms.\n\n\n##### Returns\n* **result **: dict\n    A dict (keys\n\n"
},{
    "source file": "parse_jmulti_vecm_output.py",
    "line number": "107",
    "func name": "load_results_jmulti",
    "func arg": "(dataset)",
    "comments": "Parameters ---------- dataset : module A data module in the statsmodels/datasets directory that defines a __str__() method returning the dataset's name. dt_s_list : list A list of strings where each string represents a combination of deterministic terms.\n\n\n##### Returns\n* **result **: dict\n    A dict (keys\n\n"
},{
    "source file": "pca_fertility_factors.py",
    "line number": "106",
    "func name": "make_plot",
    "func arg": "(labels)",
    "comments": ""
},{
    "source file": "pca.py",
    "line number": "800",
    "func name": "pca",
    "func arg": "(data, ncomp, standardize, demean, normalize, gls, weights, method)",
    "comments": "Perform Principal Component Analysis (PCA).\n\nParameters ---------- data : ndarray Variables in columns, observations in rows. ncomp : int, optional Number of components to return.\n\nIf None, returns the as many as the smaller to the number of rows or columns of data. standardize : bool, optional Flag indicating to use standardized data with mean 0 and unit variance.\n\nstandardized being True implies demean. demean : bool, optional Flag indicating whether to demean data before computing principal components.\n\ndemean is ignored if standardize is True. normalize : bool , optional Indicates whether th normalize the factors to have unit inner product.\n\nIf False, the loadings will have unit inner product. gls : bool, optional Flag indicating to implement a two-step GLS estimator where in the first step principal components are used to estimate residuals, and then the inverse residual variance is used as a set of weights to estimate the final principal components weights : ndarray, optional Series weights to use after transforming data according to standardize or demean when computing the principal components. method : str, optional Determines the linear algebra routine uses.\n\n'eig', the default, uses an eigenvalue decomposition. 'svd' uses a singular value decomposition.\n##### Returns\n* **factors **: {ndarray, DataFrame}\n    Array (nobs, ncomp)of of principal components (also known as scores).\n\n* **loadings **: {ndarray, DataFrame}\n    Array (ncomp, nvar) of  principal component loadings for constructing\n    the factors.\n\n* **projection **: {ndarray, DataFrame}\n    Array (nobs, nvar) containing the projection of the data onto the ncomp\n    estimated factors.\n\n* **rsquare **: {ndarray, Series}\n    Array (ncomp,) where the element in the ith position is the R-square\n    of including the fist i principal components.  The values are\n    calculated on the transformed data, not the original data.\n\n* **ic **: {ndarray, DataFrame}\n    Array (ncomp, 3) containing the Bai and Ng (2003) Information\n    criteria.  Each column is a different criteria, and each row\n    represents the number of included factors.\n\n* **eigenvals **: {ndarray, Series}\n    Array of eigenvalues (nvar,).\n\n* **eigenvecs **: {ndarray, DataFrame}\n    Array of eigenvectors. (nvar, nvar).\n\n"
},{
    "source file": "penalized.py",
    "line number": "437",
    "func name": "coef_restriction_diffseq",
    "func arg": "(n_coeffs, degree, n_vars, position, base_idx)",
    "comments": ""
},{
    "source file": "plot_grids.py",
    "line number": "41",
    "func name": "scatter_ellipse",
    "func arg": "(data, level, varnames, ell_kwds, plot_kwds, add_titles, keep_ticks, fig)",
    "comments": "Create a grid of scatter plots with confidence ellipses.\n\nell_kwds, plot_kdes not used yet\n\nlooks ok with 5 or 6 variables, too crowded with 8, too empty with 1\n\nParameters ---------- data : array_like Input data. level : scalar, optional Default is 0.9. varnames : list[str], optional Variable names.\n\nUsed for y-axis labels, and if `add_titles` is True also for titles.\n\nIf not given, integers 1..data.shape[1] are used. ell_kwds : dict, optional UNUSED plot_kwds : dict, optional UNUSED add_titles : bool, optional Whether or not to add titles to each subplot.\n\nDefault is False. Titles are constructed from `varnames`. keep_ticks : bool, optional If False (default), remove all axis ticks. fig : Figure, optional If given, this figure is simply returned.\n\nOtherwise a new figure is created.\n##### Returns\n* **..plot **: \n\n"
},{
    "source file": "plots_boxplots.py",
    "line number": "56",
    "func name": "beanplot",
    "func arg": "(data, plot_opts, jitter)",
    "comments": "helper function to try out different plot options\n\n\n"
},{
    "source file": "plots.py",
    "line number": "76",
    "func name": "plot_loadings",
    "func arg": "(loadings, col_names, row_names, loading_pairs, percent_variance, title)",
    "comments": "Plot factor loadings in 2-d plots\n\nParameters ---------- loadings : array like Each column is a component (or factor) col_names : a list of strings column names of `loadings` row_names : a list of strings row names of `loadings` loading_pairs : None or a list of tuples Specify plots. Each tuple (i, j) represent one figure, i and j is the loading number for x-axis and y-axis, respectively. If `None`, all combinations of the loadings will be plotted. percent_variance : array_like The percent variance explained by each factor.\n##### Returns\n* **figs **: a list of figure handles\n\n"
},{
    "source file": "plotting.py",
    "line number": "247",
    "func name": "_get_irf_plot_config",
    "func arg": "(names, impcol, rescol)",
    "comments": ""
},{
    "source file": "plottools.py",
    "line number": "3",
    "func name": "rainbow",
    "func arg": "(n)",
    "comments": "Returns a list of colors sampled at equal intervals over the spectrum.\n\nParameters ---------- n : int The number of colors to return\n##### Returns\n* **R **: (n,3) array\n    An of rows of RGB color values\n\n"
},{
    "source file": "power.py",
    "line number": "224",
    "func name": "ftest_power",
    "func arg": "(effect_size, df_num, df_denom, alpha, ncc)",
    "comments": "Calculate the power of a F-test.\n\nParameters ---------- effect_size : float standardized effect size, mean divided by the standard deviation. effect size has to be positive. df_num : int or float numerator degrees of freedom. df_denom : int or float denominator degrees of freedom. alpha : float in interval (0,1) significance level, e.g. 0.05, is the probability of a type I error, that is wrong rejections if the Null Hypothesis is true. ncc : int degrees of freedom correction for non-centrality parameter. see Notes\n##### Returns\n* **power **: float\n    Power of the test, e.g. 0.8, is one minus the probability of a\n    type II error. Power is the probability that the test correctly\n    rejects the Null Hypothesis if the Alternative Hypothesis is true.\n\n* **ncc=1 matches the non-centrality parameter in R**: \n\n"
},{
    "source file": "predict_functional.py",
    "line number": "383",
    "func name": "_glm_basic_scr",
    "func arg": "(result, exog, alpha)",
    "comments": "The basic SCR from (Sun et al. Annals of Statistics 2000).\n\nComputes simultaneous confidence regions (SCR).\n\nParameters ---------- result : results instance The fitted GLM results instance exog : array_like The exog values spanning the interval alpha : float `1\n\n- alpha` is the coverage probability.\n##### Returns\n"
},{
    "source file": "predstd.py",
    "line number": "27",
    "func name": "wls_prediction_std",
    "func arg": "(res, exog, weights, alpha)",
    "comments": "calculate standard deviation and confidence interval for prediction\n\napplies to WLS and OLS, not to general GLS, that is independently but not identically distributed observations\n\nParameters ---------- res : regression result instance results of WLS or OLS regression required attributes see notes exog : array_like (optional) exogenous variables for points to predict weights : scalar or array_like (optional) weights as defined for WLS (inverse of variance of observation) alpha : float (default: alpha = 0.05) confidence level for two-sided hypothesis\n##### Returns\n* **predstd **: array_like, 1d\n    standard error of prediction\n    same length as rows of exog\n\n* **interval_l, interval_u **: array_like\n    lower und upper confidence bounds\n\n* **res.model.predict() **: predicted values or\n\n* **res.fittedvalues **: values used in estimation\n\n* **res.cov_params() **: covariance matrix of parameter estimates\n\n* **testing status**: not compared with other packages\n\n"
},{
    "source file": "print_version.py",
    "line number": "140",
    "func name": "show_versions",
    "func arg": "(show_dirs)",
    "comments": "List the versions of statsmodels and any installed dependencies\n\nParameters ---------- show_dirs : bool Flag indicating to show module locations\n"
},{
    "source file": "process_regression.py",
    "line number": "170",
    "func name": "_check_args",
    "func arg": "(endog, exog, exog_scale, exog_smooth, exog_noise, time, groups)",
    "comments": ""
},{
    "source file": "proportion.py",
    "line number": "2045",
    "func name": "_confint_riskratio_paired_nam",
    "func arg": "(table, alpha)",
    "comments": "confidence interval for marginal risk ratio for matched pairs\n\nneed full table\n\nsuccess fail\n\nmarginal success\n\n\n\nx11\n\n\n\nx10\n\nx1. fail\n\n\n\n\n\n x01\n\n\n\nx00\n\nx0. marginal\n\n x.1\n\n\n\nx.0\n\n n\n\nThe confidence interval is for the ratio p1 / p0 where p1 = x1. / n and p0\n\n- x.1 / n Todo: rename p1 to pa and p2 to pb, so we have a, b for treatment and 0, 1 for success/failure\n\ncurrent namings follow Nam 2009\n\nstatus testing: compared to example in Nam 2009 internal polynomial coefficients in calculation correspond at around 4 decimals confidence interval agrees only at 2 decimals\n"
},{
    "source file": "python.py",
    "line number": "66",
    "func name": "with_metaclass",
    "func arg": "(meta)",
    "comments": "Create a base class with a metaclass.\n\n\n"
},{
    "source file": "qsturng_.py",
    "line number": "845",
    "func name": "psturng",
    "func arg": "(q, r, v)",
    "comments": "Evaluates the probability from 0 to q for a studentized range having v degrees of freedom and r samples.\n\nParameters ---------- q : (scalar, array_like) quantile value of Studentized Range q >= 0. r : (scalar, array_like) The number of samples r >= 2 and r <= 200 (values over 200 are permitted but not recommended) v : (scalar, array_like) The sample degrees of freedom if p >= .9: v >=1 and v >= inf else: v >=2 and v >= inf\n##### Returns\n* **p **: (scalar, array_like)\n    1. - area from zero to q under the Studentized Range\n    distribution. When v == 1, p is bound between .001\n    and .1, when v > 1, p is bound between .001 and .9.\n    Values between .5 and .9 are 1st order appoximations.\n\n"
},{
    "source file": "quantile_regression.py",
    "line number": "260",
    "func name": "chamberlain",
    "func arg": "(n, q, alpha)",
    "comments": ""
},{
    "source file": "quantile_regression66.py",
    "line number": "59",
    "func name": "fit_model",
    "func arg": "(q)",
    "comments": ""
},{
    "source file": "quantize.py",
    "line number": "88",
    "func name": "prob_quantize_cdf_old",
    "func arg": "(binsx, binsy, cdf)",
    "comments": "quantize a continuous distribution given by a cdf\n\nold version without precomputing cdf values\n\nParameters ---------- binsx : array_like, 1d binedges\n"
},{
    "source file": "rates.py",
    "line number": "272",
    "func name": "tost_poisson_2indep",
    "func arg": "(count1, exposure1, count2, exposure2, low, upp, method)",
    "comments": "Equivalence test based on two one-sided `test_proportions_2indep`\n\nThis assumes that we have two independent binomial samples.\n\nThe Null and alternative hypothesis for equivalence testing are\n\nH0: g1 / g2 <= low or upp <= g1 / g2 H1: low < g1 / g2 < upp\n\nwhere g1 and g2 are the Poisson rates.\n\nParameters ---------- count1: int Number of events in first sample exposure1: float Total exposure (time * subjects) in first sample count2: int Number of events in first sample exposure2: float Total exposure (time * subjects) in first sample low, upp : equivalence margin for the ratio of Poisson rates method: string Method for the test statistic and the p-value. Defaults to `'score'`. Current Methods are based on Gu et. al 2008 Implemented are 'wald', 'score' and 'sqrt' based asymptotic normal distribution, and the exact conditional test 'exact-cond', and its mid-point version 'cond-midp', see Notes\n##### Returns\n* **pvalue **: float\n    p-value is the max of the pvalues of the two one-sided tests\n\n* **t1 **: test results\n    results instance for one-sided hypothesis at the upper margin\n\n* **'wald'**: method W1A, wald test, variance based on separate estimates\n\n* **'score'**: method W2A, score test, variance based on estimate under Null\n\n* **'wald-log'**: W3A  not implemented\n\n* **'sqrt'**: W5A, based on variance stabilizing square root transformation\n\n* **'exact-cond'**: exact conditional test based on binomial distribution\n\n* **'cond-midp'**: midpoint-pvalue of exact conditional test\n\n* **Gu, Ng, Tang, Schucany 2008**: Testing the Ratio of Two Poisson Rates,\n\n"
},{
    "source file": "recursive_ls67.py",
    "line number": "104",
    "func name": "ewma",
    "func arg": "(series, beta, n_window)",
    "comments": ""
},{
    "source file": "regressionplots.py",
    "line number": "1190",
    "func name": "added_variable_resids",
    "func arg": "(results, focus_exog, resid_type, use_glm_weights, fit_kwargs)",
    "comments": "Residualize the endog variable and a 'focus' exog variable in a regression model with respect to the other exog variables.\n\nParameters ---------- results : regression results instance A fitted model including the focus exog and all other predictors of interest. focus_exog : {int, str} The column of results.model.exog or a variable name that is to be residualized against the other predictors. resid_type : str The type of residuals to use for the dependent variable.\n\nIf None, uses `resid_deviance` for GLM/GEE and `resid` otherwise. use_glm_weights : bool Only used if the model is a GLM or GEE.\n\nIf True, the residuals for the focus predictor are computed using WLS, with the weights obtained from the IRLS calculations for fitting the GLM.\n\nIf False, unweighted regression is used. fit_kwargs : dict, optional Keyword arguments to be passed to fit when refitting the model.\n##### Returns\n* **endog_resid **: array_like\n    The residuals for the original exog\n\n* **focus_exog_resid **: array_like\n    The residuals for the focus predictor\n\n"
},{
    "source file": "regularized_covariance.py",
    "line number": "89",
    "func name": "_calc_approx_inv_cov",
    "func arg": "(nodewise_row_l, nodewise_weight_l)",
    "comments": "calculates the approximate inverse covariance matrix\n\nParameters ---------- nodewise_row_l : list A list of array-like object where each object corresponds to the nodewise_row values for the corresponding variable, should be length p. nodewise_weight_l : list A list of scalars where each scalar corresponds to the nodewise_weight value for the corresponding variable, should be length p.\n##### Returns\n"
},{
    "source file": "results_rlm.py",
    "line number": "6",
    "func name": "_shift_intercept",
    "func arg": "(arr)",
    "comments": "A convenience function to make the SAS covariance matrix compatible with statsmodels.rlm covariance\n\n\n"
},{
    "source file": "robust_compare.py",
    "line number": "237",
    "func name": "scale_transform",
    "func arg": "(data, center, transform, trim_frac, axis)",
    "comments": "Transform data for variance comparison for Levene type tests\n\nParameters ---------- data : array_like observations for the data center : str in ['median', 'mean', 'trimmed'] the statistic that is used as center for the data transformation transform : 'abs', 'square', 'identity' or a callable the transform for the centered data trim_frac : float in [0, 0.5) Fraction of observations that are trimmed on each side of the sorted observations. This is only used if center is `trimmed`. axis : int axis along which the data are transformed when centering.\n##### Returns\n* **res **: ndarray\n    transformed data in the same shape as the original data.\n\n"
},{
    "source file": "robust_linear_model.py",
    "line number": "31",
    "func name": "_check_convergence",
    "func arg": "(criterion, iteration, tol, maxiter)",
    "comments": ""
},{
    "source file": "robust_models_1.py",
    "line number": "37",
    "func name": "plot_weights",
    "func arg": "(support, weights_func, xlabels, xticks)",
    "comments": ""
},{
    "source file": "rolling.py",
    "line number": "28",
    "func name": "strip4",
    "func arg": "(line)",
    "comments": ""
},{
    "source file": "rootfinding.py",
    "line number": "20",
    "func name": "brentq_expanding",
    "func arg": "(func, low, upp, args, xtol, start_low, start_upp, increasing, max_it, maxiter_bq, factor, full_output)",
    "comments": "find the root of a function in one variable by expanding and brentq\n\nAssumes function ``func`` is monotonic.\n\nParameters ---------- func : callable function for which we find the root ``x`` such that ``func(x) = 0`` low : float or None lower bound for brentq upp : float or None upper bound for brentq args : tuple optional additional arguments for ``func`` xtol : float parameter x tolerance given to brentq start_low : float (positive) or None starting bound for expansion with increasing ``x``. It needs to be positive. If None, then it is set to 1. start_upp : float (negative) or None starting bound for expansion with decreasing ``x``. It needs to be negative. If None, then it is set to -1. increasing : bool or None If None, then the function is evaluated at the initial bounds to determine wether the function is increasing or not. If increasing is True (False), then it is assumed that the function is monotonically increasing (decreasing). max_it : int maximum number of expansion steps. maxiter_bq : int maximum number of iterations of brentq. factor : float expansion factor for step of shifting the bounds interval, default is 10. full_output : bool, optional If full_output is False, the root is returned. If full_output is True, the return value is (x, r), where x is the root, and r is a RootResults object.\n##### Returns\n* **x **: float\n    root of the function, value at which ``func(x) = 0``.\n\n* **info **: RootResult (optional)\n    returned if ``full_output`` is True.\n    attributes\n\n"
},{
    "source file": "ros.py",
    "line number": "476",
    "func name": "impute_ros",
    "func arg": "(observations, censorship, df, min_uncensored, max_fraction_censored, substitution_fraction, transform_in, transform_out, as_array)",
    "comments": "Impute censored dataset using Regression on Order Statistics (ROS).\n\nMethod described in *Nondetects and Data Analysis* by Dennis R. Helsel (John Wiley, 2005) to estimate the left-censored (non-detect) values of a dataset. When there is insufficient non-censorded data, simple substitution is used.\n\nParameters ---------- observations : str or array-like Label of the column or the float array of censored observations\n\ncensorship : str Label of the column or the bool array of the censorship status of the observations.\n\n* True if censored, * False if uncensored\n\ndf : pandas.DataFrame, optional If `observations` and `censorship` are labels, this is the DataFrame that contains those columns.\n\nmin_uncensored : int (default is 2) The minimum number of uncensored values required before ROS can be used to impute the censored observations. When this criterion is not met, simple substituion is used instead.\n\nmax_fraction_censored : float (default is 0.8) The maximum fraction of censored data below which ROS can be used to impute the censored observations. When this fraction is exceeded, simple substituion is used instead.\n\nsubstitution_fraction : float (default is 0.5) The fraction of the detection limit to be used during simple substitution of the censored values.\n\ntransform_in : callable (default is numpy.log) Transformation to be applied to the values prior to fitting a line to the plotting positions vs. uncensored values.\n\ntransform_out : callable (default is numpy.exp) Transformation to be applied to the imputed censored values estimated from the previously computed best-fit line.\n\nas_array : bool (default is True) When True, a numpy array of the imputed observations is returned. Otherwise, a modified copy of the original dataframe with all of the intermediate calculations is returned.\n##### Returns\n* **imputed **: numpy.array (default) or pandas.DataFrame\n    The final observations where the censored values have either been\n    imputed through ROS or substituted as a fraction of the\n    detection limit.\n\n"
},{
    "source file": "run_all.py",
    "line number": "39",
    "func name": "noop",
    "func arg": "()",
    "comments": ""
},{
    "source file": "run_all68.py",
    "line number": "10",
    "func name": "no_show",
    "func arg": "()",
    "comments": ""
},{
    "source file": "runs.py",
    "line number": "564",
    "func name": "symmetry_bowker",
    "func arg": "(table)",
    "comments": "Test for symmetry of a (k, k) square contingency table\n\nThis is an extension of the McNemar test to test the Null hypothesis that the contingency table is symmetric around the main diagonal, that is\n\nn_{i, j} = n_{j, i}\n\nfor all i, j\n\nParameters ---------- table : array_like, 2d, (k, k) a square contingency table that contains the count for k categories in rows and columns.\n##### Returns\n* **statistic **: float\n    chisquare test statistic\n\n* **p-value **: float\n    p-value of the test statistic based on chisquare distribution\n\n* **df **: int\n    degrees of freedom of the chisquare distribution\n\n"
},{
    "source file": "sandwich_covariance_generic.py",
    "line number": "118",
    "func name": "S_white",
    "func arg": "(x, d)",
    "comments": "simple white heteroscedasticity robust covariance note: calculating this way is very inefficient, just for cross-checking\n\n\n"
},{
    "source file": "sandwich_covariance.py",
    "line number": "801",
    "func name": "cov_nw_groupsum",
    "func arg": "(results, nlags, time, weights_func, use_correction)",
    "comments": "Driscoll and Kraay Panel robust covariance matrix\n\nRobust covariance matrix for panel data of Driscoll and Kraay.\n\nAssumes we have a panel of time series where the time index is available. The time index is assumed to represent equal spaced periods. At least one observation per period is required.\n\nParameters ---------- results : result instance result of a regression, uses results.model.exog and results.resid TODO: this should use wexog instead nlags : int or None Highest lag to include in kernel window. Currently, no default because the optimal length will depend on the number of observations per cross-sectional unit. time : ndarray of int this should contain the coding for the time period of each observation. time periods should be integers in range(maxT) where maxT is obs of i weights_func : callable weights_func is called with nlags as argument to get the kernel weights. default are Bartlett weights use_correction : 'cluster' or 'hac' or False If False, then no small sample correction is used. If 'hac' (default), then the same correction as in single time series, cov_hac is used. If 'cluster', then the same correction as in cov_cluster is used.\n##### Returns\n* **cov **: ndarray, (k_vars, k_vars)\n    HAC robust covariance matrix for parameter estimates\n\n* **Warning**: \n\n"
},{
    "source file": "scale.py",
    "line number": "18",
    "func name": "mad",
    "func arg": "(a, c, axis, center)",
    "comments": "The Median Absolute Deviation along given axis of an array\n\nParameters ---------- a : array_like Input array. c : float, optional The normalization constant.\n\nDefined as scipy.stats.norm.ppf(3/4.), which is approximately .6745. axis : int, optional The default is 0. Can also be None. center : callable or float If a callable is provided, such as the default `np.median` then it is expected to be called center(a). The axis argument will be applied via np.apply_over_axes. Otherwise, provide a float.\n##### Returns\n* **mad **: float\n    `mad` = median(abs(`a` - center))/`c`\n\n"
},{
    "source file": "scipy.py",
    "line number": "71",
    "func name": "_lazywhere",
    "func arg": "(cond, arrays, f, fillvalue, f2)",
    "comments": "np.where(cond, x, fillvalue) always evaluates x even where cond is False. This one only evaluates f(arr1[cond], arr2[cond], ...). For example, >>> a, b = np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8]) >>> def f(a, b): return a*b >>> _lazywhere(a > 2, (a, b), f, np.nan) array([ nan,  nan,  21.,  32.]) Notice it assumes that all `arrays` are of the same shape, or can be broadcasted together.\n\n\n"
},{
    "source file": "seasonal.py",
    "line number": "60",
    "func name": "seasonal_decompose",
    "func arg": "(x, model, filt, period, two_sided, extrapolate_trend)",
    "comments": "Seasonal decomposition using moving averages.\n\nParameters ---------- x : array_like Time series. If 2d, individual series are in columns. x must contain 2 complete cycles. model : {\"additive\", \"multiplicative\"}, optional Type of seasonal component. Abbreviations are accepted. filt : array_like, optional The filter coefficients for filtering out the seasonal component. The concrete moving average method used in filtering is determined by two_sided. period : int, optional Period of the series. Must be used if x is not a pandas object or if the index of x does not have\n\na frequency. Overrides default periodicity of x if x is a pandas object with a timeseries index. two_sided : bool, optional The moving average method used in filtering. If True (default), a centered moving average is computed using the filt. If False, the filter coefficients are for past values only. extrapolate_trend : int or 'freq', optional If set to > 0, the trend resulting from the convolution is linear least-squares extrapolated on both ends (or the single one if two_sided is False) considering this many (+1) closest points. If set to 'freq', use `freq` closest points. Setting this parameter results in no NaN values in trend or resid components.\n##### Returns\n"
},{
    "source file": "sequences.py",
    "line number": "154",
    "func name": "halton",
    "func arg": "(dim, n_sample, bounds, start_index)",
    "comments": "Halton sequence.\n\nPseudo-random number generator that generalize the Van der Corput sequence for multiple dimensions. Halton sequence use base-two Van der Corput sequence for the first dimension, base-three for its second and base-n for its n-dimension.\n\nParameters ---------- dim : int Dimension of the parameter space. n_sample : int Number of samples to generate in the parametr space. bounds : tuple or array_like ([min, k_vars], [max, k_vars]) Desired range of transformed data. The transformation apply the bounds on the sample and not the theoretical space, unit cube. Thus min and max values of the sample will coincide with the bounds. start_index : int Index to start the sequence from.\n##### Returns\n* **sequence **: array_like (n_samples, k_vars)\n    Sequence of Halton.\n\n"
},{
    "source file": "setup.py",
    "line number": "247",
    "func name": "process_tempita",
    "func arg": "(source_name)",
    "comments": "Runs pyx.in files through tempita is needed\n\n\n"
},{
    "source file": "smooth_basis.py",
    "line number": "261",
    "func name": "make_poly_basis",
    "func arg": "(x, degree, intercept)",
    "comments": "given a vector x returns poly=(1, x, x^2, ..., x^degree) and its first and second derivative\n\n\n"
},{
    "source file": "smoothers_lowess_old.py",
    "line number": "336",
    "func name": "_lowess_bisquare",
    "func arg": "(t)",
    "comments": "The bisquare function applied to a numpy array. The bisquare function is (1-t**2)**2.\n\nParameters ---------- t : ndarray array bisquare function is applied to, element-wise and in-place.\n##### Returns\n"
},{
    "source file": "smoothers_lowess.py",
    "line number": "13",
    "func name": "lowess",
    "func arg": "(endog, exog, frac, it, delta, is_sorted, missing, return_sorted)",
    "comments": "LOWESS (Locally Weighted Scatterplot Smoothing)\n\nA lowess function that outs smoothed estimates of endog at the given exog values from points (exog, endog)\n\nParameters ---------- endog : 1-D numpy array The y-values of the observed points exog : 1-D numpy array The x-values of the observed points frac : float Between 0 and 1. The fraction of the data used when estimating each y-value. it : int The number of residual-based reweightings to perform. delta : float Distance within which to use linear-interpolation instead of weighted regression. is_sorted : bool If False (default), then the data will be sorted by exog before calculating lowess. If True, then it is assumed that the data is already sorted by exog. missing : str Available options are 'none', 'drop', and 'raise'. If 'none', no nan checking is done. If 'drop', any observations with nans are dropped. If 'raise', an error is raised. Default is 'drop'. return_sorted : bool If True (default), then the returned array is sorted by exog and has missing (nan or infinite) observations removed. If False, then the returned array is in the same length and the same sequence of observations as the input array.\n##### Returns\n* **out**: ndarray, float\n    The returned array is two-dimensional if return_sorted is True, and\n    one dimensional if return_sorted is False.\n    If return_sorted is True, then a numpy array with two columns. The\n    first column contains the sorted x (exog) values and the second column\n    the associated estimated y (endog) values.\n    If return_sorted is False, then only the fitted values are returned,\n    and the observations will be in the same order as the input arrays.\n\n* **Association 74 (368)**: 829-836.\n\n"
},{
    "source file": "smpickle.py",
    "line number": "20",
    "func name": "load_pickle",
    "func arg": "(fname)",
    "comments": "Load a previously saved object\n\n.. warning::\n\nLoading pickled models is not secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.\n\nParameters ---------- fname : str Filename to unpickle\n\nNotes ----- This method can be used to load *both* models and results.\n"
},{
    "source file": "sppatch.py",
    "line number": "606",
    "func name": "printresults",
    "func arg": "(sample, arg, bres, kind)",
    "comments": "calculate and print(Bootstrap or Monte Carlo result\n\nParameters ---------- sample : ndarray original sample data arg : float\n\n (for general case will be array) bres : ndarray parameter estimates from Bootstrap or Monte Carlo run kind : {'bootstrap', 'montecarlo'} output is printed for Mootstrap (default) or Monte Carlo\n##### Returns\n* **made correction**: reference point for bootstrap is estimated parameter\n\n* **not clear**: I'm not doing any ddof adjustment in estimation of variance, do we\n    need ddof>0 ?\n\n* **todo**: return results and string instead of printing\n\n"
},{
    "source file": "statespace_arma_0.py",
    "line number": "94",
    "func name": "mean_forecast_err",
    "func arg": "(y, yhat)",
    "comments": ""
},{
    "source file": "statespace_dfm_coincident.py",
    "line number": "315",
    "func name": "compute_coincident_index",
    "func arg": "(mod, res)",
    "comments": ""
},{
    "source file": "statespace_seasonal.py",
    "line number": "48",
    "func name": "simulate_seasonal_term",
    "func arg": "(periodicity, total_cycles, noise_std, harmonics)",
    "comments": ""
},{
    "source file": "statespace.py",
    "line number": "16",
    "func name": "statespace",
    "func arg": "(endog, exog, order, seasonal_order, include_constant, enforce_stationarity, enforce_invertibility, concentrate_scale, start_params, fit_kwargs)",
    "comments": "Estimate SARIMAX parameters using state space methods.\n\nParameters ---------- endog : array_like Input time series array. order : tuple, optional The (p,d,q) order of the model for the number of AR parameters, differences, and MA parameters. Default is (0, 0, 0). seasonal_order : tuple, optional The (P,D,Q,s) order of the seasonal component of the model for the AR parameters, differences, MA parameters, and periodicity. Default is (0, 0, 0, 0). include_constant : bool, optional Whether to add a constant term in `exog` if it's not already there. The estimate of the constant will then appear as one of the `exog` parameters. If `exog` is None, then the constant will represent the mean of the process. enforce_stationarity : bool, optional Whether or not to transform the AR parameters to enforce stationarity in the autoregressive component of the model. Default is True. enforce_invertibility : bool, optional Whether or not to transform the MA parameters to enforce invertibility in the moving average component of the model. Default is True. concentrate_scale : bool, optional Whether or not to concentrate the scale (variance of the error term) out of the likelihood. This reduces the number of parameters estimated by maximum likelihood by one. start_params : array_like, optional Initial guess of the solution for the loglikelihood maximization. The AR polynomial must be stationary. If `enforce_invertibility=True` the MA poylnomial must be invertible. If not provided, default starting parameters are computed using the Hannan-Rissanen method. fit_kwargs : dict, optional Arguments to pass to the state space model's `fit` method.\n##### Returns\n* **parameters **: SARIMAXParams object\n\n* **other_results **: Bunch\n    Includes two components, `spec`, containing the `SARIMAXSpecification`\n    instance corresponding to the input arguments; and\n    `state_space_results`, corresponding to the results from the underlying\n    state space model and Kalman filter / smoother.\n\n* **.. [1] Durbin, James, and Siem Jan Koopman. 2012.\n   Time Series Analysis by State Space Methods**: Second Edition.\n   Oxford University Press.\n\n"
},{
    "source file": "stats_dhuard.py",
    "line number": "118",
    "func name": "empiricalcdf",
    "func arg": "(data, method)",
    "comments": "Return the empirical cdf.\n\nMethods available: Hazen:\n\n\n\n\n\n (i-0.5)/N Weibull:\n\n\n\n i/(N+1) Chegodayev:\n\n(i-.3)/(N+.4) Cunnane:\n\n\n\n (i-.4)/(N+.2) Gringorten:\n\n(i-.44)/(N+.12) California:\n\n(i-1)/N\n\nWhere i goes from 1 to N.\n"
},{
    "source file": "stats_mstats_short.py",
    "line number": "311",
    "func name": "edf_normal_inverse_transformed",
    "func arg": "(x, alpha, beta, axis)",
    "comments": "rank based normal inverse transformed cdf\n\n\n"
},{
    "source file": "stattools.py",
    "line number": "1907",
    "func name": "_kpss_autolag",
    "func arg": "(resids, nobs)",
    "comments": "Computes the number of lags for covariance matrix estimation in KPSS test using method of Hobijn et al (1998). See also Andrews (1991), Newey & West (1994), and Schwert (1989). Assumes Bartlett / Newey-West kernel.\n\n\n"
},{
    "source file": "stattools70.py",
    "line number": "442",
    "func name": "medcouple",
    "func arg": "(y, axis)",
    "comments": "Calculate the medcouple robust measure of skew.\n\nParameters ---------- y : array_like Data to compute use in the estimator. axis : {int, None} Axis along which the medcouple statistic is computed.\n\nIf `None`, the entire array is used.\n##### Returns\n* **mc **: ndarray\n    The medcouple statistic with the same shape as `y`, with the specified\n    axis removed.\n\n"
},{
    "source file": "summary.py",
    "line number": "708",
    "func name": "summary_return",
    "func arg": "(tables, return_fmt)",
    "comments": ""
},{
    "source file": "summary2.py",
    "line number": "593",
    "func name": "_simple_tables",
    "func arg": "(tables, settings, pad_col, pad_index)",
    "comments": ""
},{
    "source file": "survfunc.py",
    "line number": "739",
    "func name": "plot_survfunc",
    "func arg": "(survfuncs, ax)",
    "comments": "Plot one or more survivor functions.\n\nParameters ---------- survfuncs : object or array_like A single SurvfuncRight object, or a list or SurvfuncRight objects that are plotted together.\n##### Returns\n* **Add a legend**: \n\n* **>>> df = data.loc[data.sex == \"F\", **: ]\n\n* **Change the line colors**: \n\n"
},{
    "source file": "svar_model.py",
    "line number": "25",
    "func name": "svar_ckerr",
    "func arg": "(svar_type, A, B)",
    "comments": ""
},{
    "source file": "sympy_diff.py",
    "line number": "15",
    "func name": "cdf",
    "func arg": "(x, mu, sigma)",
    "comments": "Return the cumulative density function as an expression in x\n\n\n"
},{
    "source file": "table.py",
    "line number": "913",
    "func name": "get_output_format",
    "func arg": "(output_format)",
    "comments": ""
},{
    "source file": "template_data.py",
    "line number": "61",
    "func name": "_get_data",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_adfuller_lag.py",
    "line number": "14",
    "func name": "test_adf_autolag",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_agreement.py",
    "line number": "15",
    "func name": "test_mean_diff_plot",
    "func arg": "(close_figures)",
    "comments": ""
},{
    "source file": "test_anova_rm.py",
    "line number": "182",
    "func name": "test_repeated_measures_aggregate_compare_with_ezANOVA",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_ar.py",
    "line number": "1269",
    "func name": "test_autoreg_forecast_period_index",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_arima_process.py",
    "line number": "210",
    "func name": "test_lpol2index_index2lpol",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_arima.py",
    "line number": "2742",
    "func name": "test_arma_exog_const_trend_nc",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_arma_innovations.py",
    "line number": "48",
    "func name": "test_innovations_nonstationary",
    "func arg": "(ar_params)",
    "comments": ""
},{
    "source file": "test_base.py",
    "line number": "33",
    "func name": "test_holdertuple2",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_base72.py",
    "line number": "102",
    "func name": "test_get_predict_start_end",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_bayes_mi.py",
    "line number": "141",
    "func name": "test_mi_formula",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_bayes_mixed_glm.py",
    "line number": "579",
    "func name": "test_doc_examples",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_boxplots.py",
    "line number": "102",
    "func name": "test_beanplot_legend_text",
    "func arg": "(age_and_labels, close_figures)",
    "comments": ""
},{
    "source file": "test_burg.py",
    "line number": "102",
    "func name": "test_misc",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_cancorr.py",
    "line number": "29",
    "func name": "test_cancorr",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_catadd.py",
    "line number": "8",
    "func name": "test_add_indep",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_cfa_simulation_smoothing.py",
    "line number": "183",
    "func name": "test_dfm",
    "func arg": "(missing)",
    "comments": ""
},{
    "source file": "test_cfa_tvpvar.py",
    "line number": "107",
    "func name": "test_tvpvar",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_chandrasekhar.py",
    "line number": "189",
    "func name": "test_invalid",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_coint.py",
    "line number": "151",
    "func name": "test_coint_johansen_0lag",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_collapsed.py",
    "line number": "742",
    "func name": "test_dfm_missing",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_concentrated.py",
    "line number": "283",
    "func name": "test_concentrated_scale_univariate",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_conditional.py",
    "line number": "300",
    "func name": "test_conditional_mnlogit_3d",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_conserve_memory.py",
    "line number": "325",
    "func name": "test_invalid_fittedvalues_resid_predict",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_constrained73.py",
    "line number": "523",
    "func name": "junk",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_contingency_tables.py",
    "line number": "259",
    "func name": "test_cochranq",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_contrast.py",
    "line number": "42",
    "func name": "test_constraints",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_correlation.py",
    "line number": "7",
    "func name": "test_kernel_covariance",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_correlation74.py",
    "line number": "21",
    "func name": "test_plot_corr_grid",
    "func arg": "(close_figures)",
    "comments": ""
},{
    "source file": "test_corrpsd.py",
    "line number": "191",
    "func name": "test_corrpsd_threshold",
    "func arg": "(threshold)",
    "comments": ""
},{
    "source file": "test_cov.py",
    "line number": "11",
    "func name": "test_HC_use",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_cython_arma_innovations_fast.py",
    "line number": "334",
    "func name": "test_regression_with_arma_errors",
    "func arg": "(ar_params, ma_params, sigma2)",
    "comments": ""
},{
    "source file": "test_data.py",
    "line number": "937",
    "func name": "test_raise_nonfinite_exog",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_data75.py",
    "line number": "20",
    "func name": "test_dataset",
    "func arg": "(dataset_name)",
    "comments": ""
},{
    "source file": "test_data76.py",
    "line number": "47",
    "func name": "test_patsy_577",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_datetools.py",
    "line number": "31",
    "func name": "test_dates_from_range",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_decorators.py",
    "line number": "51",
    "func name": "test_deprecated_alias",
    "func arg": "(msg, remove_version, warning)",
    "comments": ""
},{
    "source file": "test_denton.py",
    "line number": "16",
    "func name": "test_denton_quarterly2",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_descriptivestats.py",
    "line number": "5",
    "func name": "test_sign_test",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_deterministic.py",
    "line number": "666",
    "func name": "test_drop",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_diagnostic.py",
    "line number": "1257",
    "func name": "test_small_skip",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_dimred.py",
    "line number": "171",
    "func name": "test_covreduce",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_discrete78.py",
    "line number": "2389",
    "func name": "test_t_test",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_distributed_estimation.py",
    "line number": "440",
    "func name": "test_debiased_v_average",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_docstring.py",
    "line number": "173",
    "func name": "test_multiple_sig",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_dotplot.py",
    "line number": "22",
    "func name": "test_all",
    "func arg": "(close_figures, reset_randomstate)",
    "comments": ""
},{
    "source file": "test_durbin_levinson.py",
    "line number": "93",
    "func name": "test_misc",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_dynamic_factor.py",
    "line number": "977",
    "func name": "test_start_params_nans",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_edgeworth.py",
    "line number": "179",
    "func name": "check_distribution_rvs",
    "func arg": "(distfn, args, alpha, rvs)",
    "comments": ""
},{
    "source file": "test_eval_measures.py",
    "line number": "106",
    "func name": "test_iqr_axis",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_exact_diffuse_filtering.py",
    "line number": "1002",
    "func name": "test_nondiagonal_obs_cov",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_exponential_smoothing.py",
    "line number": "882",
    "func name": "test_parameterless_model",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_exponential_smoothing79.py",
    "line number": "616",
    "func name": "test_convergence_simple",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_extras.py",
    "line number": "51",
    "func name": "test_skewt",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_factor.py",
    "line number": "255",
    "func name": "test_factor_scoring",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_filters.py",
    "line number": "762",
    "func name": "test_pandas_freq_decorator",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_fixed_params.py",
    "line number": "596",
    "func name": "test_score_shape",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_forecasting.py",
    "line number": "15",
    "func name": "test_append_multistep",
    "func arg": "(data)",
    "comments": ""
},{
    "source file": "test_foreign.py",
    "line number": "208",
    "func name": "test_datetime_roundtrip",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_formula.py",
    "line number": "238",
    "func name": "test_formula_predict_series_exog",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_functional.py",
    "line number": "212",
    "func name": "test_fboxplot_rainbowplot",
    "func arg": "(close_figures)",
    "comments": ""
},{
    "source file": "test_gam80.py",
    "line number": "774",
    "func name": "test_cov_params",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_gee.py",
    "line number": "2013",
    "func name": "test_grid_ar",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_generic_methods.py",
    "line number": "529",
    "func name": "compare_waldres",
    "func arg": "(res, wa, constrasts)",
    "comments": ""
},{
    "source file": "test_glm_weights.py",
    "line number": "882",
    "func name": "test_poisson_residuals",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_glm.py",
    "line number": "2333",
    "func name": "test_int_exog",
    "func arg": "(dtype)",
    "comments": ""
},{
    "source file": "test_gls.py",
    "line number": "191",
    "func name": "test_arma_kwargs",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_glsar_gretl.py",
    "line number": "412",
    "func name": "test_GLSARlag",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_gmm_poisson.py",
    "line number": "58",
    "func name": "moment_exponential_mult",
    "func arg": "(params, data, exp)",
    "comments": ""
},{
    "source file": "test_gmm.py",
    "line number": "808",
    "func name": "test_gmm_basic",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_gof_new.py",
    "line number": "7",
    "func name": "test_loop_vectorized_batch_equivalence",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_gof.py",
    "line number": "80",
    "func name": "test_chisquare_effectsize",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_gofplots.py",
    "line number": "233",
    "func name": "test_invalid_dist_config",
    "func arg": "(close_figures)",
    "comments": ""
},{
    "source file": "test_grouputils.py",
    "line number": "305",
    "func name": "test_dummy_sparse",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_hannan_rissanen.py",
    "line number": "97",
    "func name": "test_unbiased_error",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_holtwinters.py",
    "line number": "885",
    "func name": "test_forecast_index",
    "func arg": "(ix)",
    "comments": ""
},{
    "source file": "test_impulse_responses.py",
    "line number": "678",
    "func name": "test_pandas_anchor",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_influence.py",
    "line number": "108",
    "func name": "_check_looo",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_initialization.py",
    "line number": "368",
    "func name": "test_invalid",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_innovations.py",
    "line number": "312",
    "func name": "test_innovations_mle_invalid",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_inter_rater.py",
    "line number": "348",
    "func name": "test_aggregate_raters",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_itercompat.py",
    "line number": "30",
    "func name": "test_combinations",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_kalman.py",
    "line number": "797",
    "func name": "test_stationary_initialization",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_kde.py",
    "line number": "336",
    "func name": "test_kde_bw_positive",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_kernel_density.py",
    "line number": "422",
    "func name": "test_all_kernels",
    "func arg": "(kernel, reset_randomstate)",
    "comments": ""
},{
    "source file": "test_kernel_regression.py",
    "line number": "383",
    "func name": "test_invalid_kernel",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_knockoff.py",
    "line number": "96",
    "func name": "test_sim",
    "func arg": "(method, tester, n, p, es)",
    "comments": ""
},{
    "source file": "test_lilliefors.py",
    "line number": "95",
    "func name": "test_ksstat",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_linalg.py",
    "line number": "17",
    "func name": "test_stationary_solve_2d",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_link.py",
    "line number": "104",
    "func name": "test_invlogit_stability",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_lme.py",
    "line number": "1238",
    "func name": "test_get_distribution",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_lowess.py",
    "line number": "151",
    "func name": "test_returns_inputs",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_manova.py",
    "line number": "170",
    "func name": "test_endog_1D_array",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_markov_autoregression.py",
    "line number": "170",
    "func name": "test_conditional_loglikelihoods",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_markov_regression.py",
    "line number": "1278",
    "func name": "test_exog_tvtp",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_markov_switching.py",
    "line number": "254",
    "func name": "test_partials_logistic",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_mediation.py",
    "line number": "217",
    "func name": "test_surv",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_mice.py",
    "line number": "375",
    "func name": "test_micedata_miss1",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_ml_factor.py",
    "line number": "146",
    "func name": "test_2factor",
    "func arg": "()",
    "comments": "# R code: r = 0.4 p = 6 ii = seq(0, p-1) ii = outer(ii, ii, \"-\") ii = abs(ii) cm = r^ii factanal(covmat=cm, factors=2)\n\n\n"
},{
    "source file": "test_mlemodel.py",
    "line number": "1183",
    "func name": "test_states_index_rangeindex",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_model.py",
    "line number": "290",
    "func name": "test_nonstationary_gls_error",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_models.py",
    "line number": "228",
    "func name": "test_large_kposdef",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_moment_helpers.py",
    "line number": "111",
    "func name": "test_moment_conversion_types",
    "func arg": "(func_name)",
    "comments": ""
},{
    "source file": "test_mosaicplot.py",
    "line number": "433",
    "func name": "test_missing_category",
    "func arg": "(close_figures)",
    "comments": ""
},{
    "source file": "test_multi.py",
    "line number": "435",
    "func name": "test_null_constrained",
    "func arg": "(estimate_mean, estimate_scale, estimate_prob)",
    "comments": ""
},{
    "source file": "test_multicomp.py",
    "line number": "10",
    "func name": "test_tukey_pvalues",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_multivariate_ols.py",
    "line number": "179",
    "func name": "test_affine_hypothesis",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_multivariate_switch_univariate.py",
    "line number": "436",
    "func name": "test_time_varying_model",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_multivariate.py",
    "line number": "278",
    "func name": "test_cov_oneway",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_news.py",
    "line number": "1019",
    "func name": "test_invalid",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_nonparametric.py",
    "line number": "255",
    "func name": "test_runstest_2sample",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_notebooks.py",
    "line number": "53",
    "func name": "test_notebook",
    "func arg": "(notebook)",
    "comments": ""
},{
    "source file": "test_numdiff.py",
    "line number": "297",
    "func name": "test_dtypes",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_oneway.py",
    "line number": "513",
    "func name": "test_simulate_equivalence",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_optimize.py",
    "line number": "124",
    "func name": "test_minimize_scipy_slsqp",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_outliers_influence.py",
    "line number": "11",
    "func name": "test_reset_stata",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_package.py",
    "line number": "23",
    "func name": "test_docstring_optimization_compat",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_pairwise.py",
    "line number": "157",
    "func name": "get_thsd",
    "func arg": "(mci, alpha)",
    "comments": ""
},{
    "source file": "test_panel_robustcov.py",
    "line number": "19",
    "func name": "test_panel_robust_cov",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_parallel.py",
    "line number": "6",
    "func name": "test_parallel",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_params.py",
    "line number": "526",
    "func name": "test_repr_str",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_pca.py",
    "line number": "432",
    "func name": "test_gls_warning",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_pca82.py",
    "line number": "49",
    "func name": "test_pca_svd",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_phreg.py",
    "line number": "415",
    "func name": "test_r",
    "func arg": "(fname, ties, entry_f, strata_f)",
    "comments": ""
},{
    "source file": "test_pickle.py",
    "line number": "136",
    "func name": "test_representation_pickle",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_pickle84.py",
    "line number": "11",
    "func name": "test_pickle",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_power.py",
    "line number": "743",
    "func name": "test_power_solver_warn",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_predict_functional.py",
    "line number": "15",
    "func name": "pctl",
    "func arg": "(q)",
    "comments": ""
},{
    "source file": "test_predict85.py",
    "line number": "17",
    "func name": "test_predict_se",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_prediction.py",
    "line number": "61",
    "func name": "test_memory_no_predicted",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_processreg.py",
    "line number": "183",
    "func name": "test_score_numdiff",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_proportion.py",
    "line number": "862",
    "func name": "test_power_2indep",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_qif.py",
    "line number": "91",
    "func name": "test_formula",
    "func arg": "(cov_struct)",
    "comments": ""
},{
    "source file": "test_qsturng.py",
    "line number": "19",
    "func name": "test_qstrung",
    "func arg": "(alpha, k)",
    "comments": ""
},{
    "source file": "test_qsturng86.py",
    "line number": "21",
    "func name": "read_ch",
    "func arg": "(fname)",
    "comments": ""
},{
    "source file": "test_quantile_regression.py",
    "line number": "276",
    "func name": "test_alpha_summary",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_random_panel.py",
    "line number": "27",
    "func name": "test_short_panel",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_rates_poisson.py",
    "line number": "241",
    "func name": "test_alternative",
    "func arg": "(case)",
    "comments": ""
},{
    "source file": "test_recursive_ls.py",
    "line number": "477",
    "func name": "test_fix_params",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_regression.py",
    "line number": "1402",
    "func name": "test_summary_no_constant",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_regressionplots.py",
    "line number": "26",
    "func name": "close_or_save",
    "func arg": "(pdf, fig)",
    "comments": ""
},{
    "source file": "test_regularized_covariance.py",
    "line number": "40",
    "func name": "test_fit",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_representation.py",
    "line number": "1320",
    "func name": "test_missing",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_rlm.py",
    "line number": "369",
    "func name": "test_bad_criterion",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_robustcov.py",
    "line number": "887",
    "func name": "test_cov_type_fixed_scale",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_rolling.py",
    "line number": "294",
    "func name": "test_expanding",
    "func arg": "(basic_data)",
    "comments": ""
},{
    "source file": "test_rootfinding.py",
    "line number": "32",
    "func name": "test_brentq_expanding",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_ros.py",
    "line number": "340",
    "func name": "test__do_ros",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_sandwich.py",
    "line number": "55",
    "func name": "test_hac_simple",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_sarimax.py",
    "line number": "2696",
    "func name": "test_invalid_seasonal_order",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_save.py",
    "line number": "140",
    "func name": "test_existing_pickle",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_scipy_compat.py",
    "line number": "5",
    "func name": "test_next_regular",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_screening.py",
    "line number": "312",
    "func name": "test_glmgaussian_screening",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_seasonal.py",
    "line number": "316",
    "func name": "test_seasonal_decompose_plot",
    "func arg": "(model, freq, two_sided, extrapolate_trend)",
    "comments": ""
},{
    "source file": "test_sequences.py",
    "line number": "36",
    "func name": "test_halton",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_shrink_pickle.py",
    "line number": "25",
    "func name": "check_pickle",
    "func arg": "(obj)",
    "comments": ""
},{
    "source file": "test_simulate.py",
    "line number": "1780",
    "func name": "test_time_varying_selection",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_simulation_smoothing.py",
    "line number": "641",
    "func name": "test_simulation_smoothing_state_intercept_diffuse",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_smooth_basis.py",
    "line number": "22",
    "func name": "test_multivariate_polynomial_basis",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_smoothing.py",
    "line number": "1477",
    "func name": "test_news_invalid",
    "func arg": "(missing, filter_univariate, tvp)",
    "comments": ""
},{
    "source file": "test_specification.py",
    "line number": "584",
    "func name": "test_invalid_estimator",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_statespace.py",
    "line number": "44",
    "func name": "test_start_params",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_statstools.py",
    "line number": "167",
    "func name": "test_durbin_watson_pandas",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_stattools.py",
    "line number": "1055",
    "func name": "test_pacf_nlags_error",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_stl.py",
    "line number": "274",
    "func name": "test_default_trend",
    "func arg": "(default_kwargs)",
    "comments": ""
},{
    "source file": "test_structural.py",
    "line number": "680",
    "func name": "test_apply_results",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_summary_old.py",
    "line number": "7",
    "func name": "test_regression_summary",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_summary.py",
    "line number": "24",
    "func name": "test_wrong_len_xname",
    "func arg": "(reset_randomstate)",
    "comments": ""
},{
    "source file": "test_summary2.py",
    "line number": "153",
    "func name": "test_summary_col_r2",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_survfunc.py",
    "line number": "557",
    "func name": "test_kernel_cumincidence2",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_table_econpy.py",
    "line number": "50",
    "func name": "custom_labeller",
    "func arg": "(cell)",
    "comments": ""
},{
    "source file": "test_tabledist.py",
    "line number": "14",
    "func name": "test_tabledist",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_testing.py",
    "line number": "23",
    "func name": "test_holder",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_theta.py",
    "line number": "99",
    "func name": "test_forecast_errors",
    "func arg": "(data)",
    "comments": ""
},{
    "source file": "test_tools.py",
    "line number": "950",
    "func name": "test_copy_index_vector",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_tools88.py",
    "line number": "74",
    "func name": "test_validate_basic",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_tools90.py",
    "line number": "696",
    "func name": "test_categorical_errors",
    "func arg": "(string_var)",
    "comments": ""
},{
    "source file": "test_tost.py",
    "line number": "550",
    "func name": "test_tost_transform_paired",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_transf.py",
    "line number": "53",
    "func name": "foldnorm_stats",
    "func arg": "(c)",
    "comments": ""
},{
    "source file": "test_transform_model.py",
    "line number": "53",
    "func name": "test_standardize_ols",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_tsa_indexes.py",
    "line number": "1142",
    "func name": "test_get_index_loc_quarterly",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_tsa_tools.py",
    "line number": "375",
    "func name": "test_freq_to_period",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_tsaplots.py",
    "line number": "230",
    "func name": "test_seasonal_plot",
    "func arg": "(close_figures)",
    "comments": ""
},{
    "source file": "test_univariate.py",
    "line number": "687",
    "func name": "test_time_varying_transition",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_utils.py",
    "line number": "69",
    "func name": "test_webuse_pandas",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_validation.py",
    "line number": "394",
    "func name": "test_not_bool_like",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_var_jmulti.py",
    "line number": "527",
    "func name": "test_exceptions",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_var.py",
    "line number": "876",
    "func name": "test_from_formula",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_var91.py",
    "line number": "243",
    "func name": "test_var_c_2exog",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_varmax.py",
    "line number": "1134",
    "func name": "test_vma1_exog",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_vecm.py",
    "line number": "1372",
    "func name": "test_VECM_seasonal_forecast",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_weightstats.py",
    "line number": "528",
    "func name": "test_ztest_ztost",
    "func arg": "()",
    "comments": ""
},{
    "source file": "test_x13.py",
    "line number": "48",
    "func name": "test_x13_arima_plot",
    "func arg": "(dataset)",
    "comments": ""
},{
    "source file": "test_yule_walker.py",
    "line number": "82",
    "func name": "test_invalid_xfail",
    "func arg": "()",
    "comments": ""
},{
    "source file": "testing.py",
    "line number": "67",
    "func name": "assert_equal",
    "func arg": "(actual, desired, err_msg, verbose, **kwds)",
    "comments": ""
},{
    "source file": "theta.py",
    "line number": "43",
    "func name": "extend_index",
    "func arg": "(steps, index)",
    "comments": ""
},{
    "source file": "tools_pca.py",
    "line number": "87",
    "func name": "pcasvd",
    "func arg": "(data, keepdim, demean)",
    "comments": "principal components with svd\n\nParameters ---------- data : ndarray, 2d data with observations by rows and variables in columns keepdim : int number of eigenvectors to keep if keepdim is zero, then all eigenvectors are included demean : bool if true, then the column mean is subtracted from the data\n##### Returns\n* **xreduced **: ndarray, 2d, (nobs, nvars)\n    projection of the data x on the kept eigenvectors\n\n* **factors **: ndarray, 2d, (nobs, nfactors)\n    factor matrix, given by np.dot(x, evecs)\n\n* **evals **: ndarray, 2d, (nobs, nfactors)\n    eigenvalues\n\n* **evecs **: ndarray, 2d, (nobs, nfactors)\n    eigenvectors, normalized if normalize is true\n\n* **pca **: principal component analysis using eigenvector decomposition\n\n"
},{
    "source file": "tools.py",
    "line number": "1861",
    "func name": "prepare_trend_data",
    "func arg": "(polynomial_trend, k_trend, nobs, offset)",
    "comments": ""
},{
    "source file": "tools92.py",
    "line number": "255",
    "func name": "locscale_grad",
    "func arg": "(y, loc, scale, dlldy)",
    "comments": "derivative of log-likelihood with respect to location and scale\n\nParameters ---------- y : array_like data points of random variable at which loglike is evaluated loc : float location parameter of distribution scale : float scale parameter of distribution dlldy : function derivative of loglikelihood fuction wrt. random variable x args : array_like shape parameters of log-likelihood function\n##### Returns\n* **dlldloc **: ndarray\n    derivative of loglikelihood wrt location evaluated at the\n    points given in y\n\n* **dlldscale **: ndarray\n    derivative of loglikelihood wrt scale evaluated at the\n    points given in y\n\n"
},{
    "source file": "tools93.py",
    "line number": "111",
    "func name": "validate_basic",
    "func arg": "(params, length, allow_infnan, title)",
    "comments": "Validate parameter vector for basic correctness.\n\nParameters ---------- params : array_like Array of parameters to validate. length : int Expected length of the parameter vector. allow_infnan : bool, optional Whether or not to allow `params` to contain -np.Inf, np.Inf, and np.nan. Default is False. title : str, optional Description of the parameters (e.g. \"autoregressive\") to use in error messages.\n##### Returns\n* **params **: ndarray\n    Array of validated parameters.\n\n"
},{
    "source file": "tools94.py",
    "line number": "646",
    "func name": "matrix_rank",
    "func arg": "(m, tol, method)",
    "comments": "Matrix rank calculation using QR or SVD\n\nParameters ---------- m : array_like A 2-d array-like object to test tol : float, optional The tolerance to use when testing the matrix rank. If not provided an appropriate value is selected. method : {\"ip\", \"qr\", \"svd\"} The method used. \"ip\" uses the inner-product of a normalized version of m and then computes the rank using NumPy's matrix_rank. \"qr\" uses a QR decomposition and is the default. \"svd\" defers to NumPy's matrix_rank.\n##### Returns\n"
},{
    "source file": "transformed.py",
    "line number": "447",
    "func name": "absfunc",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "treewalkerclass.py",
    "line number": "167",
    "func name": "getnodes",
    "func arg": "(tree)",
    "comments": "walk tree to get list of branches and list of leaves\n\nParameters ---------- tree : list of tuples tree as defined for RU2NMNL\n##### Returns\n* **branch **: list\n    list of all branch names\n\n* **leaves **: list\n    list of all leaves names\n\n"
},{
    "source file": "try_ar.py",
    "line number": "11",
    "func name": "armaloop",
    "func arg": "(arcoefs, macoefs, x)",
    "comments": "get arma recursion in simple loop\n\nfor simplicity assumes that ma polynomial is not longer than the ar-polynomial\n\nParameters ---------- arcoefs : array_like autoregressive coefficients in right hand side parameterization macoefs : array_like moving average coefficients, without leading 1\n##### Returns\n* **y **: ndarray\n    predicted values, initial values are the same as the observed values\n\n* **e **: ndarray\n    predicted residuals, zero for initial observations\n\n"
},{
    "source file": "try_catdata.py",
    "line number": "115",
    "func name": "groupsstats_dummy",
    "func arg": "(y, x, nonseq)",
    "comments": ""
},{
    "source file": "try_mctools.py",
    "line number": "44",
    "func name": "adf20",
    "func arg": "(x)",
    "comments": ""
},{
    "source file": "try_mlecov.py",
    "line number": "120",
    "func name": "getpoly",
    "func arg": "(params)",
    "comments": ""
},{
    "source file": "try_ols_anova.py",
    "line number": "169",
    "func name": "dropname",
    "func arg": "(ss, li)",
    "comments": "drop names from a list of strings, names to drop are in space delimited list does not change original list\n\n\n"
},{
    "source file": "try_pot.py",
    "line number": "10",
    "func name": "mean_residual_life",
    "func arg": "(x, frac, alpha)",
    "comments": "empirical mean residual life or expected shortfall\n\nParameters ---------- x : 1-dimensional array_like frac : list[float], optional All entries must be between 0 and 1 alpha : float, default 0.05 FIXME: not actually used.\n\nTODO: check formula for std of mean does not include case for all observations last observations std is zero vectorize loop using cumsum frac does not work yet\n"
},{
    "source file": "try_power.py",
    "line number": "61",
    "func name": "cohen_es",
    "func arg": "(**kwds)",
    "comments": ""
},{
    "source file": "try_treewalker.py",
    "line number": "46",
    "func name": "branch2",
    "func arg": "(tree)",
    "comments": "walking a tree bottom-up based on dictionary\n\n\n"
},{
    "source file": "try_tukey_hsd.py",
    "line number": "130",
    "func name": "get_thsd",
    "func arg": "(mci)",
    "comments": ""
},{
    "source file": "try_var_convolve.py",
    "line number": "185",
    "func name": "maxabs",
    "func arg": "(x, y)",
    "comments": ""
},{
    "source file": "tsa_arma_0.py",
    "line number": "89",
    "func name": "mean_forecast_err",
    "func arg": "(y, yhat)",
    "comments": ""
},{
    "source file": "tsa.py",
    "line number": "25",
    "func name": "acovf_fft",
    "func arg": "(x, demean)",
    "comments": "autocovariance function with call to fftconvolve, biased\n\nParameters ---------- x : array_like timeseries, signal demean : bool If true, then demean time series\n##### Returns\n* **acovf **: ndarray\n    autocovariance for data, same length as x\n\n"
},{
    "source file": "tsaplots.py",
    "line number": "358",
    "func name": "quarter_plot",
    "func arg": "(x, dates, ylabel, ax)",
    "comments": "Seasonal plot of quarterly data\n\nParameters ---------- x : array_like Seasonal data to plot. If dates is None, x must be a pandas object with a PeriodIndex or DatetimeIndex with a monthly frequency. dates : array_like, optional If `x` is not a pandas object, then dates must be supplied. ylabel : str, optional The label for the y-axis. Will attempt to use the `name` attribute of the Series. ax : matplotlib.axes, optional Existing axes instance.\n##### Returns\n* **>>> dates = pd.to_datetime(list(map(lambda x**: '-'.join(x) + '-1',\n\n* **.. plot**: \n\n"
},{
    "source file": "tsatools.py",
    "line number": "792",
    "func name": "freq_to_period",
    "func arg": "(freq)",
    "comments": "Convert a pandas frequency to a periodicity\n\nParameters ---------- freq : str or offset Frequency to convert\n##### Returns\n* **period **: int\n    Periodicity of freq\n\n"
},{
    "source file": "tukeyplot.py",
    "line number": "6",
    "func name": "tukeyplot",
    "func arg": "(results, dim, yticklabels)",
    "comments": ""
},{
    "source file": "util.py",
    "line number": "296",
    "func name": "seasonal_dummies",
    "func arg": "(n_seasons, len_endog, first_period, centered)",
    "comments": "Parameters ---------- n_seasons : int >= 0 Number of seasons (e.g. 12 for monthly data and 4 for quarterly data). len_endog : int >= 0 Total number of observations. first_period : int, default: 0 Season of the first observation. As an example, suppose we have monthly data and the first observation is in March (third month of the year). In this case we pass 2 as first_period. (0 for the first season, 1 for the second, ..., n_seasons-1 for the last season). An integer greater than n_seasons-1 are treated in the same way as the integer modulo n_seasons. centered : bool, default: False If True, center (demean) the dummy variables. That is useful in order to get seasonal dummies that are orthogonal to the vector of constant dummy variables (a vector of ones).\n\n\n##### Returns\n* **seasonal_dummies **: ndarray (len_endog x n_seasons-1)\n\n"
},{
    "source file": "utils.py",
    "line number": "136",
    "func name": "annotate_axes",
    "func arg": "(index, labels, points, offset_points, size, ax, **kwargs)",
    "comments": "Annotate Axes with labels, points, offset_points according to the given index.\n\n\n"
},{
    "source file": "utils95.py",
    "line number": "330",
    "func name": "as_numpy_dataset",
    "func arg": "(ds, as_pandas, retain_index)",
    "comments": "Convert a pandas dataset to a NumPy dataset\n\n\n"
},{
    "source file": "validate_docstrings.py",
    "line number": "1005",
    "func name": "main",
    "func arg": "(func_name, prefix, errors, output_format, ignore_deprecated)",
    "comments": ""
},{
    "source file": "validation.py",
    "line number": "415",
    "func name": "dict_like",
    "func arg": "(value, name, optional, strict)",
    "comments": "Check if dict_like (dict, Mapping) or raise if not\n\nParameters ---------- value : object Value to verify name : str Variable name for exceptions optional : bool Flag indicating whether None is allowed strict : bool If True, then only allow dict. If False, allow any Mapping-like object.\n##### Returns\n* **converted **: dict_like\n    value\n\n"
},{
    "source file": "var_model.py",
    "line number": "2303",
    "func name": "_acovs_to_acorrs",
    "func arg": "(acovs)",
    "comments": ""
},{
    "source file": "var_plots.py",
    "line number": "39",
    "func name": "plot_fevd",
    "func arg": "()",
    "comments": ""
},{
    "source file": "varma_process.py",
    "line number": "315",
    "func name": "ar2lhs",
    "func arg": "(ar)",
    "comments": "convert full (rhs) lagpolynomial into a reduced, left side lagpoly array\n\nthis is mainly a reminder about the definition\n"
},{
    "source file": "varma.py",
    "line number": "77",
    "func name": "VARMA",
    "func arg": "(x, B, C, const)",
    "comments": "multivariate linear filter\n\nx (TxK) B (PxKxK)\n\nxhat(t,i) = sum{_p}sum{_k} { x(t-P:t,:) .* B(:,:,i) } + sum{_q}sum{_k} { e(t-Q:t,:) .* C(:,:,i) }for all i = 0,K-1\n"
},{
    "source file": "vecm.py",
    "line number": "526",
    "func name": "coint_johansen",
    "func arg": "(endog, det_order, k_ar_diff)",
    "comments": "Johansen cointegration test of the cointegration rank of a VECM\n\nParameters ---------- endog : array_like (nobs_tot x neqs) Data to test det_order : int * -1\n\n- no deterministic terms * 0\n\n- constant term * 1\n\n- linear trend k_ar_diff : int, nonnegative Number of lagged differences in the model.\n##### Returns\n* **result **: JohansenTestResult\n    An object containing the test's results. The most important attributes\n    of the result class are\n\n"
},{
    "source file": "versioneer.py",
    "line number": "1779",
    "func name": "scan_setup_py",
    "func arg": "()",
    "comments": "Validate the contents of setup.py against Versioneer's expectations.\n\n\n"
},{
    "source file": "web.py",
    "line number": "47",
    "func name": "webdoc",
    "func arg": "(func, stable)",
    "comments": "Opens a browser and displays online documentation\n\nParameters ---------- func : {str, callable} Either a string to search the documentation or a function stable : bool Flag indicating whether to use the stable documentation (True) or the development documentation (False).\n\nIf not provided, opens the stable documentation if the current version of statsmodels is a release\n\nExamples -------- >>> import statsmodels.api as sm\n\nDocumentation site\n\n>>> sm.webdoc()\n\nSearch for glm in docs\n\n>>> sm.webdoc('glm')\n\nGo to current generated help for OLS\n\n>>> sm.webdoc(sm.OLS, stable=False)\n\nNotes ----- By default, open stable documentation if the current version of statsmodels is a release.\n\nOtherwise opens the development documentation.\n\nUses the default system browser.\n"
},{
    "source file": "weightstats.py",
    "line number": "1445",
    "func name": "ztost",
    "func arg": "(x1, low, upp, x2, usevar, ddof)",
    "comments": "Equivalence test based on normal distribution\n\nParameters ---------- x1 : array_like one sample or first sample for 2 independent samples low, upp : float equivalence interval low < m1\n\n- m2 < upp x1 : array_like or None second sample for 2 independent samples test. If None, then a one-sample test is performed. usevar : str, 'pooled' If `pooled`, then the standard deviation of the samples is assumed to be the same. Only `pooled` is currently implemented.\n##### Returns\n* **pvalue **: float\n    pvalue of the non-equivalence test\n\n* **t1, pv1 **: tuple of floats\n    test statistic and pvalue for lower threshold test\n\n* **t2, pv2 **: tuple of floats\n    test statistic and pvalue for upper threshold test\n\n"
},{
    "source file": "wls_extended.py",
    "line number": "116",
    "func name": "index_trim_outlier",
    "func arg": "(resid, k)",
    "comments": "returns indices to residual array with k outliers removed\n\nParameters ---------- resid : array_like, 1d data vector, usually residuals of a regression k : int number of outliers to remove\n##### Returns\n* **trimmed_index **: ndarray, 1d\n    index array with k outliers removed\n\n* **outlier_index **: ndarray, 1d\n    index array of k outliers\n\n"
},{
    "source file": "wrapper.py",
    "line number": "127",
    "func name": "populate_wrapper",
    "func arg": "(klass, wrapping)",
    "comments": ""
},{
    "source file": "x13.py",
    "line number": "490",
    "func name": "x13_arima_select_order",
    "func arg": "(endog, maxorder, maxdiff, diff, exog, log, outlier, trading, forecast_periods, start, freq, print_stdout, x12path, prefer_x13)",
    "comments": "Perform automatic seasonal ARIMA order identification using x12/x13 ARIMA.\n\nParameters ---------- endog : array_like, pandas.Series The series to model. It is best to use a pandas object with a DatetimeIndex or PeriodIndex. However, you can pass an array-like object. If your object does not have a dates index then ``start`` and ``freq`` are not optional. maxorder : tuple The maximum order of the regular and seasonal ARMA polynomials to examine during the model identification. The order for the regular polynomial must be greater than zero and no larger than 4. The order for the seasonal polynomial may be 1 or 2. maxdiff : tuple The maximum orders for regular and seasonal differencing in the automatic differencing procedure. Acceptable inputs for regular differencing are 1 and 2. The maximum order for seasonal differencing is 1. If ``diff`` is specified then ``maxdiff`` should be None. Otherwise, ``diff`` will be ignored. See also ``diff``. diff : tuple Fixes the orders of differencing for the regular and seasonal differencing. Regular differencing may be 0, 1, or 2. Seasonal differencing may be 0 or 1. ``maxdiff`` must be None, otherwise ``diff`` is ignored. exog : array_like Exogenous variables. log : bool or None If None, it is automatically determined whether to log the series or not. If False, logs are not taken. If True, logs are taken. outlier : bool Whether or not outliers are tested for and corrected, if detected. trading : bool Whether or not trading day effects are tested for. forecast_periods : int Number of forecasts produced. The default is None. start : str, datetime Must be given if ``endog`` does not have date information in its index. Anything accepted by pandas.DatetimeIndex for the start value. freq : str Must be givein if ``endog`` does not have date information in its index. Anything accepted by pandas.DatetimeIndex for the freq value. print_stdout : bool The stdout from X12/X13 is suppressed. To print it out, set this to True. Default is False. x12path : str or None The path to x12 or x13 binary. If None, the program will attempt to find x13as or x12a on the PATH or by looking at X13PATH or X12PATH depending on the value of prefer_x13. prefer_x13 : bool If True, will look for x13as first and will fallback to the X13PATH environmental variable. If False, will look for x12a first and will fallback to the X12PATH environmental variable. If x12path points to the path for the X12/X13 binary, it does nothing.\n##### Returns\n* **Bunch\n    A bunch object containing the listed attributes.\n    - order **: tuple\n      The regular order.\n    - sorder\n\n"
},{
    "source file": "yule_walker.py",
    "line number": "16",
    "func name": "yule_walker",
    "func arg": "(endog, ar_order, demean, adjusted)",
    "comments": "Estimate AR parameters using Yule-Walker equations.\n\nParameters ---------- endog : array_like or SARIMAXSpecification Input time series array, assumed to be stationary. ar_order : int, optional Autoregressive order. Default is 0. demean : bool, optional Whether to estimate and remove the mean from the process prior to fitting the autoregressive coefficients. Default is True. adjusted : bool, optional Whether to use the adjusted autocovariance estimator, which uses n\n\n- h degrees of freedom rather than n. For some processes this option may\n\nresult in a non-positive definite autocovariance matrix. Default is False.\n##### Returns\n* **parameters **: SARIMAXParams object\n    Contains the parameter estimates from the final iteration.\n\n* **other_results **: Bunch\n    Includes one component, `spec`, which is the `SARIMAXSpecification`\n    instance corresponding to the input arguments.\n\n"
}]
}