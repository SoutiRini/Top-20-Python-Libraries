{
    "source file": "_bvp.py",
    "line number": "711",
    "func name": "solve_bvp",
    "func arg": "(fun, bc, x, y, p, S, fun_jac, bc_jac, tol, max_nodes, verbose, bc_tol)",
    "comments": "Solve a boundary value problem for a system of ODEs.\n\nThis function numerically solves a first order system of ODEs subject to two-point boundary conditions::\n\ndy / dx = f(x, y, p) + S * y / (x\n\n- a), a <= x <= b bc(y(a), y(b), p) = 0\n\nHere x is a 1-D independent variable, y(x) is an N-D vector-valued function and p is a k-D vector of unknown parameters which is to be found along with y(x). For the problem to be determined, there must be n + k boundary conditions, i.e., bc must be an (n + k)-D function.\n\nThe last singular term on the right-hand side of the system is optional. It is defined by an n-by-n matrix S, such that the solution must satisfy S y(a) = 0. This condition will be forced during iterations, so it must not contradict boundary conditions. See [2]_ for the explanation how this term is handled when solving BVPs numerically.\n\nProblems in a complex domain can be solved as well. In this case, y and p are considered to be complex, and f and bc are assumed to be complex-valued functions, but x stays real. Note that f and bc must be complex differentiable (satisfy Cauchy-Riemann equations [4]_), otherwise you should rewrite your problem for real and imaginary parts separately. To solve a problem in a complex domain, pass an initial guess for y with a complex data type (see below).\n\nParameters ---------- fun : callable Right-hand side of the system. The calling signature is ``fun(x, y)``, or ``fun(x, y, p)`` if parameters are present. All arguments are ndarray: ``x`` with shape (m,), ``y`` with shape (n, m), meaning that ``y[:, i]`` corresponds to ``x[i]``, and ``p`` with shape (k,). The return value must be an array with shape (n, m) and with the same layout as ``y``. bc : callable Function evaluating residuals of the boundary conditions. The calling signature is ``bc(ya, yb)``, or ``bc(ya, yb, p)`` if parameters are present. All arguments are ndarray: ``ya`` and ``yb`` with shape (n,), and ``p`` with shape (k,). The return value must be an array with shape (n + k,). x : array_like, shape (m,) Initial mesh. Must be a strictly increasing sequence of real numbers with ``x[0]=a`` and ``x[-1]=b``. y : array_like, shape (n, m) Initial guess for the function values at the mesh nodes, ith column corresponds to ``x[i]``. For problems in a complex domain pass `y` with a complex data type (even if the initial guess is purely real). p : array_like with shape (k,) or None, optional Initial guess for the unknown parameters. If None (default), it is assumed that the problem doesn't depend on any parameters. S : array_like with shape (n, n) or None Matrix defining the singular term. If None (default), the problem is solved without the singular term. fun_jac : callable or None, optional Function computing derivatives of f with respect to y and p. The calling signature is ``fun_jac(x, y)``, or ``fun_jac(x, y, p)`` if parameters are present. The return must contain 1 or 2 elements in the following order:\n\n* df_dy : array_like with shape (n, n, m), where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j. * df_dp : array_like with shape (n, k, m), where an element (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j.\n\nHere q numbers nodes at which x and y are defined, whereas i and j number vector components. If the problem is solved without unknown parameters, df_dp should not be returned.\n\nIf `fun_jac` is None (default), the derivatives will be estimated by the forward finite differences. bc_jac : callable or None, optional Function computing derivatives of bc with respect to ya, yb, and p. The calling signature is ``bc_jac(ya, yb)``, or ``bc_jac(ya, yb, p)`` if parameters are present. The return must contain 2 or 3 elements in the following order:\n\n* dbc_dya : array_like with shape (n, n), where an element (i, j) equals to d bc_i(ya, yb, p) / d ya_j. * dbc_dyb : array_like with shape (n, n), where an element (i, j) equals to d bc_i(ya, yb, p) / d yb_j. * dbc_dp : array_like with shape (n, k), where an element (i, j) equals to d bc_i(ya, yb, p) / d p_j.\n\nIf the problem is solved without unknown parameters, dbc_dp should not be returned.\n\nIf `bc_jac` is None (default), the derivatives will be estimated by the forward finite differences. tol : float, optional Desired tolerance of the solution. If we define ``r = y'\n\n- f(x, y)``, where y is the found solution, then the solver tries to achieve on each mesh interval ``norm(r / (1 + abs(f)) < tol``, where ``norm`` is estimated in a root mean squared sense (using a numerical quadrature formula). Default is 1e-3. max_nodes : int, optional Maximum allowed number of the mesh nodes. If exceeded, the algorithm terminates. Default is 1000. verbose : {0, 1, 2}, optional Level of algorithm's verbosity:\n\n* 0 (default) : work silently. * 1 : display a termination report. * 2 : display progress during iterations. bc_tol : float, optional Desired absolute tolerance for the boundary condition residuals: `bc` value should satisfy ``abs(bc) < bc_tol`` component-wise. Equals to `tol` by default. Up to 10 iterations are allowed to achieve this tolerance.\n##### Returns\n* **Bunch object with the following fields defined**: \n\n* **sol **: PPoly\n    Found solution for y as `scipy.interpolate.PPoly` instance, a C1\n    continuous cubic spline.\n\n* **p **: ndarray or None, shape (k,)\n    Found parameters. None, if the parameters were not present in the\n    problem.\n\n* **x **: ndarray, shape (m,)\n    Nodes of the final mesh.\n\n* **y **: ndarray, shape (n, m)\n    Solution values at the mesh nodes.\n\n* **yp **: ndarray, shape (n, m)\n    Solution derivatives at the mesh nodes.\n\n* **rms_residuals **: ndarray, shape (m - 1,)\n    RMS values of the relative residuals over each mesh interval (see the\n    description of `tol` parameter).\n\n* **niter **: int\n    Number of completed iterations.\n\n* **status **: int\n    Reason for algorithm termination\n\n* **message **: string\n    Verbal description of the termination reason.\n\n* **success **: bool\n    True if the algorithm converged to the desired accuracy (``status=0``).\n\n* **.. versionadded**: \n\n* **.. [4] `Cauchy-Riemann equations\n        <https**: //en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\n        Wikipedia.\n\n* **In the first example, we solve Bratu's problem**: \n\n* **right-hand side evaluation**: \n\n* **>>> def fun(x, y)**: \n\n* **Implement evaluation of the boundary condition residuals**: \n\n* **>>> def bc(ya, yb)**: \n\n* **Define the initial mesh with 5 nodes**: \n\n* **In the second example, we solve a simple Sturm-Liouville problem**: \n\n* **A = 1 we add a boundary condition**: \n\n* **>>> def fun(x, y, p)**: \n\n* **Implement the boundary conditions**: \n\n* **>>> def bc(ya, yb, p)**: \n\n* **sin(2 * pi * x)**: \n\n* **We see that the found k is approximately correct**: \n\n* **And, finally, plot the solution to see the anticipated sinusoid**: \n\n"
}