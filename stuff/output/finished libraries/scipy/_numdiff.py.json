{
    "source file": "_numdiff.py",
    "line number": "607",
    "func name": "check_derivative",
    "func arg": "(fun, jac, x0, bounds, args, kwargs)",
    "comments": "Check correctness of a function computing derivatives (Jacobian or gradient) by comparison with a finite difference approximation.\n\nParameters ---------- fun : callable Function of which to estimate the derivatives. The argument x passed to this function is ndarray of shape (n,) (never a scalar even if n=1). It must return 1-D array_like of shape (m,) or a scalar. jac : callable Function which computes Jacobian matrix of `fun`. It must work with argument x the same way as `fun`. The return value must be array_like or sparse matrix with an appropriate shape. x0 : array_like of shape (n,) or float Point at which to estimate the derivatives. Float will be converted to 1-D array. bounds : 2-tuple of array_like, optional Lower and upper bounds on independent variables. Defaults to no bounds. Each bound must match the size of `x0` or be a scalar, in the latter case the bound will be the same for all variables. Use it to limit the range of function evaluation. args, kwargs : tuple and dict, optional Additional arguments passed to `fun` and `jac`. Both empty by default. The calling signature is ``fun(x, *args, **kwargs)`` and the same for `jac`.\n##### Returns\n* **accuracy **: float\n    The maximum among all relative errors for elements with absolute values\n    higher than 1 and absolute errors for elements with absolute values\n    less or equal than 1. If `accuracy` is on the order of 1e-6 or lower,\n    then it is likely that your `jac` implementation is correct.\n\n* **approx_derivative **: Compute finite difference approximation of derivative.\n\n* **>>> def f(x, c1, c2)**: \n\n* **>>> def jac(x, c1, c2)**: \n\n"
}