{
    "source file": "_peak_finding31.py",
    "line number": "1189",
    "func name": "find_peaks_cwt",
    "func arg": "(vector, widths, wavelet, max_distances, gap_thresh, min_length, min_snr, noise_perc, window_size)",
    "comments": "Find peaks in a 1-D array with wavelet transformation.\n\nThe general approach is to smooth `vector` by convolving it with `wavelet(width)` for each width in `widths`. Relative maxima which appear at enough length scales, and with sufficiently high SNR, are accepted.\n\nParameters ---------- vector : ndarray 1-D array in which to find the peaks. widths : sequence 1-D array of widths to use for calculating the CWT matrix. In general, this range should cover the expected width of peaks of interest. wavelet : callable, optional Should take two parameters and return a 1-D array to convolve with `vector`. The first parameter determines the number of points of the returned wavelet array, the second parameter is the scale (`width`) of the wavelet. Should be normalized and symmetric. Default is the ricker wavelet. max_distances : ndarray, optional At each row, a ridge line is only connected if the relative max at row[n] is within ``max_distances[n]`` from the relative max at ``row[n+1]``.\n\nDefault value is ``widths/4``. gap_thresh : float, optional If a relative maximum is not found within `max_distances`, there will be a gap. A ridge line is discontinued if there are more than `gap_thresh` points without connecting a new relative maximum. Default is the first value of the widths array i.e. widths[0]. min_length : int, optional Minimum length a ridge line needs to be acceptable. Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths. min_snr : float, optional Minimum SNR ratio. Default 1. The signal is the value of the cwt matrix at the shortest length scale (``cwt[0, loc]``), the noise is the `noise_perc`th percentile of datapoints contained within a window of `window_size` around ``cwt[0, loc]``. noise_perc : float, optional When calculating the noise floor, percentile of data points examined below which to consider noise. Calculated using `stats.scoreatpercentile`.\n\nDefault is 10. window_size : int, optional Size of window to use to calculate noise floor. Default is ``cwt.shape[1] / 20``.\n##### Returns\n* **peaks_indices **: ndarray\n    Indices of the locations in the `vector` where peaks were found.\n    The list is sorted.\n\n* **The algorithm is as follows**: 1. Perform a continuous wavelet transform on `vector`, for the supplied\n    `widths`. This is a convolution of `vector` with `wavelet(width)` for\n    each width in `widths`. See `cwt`.\n 2. Identify \"ridge lines\" in the cwt matrix. These are relative maxima\n    at each row, connected across adjacent rows. See identify_ridge_lines\n 3. Filter the ridge_lines using filter_ridge_lines.\n\n* **.. versionadded**: \n\n* **.. [1] Bioinformatics (2006) 22 (17)**: 2059-2065.\n\n"
}