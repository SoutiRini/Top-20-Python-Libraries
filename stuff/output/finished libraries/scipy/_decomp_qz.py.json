{
    "source file": "_decomp_qz.py",
    "line number": "265",
    "func name": "ordqz",
    "func arg": "(A, B, sort, output, overwrite_a, overwrite_b, check_finite)",
    "comments": "QZ decomposition for a pair of matrices with reordering.\n\n.. versionadded:: 0.17.0\n\nParameters ---------- A : (N, N) array_like 2-D array to decompose B : (N, N) array_like 2-D array to decompose sort : {callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional Specifies whether the upper eigenvalues should be sorted. A callable may be passed that, given an ordered pair ``(alpha, beta)`` representing the eigenvalue ``x = (alpha/beta)``, returns a boolean denoting whether the eigenvalue should be sorted to the top-left (True). For the real matrix pairs ``beta`` is real while ``alpha`` can be complex, and for complex matrix pairs both ``alpha`` and ``beta`` can be complex. The callable must be able to accept a NumPy array. Alternatively, string parameters may be used:\n\n- 'lhp'\n\n Left-hand plane (x.real < 0.0)\n\n- 'rhp'\n\n Right-hand plane (x.real > 0.0)\n\n- 'iuc'\n\n Inside the unit circle (x*x.conjugate() < 1.0)\n\n- 'ouc'\n\n Outside the unit circle (x*x.conjugate() > 1.0)\n\nWith the predefined sorting functions, an infinite eigenvalue (i.e., ``alpha != 0`` and ``beta = 0``) is considered to lie in neither the left-hand nor the right-hand plane, but it is considered to lie outside the unit circle. For the eigenvalue ``(alpha, beta) = (0, 0)``, the predefined sorting functions all return `False`. output : str {'real','complex'}, optional Construct the real or complex QZ decomposition for real matrices. Default is 'real'. overwrite_a : bool, optional If True, the contents of A are overwritten. overwrite_b : bool, optional If True, the contents of B are overwritten. check_finite : bool, optional If true checks the elements of `A` and `B` are finite numbers. If false does no checking and passes matrix through to underlying algorithm.\n##### Returns\n* **AA **: (N, N) ndarray\n    Generalized Schur form of A.\n\n* **BB **: (N, N) ndarray\n    Generalized Schur form of B.\n\n* **alpha **: (N,) ndarray\n    alpha = alphar + alphai * 1j. See notes.\n\n* **beta **: (N,) ndarray\n    See notes.\n\n* **Q **: (N, N) ndarray\n    The left Schur vectors.\n\n* **Z **: (N, N) ndarray\n    The right Schur vectors.\n\n"
}