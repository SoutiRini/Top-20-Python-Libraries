{
    "source file": "lsmr94.py",
    "line number": "29",
    "func name": "lsmr",
    "func arg": "(A, b, damp, atol, btol, conlim, maxiter, show, x0)",
    "comments": "Iterative solver for least-squares problems.\n\nlsmr solves the system of linear equations ``Ax = b``. If the system is inconsistent, it solves the least-squares problem ``min ||b\n\n- Ax||_2``. A is a rectangular matrix of dimension m-by-n, where all cases are allowed: m = n, m > n, or m < n. B is a vector of length m. The matrix A may be dense or sparse (usually sparse).\n\nParameters ---------- A : {matrix, sparse matrix, ndarray, LinearOperator} Matrix A in the linear system. Alternatively, ``A`` can be a linear operator which can produce ``Ax`` and ``A^H x`` using, e.g., ``scipy.sparse.linalg.LinearOperator``. b : array_like, shape (m,) Vector b in the linear system. damp : float Damping factor for regularized least-squares. `lsmr` solves the regularized least-squares problem::\n\nmin ||(b)\n\n- (\n\nA\n\n )x|| ||(0)\n\n (damp*I) ||_2\n\nwhere damp is a scalar.\n\nIf damp is None or 0, the system is solved without regularization. atol, btol : float, optional Stopping tolerances. `lsmr` continues iterations until a certain backward error estimate is smaller than some quantity depending on atol and btol.\n\nLet ``r = b\n\n- Ax`` be the residual vector for the current approximate solution ``x``. If ``Ax = b`` seems to be consistent, ``lsmr`` terminates when ``norm(r) <= atol * norm(A) * norm(x) + btol * norm(b)``. Otherwise, lsmr terminates when ``norm(A^H r) <= atol * norm(A) * norm(r)``.\n\nIf both tolerances are 1.0e-6 (say), the final ``norm(r)`` should be accurate to about 6 digits. (The final x will usually have fewer correct digits, depending on ``cond(A)`` and the size of LAMBDA.)\n\nIf `atol` or `btol` is None, a default value of 1.0e-6 will be used. Ideally, they should be estimates of the relative error in the entries of A and B respectively.\n\nFor example, if the entries of `A` have 7 correct digits, set atol = 1e-7. This prevents the algorithm from doing unnecessary work beyond the uncertainty of the input data. conlim : float, optional `lsmr` terminates if an estimate of ``cond(A)`` exceeds `conlim`.\n\nFor compatible systems ``Ax = b``, conlim could be as large as 1.0e+12 (say).\n\nFor least-squares problems, `conlim` should be less than 1.0e+8. If `conlim` is None, the default value is 1e+8.\n\nMaximum precision can be obtained by setting ``atol = btol = conlim = 0``, but the number of iterations may then be excessive. maxiter : int, optional `lsmr` terminates if the number of iterations reaches `maxiter`.\n\nThe default is ``maxiter = min(m, n)``.\n\nFor ill-conditioned systems, a larger value of `maxiter` may be needed. show : bool, optional Print iterations logs if ``show=True``. x0 : array_like, shape (n,), optional Initial guess of x, if None zeros are used.\n\n.. versionadded:: 1.0.0\n##### Returns\n* **x **: ndarray of float\n    Least-square solution returned.\n\n* **istop **: int\n    istop gives the reason for stopping\n\n* **itn **: int\n    Number of iterations used.\n\n* **normr **: float\n    ``norm(b-Ax)``\n\n* **normar **: float\n    ``norm(A^H (b - Ax))``\n\n* **norma **: float\n    ``norm(A)``\n\n* **conda **: float\n    Condition number of A.\n\n* **normx **: float\n    ``norm(x)``\n\n* **.. versionadded**: \n\n* **.. [1] D. C.-L. Fong and M. A. Saunders,\n       \"LSMR**: An iterative algorithm for sparse least-squares problems\",\n       SIAM J. Sci. Comput., vol. 33, pp. 2950-2971, 2011.\n       https\n\n* **.. [2] LSMR Software, https**: //web.stanford.edu/group/SOL/software/lsmr/\n\n* **>>> x, istop, itn, normr = lsmr(A, b)[**: 4]\n\n* **The next example has a non-trivial solution**: \n\n* **solution for the equation**: \n\n"
}