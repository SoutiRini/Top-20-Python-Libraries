{
    "source file": "filters.py",
    "line number": "1449",
    "func name": "generic_filter",
    "func arg": "(input, function, size, footprint, output, mode, cval, origin, extra_arguments, extra_keywords)",
    "comments": "Calculate a multidimensional filter using the given function.\n\nAt each element the provided function is called. The input values within the filter footprint at that element are passed to the function as a 1-D array of double values.\n\nParameters ---------- %(input)s function : {callable, scipy.LowLevelCallable} Function to apply at each element. %(size_foot)s %(output)s %(mode_reflect)s %(cval)s %(origin_multiple)s %(extra_arguments)s %(extra_keywords)s\n\nNotes ----- This function also accepts low-level callback functions with one of the following signatures and wrapped in `scipy.LowLevelCallable`:\n\n.. code:: c\n\nint callback(double *buffer, npy_intp filter_size, double *return_value, void *user_data) int callback(double *buffer, intptr_t filter_size, double *return_value, void *user_data)\n\nThe calling function iterates over the elements of the input and output arrays, calling the callback function at each element. The elements within the footprint of the filter at the current element are passed through the ``buffer`` parameter, and the number of elements within the footprint through ``filter_size``. The calculated value is returned in ``return_value``. ``user_data`` is the data pointer provided to `scipy.LowLevelCallable` as-is.\n\nThe callback function must return an integer error status that is zero if something went wrong and one otherwise. If an error occurs, you should normally set the python error status with an informative message before returning, otherwise a default error message is set by the calling function.\n\nIn addition, some other low-level function pointer specifications are accepted, but these are for backward compatibility only and should not be used in new code.\n"
}