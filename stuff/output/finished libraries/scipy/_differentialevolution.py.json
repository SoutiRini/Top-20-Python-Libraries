{
    "source file": "_differentialevolution.py",
    "line number": "22",
    "func name": "differential_evolution",
    "func arg": "(func, bounds, args, strategy, maxiter, popsize, tol, mutation, recombination, seed, callback, disp, polish, init, atol, updating, workers, constraints)",
    "comments": "Finds the global minimum of a multivariate function.\n\nDifferential Evolution is stochastic in nature (does not use gradient methods) to find the minimum, and can search large areas of candidate space, but often requires larger numbers of function evaluations than conventional gradient-based techniques.\n\nThe algorithm is due to Storn and Price [1]_.\n\nParameters ---------- func : callable The objective function to be minimized. Must be in the form ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array and ``args`` is a\n\ntuple of any additional fixed parameters needed to completely specify the function. bounds : sequence or `Bounds`, optional Bounds for variables. There are two ways to specify the bounds: 1. Instance of `Bounds` class. 2. ``(min, max)`` pairs for each element in ``x``, defining the finite lower and upper bounds for the optimizing argument of `func`. It is required to have ``len(bounds) == len(x)``. ``len(bounds)`` is used to determine the number of parameters in ``x``. args : tuple, optional Any additional fixed parameters needed to completely specify the objective function. strategy : str, optional The differential evolution strategy to use. Should be one of:\n\n- 'best1bin'\n\n- 'best1exp'\n\n- 'rand1exp'\n\n- 'randtobest1exp'\n\n- 'currenttobest1exp'\n\n- 'best2exp'\n\n- 'rand2exp'\n\n- 'randtobest1bin'\n\n- 'currenttobest1bin'\n\n- 'best2bin'\n\n- 'rand2bin'\n\n- 'rand1bin'\n\nThe default is 'best1bin'. maxiter : int, optional The maximum number of generations over which the entire population is evolved. The maximum number of function evaluations (with no polishing) is: ``(maxiter + 1) * popsize * len(x)`` popsize : int, optional A multiplier for setting the total population size. The population has ``popsize * len(x)`` individuals (unless the initial population is supplied via the `init` keyword). tol : float, optional Relative tolerance for convergence, the solving stops when ``np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))``, where and `atol` and `tol` are the absolute and relative tolerance respectively. mutation : float or tuple(float, float), optional The mutation constant. In the literature this is also known as differential weight, being denoted by F. If specified as a float it should be in the range [0, 2]. If specified as a tuple ``(min, max)`` dithering is employed. Dithering randomly changes the mutation constant on a generation by generation basis. The mutation constant for that generation is taken from ``U[min, max)``. Dithering can help speed convergence significantly. Increasing the mutation constant increases the search radius, but will slow down convergence. recombination : float, optional The recombination constant, should be in the range [0, 1]. In the literature this is also known as the crossover probability, being denoted by CR. Increasing this value allows a larger number of mutants to progress into the next generation, but at the risk of population stability. seed : {int, `~np.random.RandomState`, `~np.random.Generator`}, optional If `seed` is not specified the `~np.random.RandomState` singleton is used. If `seed` is an int, a new ``RandomState`` instance is used, seeded with seed. If `seed` is already a ``RandomState`` or a ``Generator`` instance, then that object is used. Specify `seed` for repeatable minimizations. disp : bool, optional Prints the evaluated `func` at every iteration. callback : callable, `callback(xk, convergence=val)`, optional A function to follow the progress of the minimization. ``xk`` is the current value of ``x0``. ``val`` represents the fractional value of the population convergence.\n\nWhen ``val`` is greater than one the function halts. If callback returns `True`, then the minimization is halted (any polishing is still carried out). polish : bool, optional If True (default), then `scipy.optimize.minimize` with the `L-BFGS-B` method is used to polish the best population member at the end, which can improve the minimization slightly. If a constrained problem is being studied then the `trust-constr` method is used instead. init : str or array-like, optional Specify which type of population initialization is performed. Should be one of:\n\n- 'latinhypercube'\n\n- 'random'\n\n- array specifying the initial population. The array should have shape ``(M, len(x))``, where M is the total population size and len(x) is the number of parameters. `init` is clipped to `bounds` before use.\n\nThe default is 'latinhypercube'. Latin Hypercube sampling tries to maximize coverage of the available parameter space. 'random' initializes the population randomly\n\n- this has the drawback that clustering can occur, preventing the whole of parameter space being covered. Use of an array to specify a population subset could be used, for example, to create a tight bunch of initial guesses in an location where the solution is known to exist, thereby reducing time for convergence. atol : float, optional Absolute tolerance for convergence, the solving stops when ``np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))``, where and `atol` and `tol` are the absolute and relative tolerance respectively. updating : {'immediate', 'deferred'}, optional If ``'immediate'``, the best solution vector is continuously updated within a single generation [4]_. This can lead to faster convergence as trial vectors can take advantage of continuous improvements in the best solution. With ``'deferred'``, the best solution vector is updated once per generation. Only ``'deferred'`` is compatible with parallelization, and the `workers` keyword can over-ride this option.\n\n.. versionadded:: 1.2.0\n\nworkers : int or map-like callable, optional If `workers` is an int the population is subdivided into `workers` sections and evaluated in parallel (uses `multiprocessing.Pool <multiprocessing>`). Supply -1 to use all available CPU cores. Alternatively supply a map-like callable, such as `multiprocessing.Pool.map` for evaluating the population in parallel. This evaluation is carried out as ``workers(func, iterable)``. This option will override the `updating` keyword to ``updating='deferred'`` if ``workers != 1``. Requires that `func` be pickleable.\n\n.. versionadded:: 1.2.0\n\nconstraints : {NonLinearConstraint, LinearConstraint, Bounds} Constraints on the solver, over and above those applied by the `bounds` kwd. Uses the approach by Lampinen [5]_.\n\n.. versionadded:: 1.4.0\n##### Returns\n* **res **: OptimizeResult\n    The optimization result represented as a `OptimizeResult` object.\n    Important attributes are\n\n* **is used to mutate the best member (the 'best' in 'best1bin'), **: math\n\n* **so far**: \n\n* **.. math**: \n\n* **.. versionadded**: \n\n* **>>> def constr_f(x)**: \n\n* **(https**: //en.wikipedia.org/wiki/Test_functions_for_optimization).\n\n* **>>> def ackley(x)**: \n\n* **.. [2] http**: //www1.icsi.berkeley.edu/~storn/code.html\n\n* **.. [3] http**: //en.wikipedia.org/wiki/Differential_evolution\n\n"
}