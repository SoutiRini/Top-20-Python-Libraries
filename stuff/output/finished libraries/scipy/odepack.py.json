{
    "source file": "odepack.py",
    "line number": "28",
    "func name": "odeint",
    "func arg": "(func, y0, t, args, Dfun, col_deriv, full_output, ml, mu, rtol, atol, tcrit, h0, hmax, hmin, ixpr, mxstep, mxhnil, mxordn, mxords, printmessg, tfirst)",
    "comments": "Integrate a system of ordinary differential equations.\n\n.. note:: For new code, use `scipy.integrate.solve_ivp` to solve a differential equation.\n\nSolve a system of ordinary differential equations using lsoda from the FORTRAN library odepack.\n\nSolves the initial value problem for stiff or non-stiff systems of first order ode-s::\n\ndy/dt = func(y, t, ...)\n\n[or func(t, y, ...)]\n\nwhere y can be a vector.\n\n.. note:: By default, the required order of the first two arguments of `func` are in the opposite order of the arguments in the system definition function used by the `scipy.integrate.ode` class and the function `scipy.integrate.solve_ivp`. To use a function with the signature ``func(t, y, ...)``, the argument `tfirst` must be set to ``True``.\n\nParameters ---------- func : callable(y, t, ...) or callable(t, y, ...) Computes the derivative of y at t. If the signature is ``callable(t, y, ...)``, then the argument `tfirst` must be set ``True``. y0 : array Initial condition on y (can be a vector). t : array A sequence of time points for which to solve for y. The initial value point should be the first element of this sequence. This sequence must be monotonically increasing or monotonically decreasing; repeated values are allowed. args : tuple, optional Extra arguments to pass to function. Dfun : callable(y, t, ...) or callable(t, y, ...) Gradient (Jacobian) of `func`. If the signature is ``callable(t, y, ...)``, then the argument `tfirst` must be set ``True``. col_deriv : bool, optional True if `Dfun` defines derivatives down columns (faster), otherwise `Dfun` should define derivatives across rows. full_output : bool, optional True if to return a dictionary of optional outputs as the second output printmessg : bool, optional Whether to print the convergence message tfirst: bool, optional If True, the first two arguments of `func` (and `Dfun`, if given) must ``t, y`` instead of the default ``y, t``.\n\n.. versionadded:: 1.1.0\n##### Returns\n* **y **: array, shape (len(t), len(y0))\n    Array containing the value of y for each desired time in t,\n    with the initial value `y0` in the first row.\n\n* **infodict **: dict, only returned if full_output == True\n    Dictionary containing additional output information\n    =======  ============================================================\n    key      meaning\n    =======  ============================================================\n    'hu'     vector of step sizes successfully used for each time step\n    'tcur'   vector with the value of t reached for each time step\n             (will always be at least as large as the input times)\n    'tolsf'  vector of tolerance scale factors, greater than 1.0,\n             computed when a request for too much accuracy was detected\n    'tsw'    value of t at the time of the last method switch\n             (given for each time step)\n    'nst'    cumulative number of time steps\n    'nfe'    cumulative number of function evaluations for each time step\n    'nje'    cumulative number of jacobian evaluations for each time step\n    'nqu'    a vector of method orders for each successful step\n    'imxer'  index of the component of largest magnitude in the\n             weighted local error vector (e / ewt) on an error return, -1\n             otherwise\n    'lenrw'  the length of the double work array required\n    'leniw'  the length of integer work array required\n    'mused'  a vector of method indicators for each successful time step\n\n* **ml, mu **: int, optional\n    If either of these are not None or non-negative, then the\n    Jacobian is assumed to be banded. These give the number of\n    lower and upper non-zero diagonals in this banded matrix.\n    For the banded case, `Dfun` should return a matrix whose\n    rows contain the non-zero bands (starting with the lowest diagonal).\n    Thus, the return matrix `jac` from `Dfun` should have shape\n    ``(ml + mu + 1, len(y0))`` when ``ml >=0`` or ``mu >=0``.\n    The data in `jac` must be stored such that ``jac[i - j + mu, j]``\n    holds the derivative of the `i`th equation with respect to the `j`th\n    state variable.  If `col_deriv` is True, the transpose of this\n    `jac` must be returned.\n\n* **rtol, atol **: float, optional\n    The input parameters `rtol` and `atol` determine the error\n    control performed by the solver.  The solver will control the\n    vector, e, of estimated local errors in y, according to an\n    inequality of the form ``max-norm of (e / ewt) <= 1``,\n    where ewt is a vector of positive error weights computed as\n    ``ewt = rtol * abs(y) + atol``.\n    rtol and atol can be either vectors the same length as y or scalars.\n    Defaults to 1.49012e-8.\n\n* **tcrit **: ndarray, optional\n    Vector of critical points (e.g., singularities) where integration\n    care should be taken.\n\n* **h0 **: float, (0\n\n* **hmax **: float, (0\n\n* **hmin **: float, (0\n\n* **ixpr **: bool, optional\n    Whether to generate extra printing at method switches.\n\n* **mxstep **: int, (0\n\n* **mxhnil **: int, (0\n\n* **mxordn **: int, (0\n\n* **mxords **: int, (0\n\n* **solve_ivp **: solve an initial value problem for a system of ODEs\n\n* **ode **: a more object-oriented integrator based on VODE\n\n* **quad **: for finding the area under a curve\n\n* **pendulum acted on by gravity with friction can be written**: \n\n* **velocity ``omega(t) = theta'(t)``, we obtain the system**: \n\n* **in Python as**: \n\n* **>>> def pend(y, t, b, c)**: \n\n* **We assume the constants are `b` = 0.25 and `c` = 5.0**: \n\n* **0 <= `t` <= 10.  So our array of times is**: \n\n* **>>> plt.plot(t, sol[**: , 1], 'g', label='omega(t)')\n\n"
}