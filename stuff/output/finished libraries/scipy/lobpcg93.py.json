{
    "source file": "lobpcg93.py",
    "line number": "127",
    "func name": "lobpcg",
    "func arg": "(A, X, B, M, Y, tol, maxiter, largest, verbosityLevel, retLambdaHistory, retResidualNormsHistory)",
    "comments": "Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG)\n\nLOBPCG is a preconditioned eigensolver for large symmetric positive definite (SPD) generalized eigenproblems.\n\nParameters ---------- A : {sparse matrix, dense matrix, LinearOperator} The symmetric linear operator of the problem, usually a sparse matrix.\n\nOften called the \"stiffness matrix\". X : ndarray, float32 or float64 Initial approximation to the ``k`` eigenvectors (non-sparse). If `A` has ``shape=(n,n)`` then `X` should have shape ``shape=(n,k)``. B : {dense matrix, sparse matrix, LinearOperator}, optional The right hand side operator in a generalized eigenproblem. By default, ``B = Identity``.\n\nOften called the \"mass matrix\". M : {dense matrix, sparse matrix, LinearOperator}, optional Preconditioner to `A`; by default ``M = Identity``. `M` should approximate the inverse of `A`. Y : ndarray, float32 or float64, optional n-by-sizeY matrix of constraints (non-sparse), sizeY < n The iterations will be performed in the B-orthogonal complement of the column-space of Y. Y must be full rank. tol : scalar, optional Solver tolerance (stopping criterion). The default is ``tol=n*sqrt(eps)``. maxiter : int, optional Maximum number of iterations.\n\nThe default is ``maxiter = 20``. largest : bool, optional When True, solve for the largest eigenvalues, otherwise the smallest. verbosityLevel : int, optional Controls solver output.\n\nThe default is ``verbosityLevel=0``. retLambdaHistory : bool, optional Whether to return eigenvalue history.\n\nDefault is False. retResidualNormsHistory : bool, optional Whether to return history of residual norms.\n\nDefault is False.\n##### Returns\n* **w **: ndarray\n    Array of ``k`` eigenvalues\n\n* **v **: ndarray\n    An array of ``k`` eigenvectors.  `v` has the same shape as `X`.\n\n* **lambdas **: list of ndarray, optional\n    The eigenvalue history, if `retLambdaHistory` is True.\n\n* **rnorms **: list of ndarray, optional\n    The history of residual norms, if `retResidualNormsHistory` is True.\n\n* **https**: //arxiv.org/abs/0705.2626\n\n* **The convergence speed depends basically on two factors**: \n\n* **.. [1] A. V. Knyazev (2001),\n       Toward the Optimal Preconditioned Eigensolver**: Locally Optimal\n       Block Preconditioned Conjugate Gradient Method.\n       SIAM Journal on Scientific Computing 23, no. 2,\n       pp. 517-541. http\n\n* **.. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\n       (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\n       (BLOPEX) in hypre and PETSc. https**: //arxiv.org/abs/0705.2626\n\n* **.. [3] A. V. Knyazev's C and MATLAB implementations**: https\n\n* **Constraints**: \n\n* **Preconditioner in the inverse of A in this example**: \n\n* **The preconditiner must be defined by a function**: \n\n* **>>> def precond( x )**: \n\n* **The preconditioner function is passed to lobpcg as a `LinearOperator`**: \n\n* **Let us now solve the eigenvalue problem for the matrix A**: \n\n"
}