{
    "source file": "iterative87.py",
    "line number": "665",
    "func name": "qmr",
    "func arg": "(A, b, x0, tol, maxiter, M1, M2, callback, atol)",
    "comments": "Use Quasi-Minimal Residual iteration to solve ``Ax = b``.\n\nParameters ---------- A : {sparse matrix, dense matrix, LinearOperator} The real-valued N-by-N matrix of the linear system. Alternatively, ``A`` can be a linear operator which can produce ``Ax`` and ``A^T x`` using, e.g., ``scipy.sparse.linalg.LinearOperator``. b : {array, matrix} Right hand side of the linear system. Has shape (N,) or (N,1).\n##### Returns\n* **x **: {array, matrix}\n    The converged solution.\n\n* **info **: integer\n    Provides convergence information\n\n* **x0  **: {array, matrix}\n    Starting guess for the solution.\n\n* **tol, atol **: float, optional\n    Tolerances for convergence, ``norm(residual) <= max(tol*norm(b), atol)``.\n    The default for ``atol`` is ``'legacy'``, which emulates\n    a different legacy behavior.\n    .. warning\n\n* **maxiter **: integer\n    Maximum number of iterations.  Iteration will stop after maxiter\n    steps even if the specified tolerance has not been achieved.\n\n* **M1 **: {sparse matrix, dense matrix, LinearOperator}\n    Left preconditioner for A.\n\n* **M2 **: {sparse matrix, dense matrix, LinearOperator}\n    Right preconditioner for A. Used together with the left\n    preconditioner M1.  The matrix M1*A*M2 should have better\n    conditioned than A alone.\n\n* **callback **: function\n    User-supplied function to call after each iteration.  It is called\n    as callback(xk), where xk is the current solution vector.\n\n"
}