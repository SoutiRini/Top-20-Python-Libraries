{
    "source file": "_decomp_cossin.py",
    "line number": "12",
    "func name": "cossin",
    "func arg": "(X, p, q, separate, swap_sign, compute_u, compute_vh)",
    "comments": "Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.\n\nX is an ``(m, m)`` orthogonal/unitary matrix, partitioned as the following where upper left block has the shape of ``(p, q)``::\n\n\u250c\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u2510 \u2502 I\n\n0\n\n0 \u2502 0\n\n0\n\n0 \u2502 \u250c\n\n\n\n\n\n\n\n\n\n \u2510\n\n \u250c\n\n\n\n\n\n\n\n \u2510\u2502 0\n\nC\n\n0 \u2502 0 -S\n\n0 \u2502\u250c\n\n\n\n\n\n\n\n \u2510* \u2502 X11 \u2502 X12 \u2502\n\n \u2502 U1 \u2502\n\n\n\n\u2502\u2502 0\n\n0\n\n0 \u2502 0\n\n0 -I \u2502\u2502 V1 \u2502\n\n\n\n\u2502 \u2502 \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500 \u2502 = \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2502 \u2502 X21 \u2502 X22 \u2502\n\n \u2502\n\n\n\n\u2502 U2 \u2502\u2502 0\n\n0\n\n0 \u2502 I\n\n0\n\n0 \u2502\u2502\n\n\n\n\u2502 V2 \u2502 \u2514\n\n\n\n\n\n\n\n\n\n \u2518\n\n \u2514\n\n\n\n\n\n\n\n \u2518\u2502 0\n\nS\n\n0 \u2502 0\n\nC\n\n0 \u2502\u2514\n\n\n\n\n\n\n\n \u2518 \u2502 0\n\n0\n\nI \u2502 0\n\n0\n\n0 \u2502 \u2514\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \u2518\n\n``U1``, ``U2``, ``V1``, ``V2`` are square orthogonal/unitary matrices of dimensions ``(p,p)``, ``(m-p,m-p)``, ``(q,q)``, and ``(m-q,m-q)`` respectively, and ``C`` and ``S`` are ``(r, r)`` nonnegative diagonal matrices satisfying ``C^2 + S^2 = I`` where ``r = min(p, m-p, q, m-q)``.\n\nMoreover, the rank of the identity matrices are ``min(p, q)\n\n- r``, ``min(p, m\n\n- q)\n\n- r``, ``min(m\n\n- p, q)\n\n- r``, and ``min(m\n\n- p, m\n\n- q)\n\n- r`` respectively.\n\nX can be supplied either by itself and block specifications p, q or its subblocks in an iterable from which the shapes would be derived. See the examples below.\n\nParameters ---------- X : array_like, iterable complex unitary or real orthogonal matrix to be decomposed, or iterable of subblocks ``X11``, ``X12``, ``X21``, ``X22``, when ``p``, ``q`` are omitted. p : int, optional Number of rows of the upper left block ``X11``, used only when X is given as an array. q : int, optional Number of columns of the upper left block ``X11``, used only when X is given as an array. separate : bool, optional if ``True``, the low level components are returned instead of the matrix factors, i.e. ``(u1,u2)``, ``theta``, ``(v1h,v2h)`` instead of ``u``, ``cs``, ``vh``. swap_sign : bool, optional if ``True``, the ``-S``, ``-I`` block will be the bottom left, otherwise (by default) they will be in the upper right block. compute_u : bool, optional if ``False``, ``u`` won't be computed and an empty array is returned. compute_vh : bool, optional if ``False``, ``vh`` won't be computed and an empty array is returned.\n##### Returns\n* **u **: ndarray\n    When ``compute_u=True``, contains the block diagonal orthogonal/unitary\n    matrix consisting of the blocks ``U1`` (``p`` x ``p``) and ``U2``\n    (``m-p`` x ``m-p``) orthogonal/unitary matrices. If ``separate=True``,\n    this contains the tuple of ``(U1, U2)``.\n\n* **cs **: ndarray\n    The cosine-sine factor with the structure described above.\n     If ``separate=True``, this contains the ``theta`` array containing the\n     angles in radians.\n\n* **vh **: ndarray\n    When ``compute_vh=True`, contains the block diagonal orthogonal/unitary\n    matrix consisting of the blocks ``V1H`` (``q`` x ``q``) and ``V2H``\n    (``m-q`` x ``m-q``) orthogonal/unitary matrices. If ``separate=True``,\n    this contains the tuple of ``(V1H, V2H)``.\n\n* **>>> ue, cs, vdh = cossin((x[**: 2,\n\n* **.. [1] **: Brian D. Sutton. Computing the complete CS decomposition. Numer.\n       Algorithms, 50(1)\n\n"
}