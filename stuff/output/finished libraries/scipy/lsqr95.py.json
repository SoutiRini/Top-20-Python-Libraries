{
    "source file": "lsqr95.py",
    "line number": "96",
    "func name": "lsqr",
    "func arg": "(A, b, damp, atol, btol, conlim, iter_lim, show, calc_var, x0)",
    "comments": "Find the least-squares solution to a large, sparse, linear system of equations.\n\nThe function solves ``Ax = b``\n\nor\n\n``min ||Ax\n\n- b||^2`` or ``min ||Ax\n\n- b||^2 + d^2 ||x||^2``.\n\nThe matrix A may be square or rectangular (over-determined or under-determined), and may have any rank.\n\n::\n\n1. Unsymmetric equations --\n\n\n\nsolve\n\nA*x = b\n\n2. Linear least squares\n\n--\n\n\n\nsolve\n\nA*x = b in the least-squares sense\n\n3. Damped least squares\n\n--\n\n\n\nsolve\n\n(\n\n A\n\n\n\n)*x = ( b ) ( damp*I )\n\n\n\n ( 0 ) in the least-squares sense\n\nParameters ---------- A : {sparse matrix, ndarray, LinearOperator} Representation of an m-by-n matrix. Alternatively, ``A`` can be a linear operator which can produce ``Ax`` and ``A^T x`` using, e.g., ``scipy.sparse.linalg.LinearOperator``. b : array_like, shape (m,) Right-hand side vector ``b``. damp : float Damping coefficient. atol, btol : float, optional Stopping tolerances. If both are 1.0e-9 (say), the final residual norm should be accurate to about 9 digits.\n\n(The final x will usually have fewer correct digits, depending on cond(A) and the size of damp.) conlim : float, optional Another stopping tolerance.\n\nlsqr terminates if an estimate of ``cond(A)`` exceeds `conlim`.\n\nFor compatible systems ``Ax = b``, `conlim` could be as large as 1.0e+12 (say).\n\nFor least-squares problems, conlim should be less than 1.0e+8. Maximum precision can be obtained by setting ``atol = btol = conlim = zero``, but the number of iterations may then be excessive. iter_lim : int, optional Explicit limitation on number of iterations (for safety). show : bool, optional Display an iteration log. calc_var : bool, optional Whether to estimate diagonals of ``(A'A + damp^2*I)^{-1}``. x0 : array_like, shape (n,), optional Initial guess of x, if None zeros are used.\n\n.. versionadded:: 1.0.0\n##### Returns\n* **x **: ndarray of float\n    The final solution.\n\n* **istop **: int\n    Gives the reason for termination.\n    1 means x is an approximate solution to Ax = b.\n    2 means x approximately solves the least-squares problem.\n\n* **itn **: int\n    Iteration number upon termination.\n\n* **r1norm **: float\n    ``norm(r)``, where ``r = b - Ax``.\n\n* **r2norm **: float\n    ``sqrt( norm(r)^2  +  damp^2 * norm(x)^2 )``.  Equal to `r1norm` if\n    ``damp == 0``.\n\n* **anorm **: float\n    Estimate of Frobenius norm of ``Abar = [[A]; [damp*I]]``.\n\n* **acond **: float\n    Estimate of ``cond(Abar)``.\n\n* **arnorm **: float\n    Estimate of ``norm(A'*r - damp^2*x)``.\n\n* **xnorm **: float\n    ``norm(x)``\n\n* **var **: ndarray of float\n    If ``calc_var`` is True, estimates all diagonals of\n    ``(A'A)^{-1}`` (if ``damp == 0``) or more generally ``(A'A +\n    damp^2*I)^{-1}``.  This is well defined if A has full column\n    rank or ``damp > 0``.  (Not sure what var means if ``rank(A)\n    < n`` and ``damp = 0.``)\n\n* **one could proceed as follows**: 1. Compute a residual vector ``r0 = b - A*x0``.\n  2. Use LSQR to solve the system  ``A*dx = r0``.\n  3. Add the correction dx to obtain a final solution ``x = x0 + dx``.\n\n* **.. [1] C. C. Paige and M. A. Saunders (1982a).\n       \"LSQR**: An algorithm for sparse linear equations and\n       sparse least squares\", ACM TOMS 8(1), 43-71.\n\n* **.. [2] C. C. Paige and M. A. Saunders (1982b).\n       \"Algorithm 583.  LSQR**: Sparse linear equations and least\n       squares problems\", ACM TOMS 8(2), 195-209.\n\n* **>>> x, istop, itn, normr = lsqr(A, b)[**: 4]\n\n* **The next example has a non-trivial solution**: \n\n* **>>> x, istop, itn, r1norm = lsqr(A, b)[**: 4]\n\n* **solution for the equation**: \n\n"
}