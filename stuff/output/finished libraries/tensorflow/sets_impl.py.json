{
    "source file": "sets_impl.py",
    "line number": "294",
    "func name": "set_union",
    "func arg": "(a, b, validate_indices)",
    "comments": "Compute set union of elements in last dimension of `a` and `b`.\n\nAll but the last dimension of `a` and `b` must match.\n\nExample:\n\n```python import tensorflow as tf import collections\n\n# [[{1, 2}, {3}], [{4}, {5, 6}]] a = collections.OrderedDict([ ((0, 0, 0), 1), ((0, 0, 1), 2), ((0, 1, 0), 3), ((1, 0, 0), 4), ((1, 1, 0), 5), ((1, 1, 1), 6), ]) a = tf.sparse.SparseTensor(list(a.keys()), list(a.values()), dense_shape=[2, 2, 2])\n\n# [[{1, 3}, {2}], [{4, 5}, {5, 6, 7, 8}]] b = collections.OrderedDict([ ((0, 0, 0), 1), ((0, 0, 1), 3), ((0, 1, 0), 2), ((1, 0, 0), 4), ((1, 0, 1), 5), ((1, 1, 0), 5), ((1, 1, 1), 6), ((1, 1, 2), 7), ((1, 1, 3), 8), ]) b = tf.sparse.SparseTensor(list(b.keys()), list(b.values()), dense_shape=[2, 2, 4])\n\n# `set_union` is applied to each aligned pair of sets. tf.sets.union(a, b)\n\n# The result will be a equivalent to either of: # # np.array([[{1, 2, 3}, {2, 3}], [{4, 5}, {5, 6, 7, 8}]]) # # collections.OrderedDict([ #\n\n\n\n ((0, 0, 0), 1), #\n\n\n\n ((0, 0, 1), 2), #\n\n\n\n ((0, 0, 2), 3), #\n\n\n\n ((0, 1, 0), 2), #\n\n\n\n ((0, 1, 1), 3), #\n\n\n\n ((1, 0, 0), 4), #\n\n\n\n ((1, 0, 1), 5), #\n\n\n\n ((1, 1, 0), 5), #\n\n\n\n ((1, 1, 1), 6), #\n\n\n\n ((1, 1, 2), 7), #\n\n\n\n ((1, 1, 3), 8), # ]) ```\n##### Args\n* **a**: `Tensor` or `SparseTensor` of the same type as `b`. If sparse, indices\n    must be sorted in row-major order.\n\n* **b**: `Tensor` or `SparseTensor` of the same type as `a`. If sparse, indices\n    must be sorted in row-major order.\n\n* **validate_indices**: Whether to validate the order and range of sparse indices\n   in `a` and `b`.\n\n##### Returns\n"
}