{
    "source file": "transpiler.py",
    "line number": "38",
    "func name": "_wrap_into_factory",
    "func arg": "(nodes, entity_name, inner_factory_name, outer_factory_name, closure_vars, factory_args, future_features)",
    "comments": "Wraps an AST into the body of a factory with consistent lexical context.\n\nThe AST is expected to define some symbol with a name given by `entity_name`.\n\nThis mechanism ensures that the resulting transformed entity has lexical scoping identical to that of the source entity, while allowing extra parametrization.\n\nTwo nested factories achieve the following:\n\n1. The inner factory dynamically creates the entity represented by `nodes`. 2. The inner factory is parametrized by a custom set of arguments. 3. The inner factory has a closure identical to that of the transformed entity. 4. The inner factory has local variables named like `args`, which `nodes` may use as additional parameters. 5. The inner factory returns the variables given by `entity_name`. 6. The outer factory is niladic. 7. The outer factory has no closure. 8. The outer factory creates the necessary lexical scope for the inner factory, so that the loaded code has the given configuration for closure/globals. 9. The outer factory returns the inner factory.\n\nRoughly speaking, the following code is generated:\n\nfrom __future__ import future_feature_1 from __future__ import future_feature_2 ...\n\ndef outer_factory(): closure_var_1 = None closure_var_2 = None ...\n\ndef inner_factory(arg_1, arg_2, ...): <<nodes>> return entity\n\nreturn inner_factory\n\nThe lexical scoping is created using dummy symbol declarations which create local fariables in the body of the outer factory, so that the Python parser correctly marks them as free non-global variables upon load (that is, it creates cell slots for each symbol. Thes symbols are initialized with None, but their values are not expected to be used; instead, the caller is expected to replace them with the cells of the source entity. For more details, see: https://docs.python.org/3/reference/executionmodel.html#binding-of-names\n##### Args\n* **nodes**: Tuple[ast.AST], the source code to wrap.\n\n* **entity_name**: Union[Text, ast.AST], the name of the principal entity that\n  `nodes` define.\n\n* **inner_factory_name**: Text, the name of the inner factory.\n\n* **outer_factory_name**: Text, the name of the outer factory.\n\n* **closure_vars**: Iterable[Text], names of the closure variables for the inner\n  factory.\n\n* **factory_args**: Iterable[Text], names of additional arguments for the\n  inner factory. Useful to configure variables that the converted code can\n  use. Typically, these are modules.\n\n* **future_features**: Iterable[Text], names of future statements to associate the\n  code with.\n\n##### Returns\n"
}