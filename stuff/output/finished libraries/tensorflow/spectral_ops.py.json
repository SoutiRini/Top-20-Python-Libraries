{
    "source file": "spectral_ops.py",
    "line number": "375",
    "func name": "inverse_mdct",
    "func arg": "(mdcts, window_fn, norm, name)",
    "comments": "Computes the inverse modified DCT of `mdcts`.\n\nTo reconstruct an original waveform, the same window function should be used with `mdct` and `inverse_mdct`.\n\nExample usage:\n\n>>> @tf.function ... def compare_round_trip(): ...\n\n samples = 1000 ...\n\n frame_length = 400 ...\n\n halflen = frame_length // 2 ...\n\n waveform = tf.random.normal(dtype=tf.float32, shape=[samples]) ...\n\n waveform_pad = tf.pad(waveform, [[halflen, 0],]) ...\n\n mdct = tf.signal.mdct(waveform_pad, frame_length, pad_end=True, ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n window_fn=tf.signal.vorbis_window) ...\n\n inverse_mdct = tf.signal.inverse_mdct(mdct, ...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n window_fn=tf.signal.vorbis_window) ...\n\n inverse_mdct = inverse_mdct[halflen: halflen + samples] ...\n\n return waveform, inverse_mdct >>> waveform, inverse_mdct = compare_round_trip() >>> np.allclose(waveform.numpy(), inverse_mdct.numpy(), rtol=1e-3, atol=1e-4) True\n\nImplemented with TPU/GPU-compatible ops and supports gradients.\n##### Args\n* **mdcts**: A `float32`/`float64` `[..., frames, frame_length // 2]`\n  `Tensor` of MDCT bins representing a batch of `frame_length // 2`-point\n  MDCTs.\n\n* **window_fn**: A callable that takes a frame_length and a `dtype` keyword\n  argument and returns a `[frame_length]` `Tensor` of samples in the\n  provided datatype. If set to `None`, a rectangular window with a scale of\n  1/sqrt(2) is used. For perfect reconstruction of a signal from `mdct`\n  followed by `inverse_mdct`, please use `tf.signal.vorbis_window`,\n  `tf.signal.kaiser_bessel_derived_window` or `None`. If using another\n  window function, make sure that w[n]^2 + w[n + frame_length // 2]^2 = 1\n  and w[n] = w[frame_length - n - 1] for n = 0,...,frame_length // 2 - 1 to\n  achieve perfect reconstruction.\n\n* **norm**: If \"ortho\", orthonormal inverse DCT4 is performed, if it is None,\n  a regular dct4 followed by scaling of `1/frame_length` is performed.\n\n* **name**: An optional name for the operation.\n\n##### Returns\n"
}