{
    "source file": "sparse_ops.py",
    "line number": "2847",
    "func name": "_take_many_sparse_from_tensors_map",
    "func arg": "(sparse_map_op, sparse_handles, rank, name)",
    "comments": "Read `SparseTensors` from a `SparseTensorsMap` and concatenate them.\n\nThe input `sparse_handles` must be a string matrix of shape `[N, 1]` where `N` is the minibatch size and the rows correspond to packed outputs of `add_sparse_to_tensors_map`.\n\nThe ranks of the original `SparseTensor` objects must all match.\n\nWhen the final `SparseTensor` is created, it has rank one higher than the ranks of the incoming `SparseTensor` objects (they have been concatenated along a new row dimension).\n\nThe output `SparseTensor` object's shape values for all dimensions but the first are the max across the input `SparseTensor` objects' shape values for the corresponding dimensions.\n\nIts first shape value is `N`, the minibatch size.\n\nThe input `SparseTensor` objects' indices are assumed ordered in standard lexicographic order.\n\nIf this is not the case, after this step run `sparse.reorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2, 3]` matrix representing two original `SparseTensor` objects:\n\nindex = [ 0] [10] [20] values = [1, 2, 3] shape = [50]\n\nand\n\nindex = [ 2] [10] values = [4, 5] shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\nindex = [0\n\n0] [0 10] [0 20] [1\n\n2] [1 10] values = [1, 2, 3, 4, 5] shape = [2 50]\n##### Args\n* **sparse_map_op**: The `Operation` that created the original handles.\n  Usually this is, e.g., `add_sparse_to_tensors_map(...).op`.\n\n* **sparse_handles**: 2-D `Tensor` of type `string` of shape `[N, 1]`.\n  The serialized and packed `SparseTensor` objects.\n\n* **rank**: (optional) Python int, the rank of the `SparseTensor` objects.\n\n* **name**: A name prefix for the returned tensors (optional)\n\n##### Returns\n"
}