{
    "source file": "shape_ops.py",
    "line number": "60",
    "func name": "frame",
    "func arg": "(signal, frame_length, frame_step, pad_end, pad_value, axis, name)",
    "comments": "Expands `signal`'s `axis` dimension into frames of `frame_length`.\n\nSlides a window of size `frame_length` over `signal`'s `axis` dimension with a stride of `frame_step`, replacing the `axis` dimension with `[frames, frame_length]` frames.\n\nIf `pad_end` is True, window positions that are past the end of the `axis` dimension are padded with `pad_value` until the window moves fully past the end of the dimension. Otherwise, only window positions that fully overlap the `axis` dimension are produced.\n\nFor example:\n\n>>> # A batch size 3 tensor of 9152 audio samples. >>> audio = tf.random.normal([3, 9152]) >>> >>> # Compute overlapping frames of length 512 with a step of 180 (frames overlap >>> # by 332 samples). By default, only 49 frames are generated since a frame >>> # with start position j*180 for j > 48 would overhang the end. >>> frames = tf.signal.frame(audio, 512, 180) >>> frames.shape.assert_is_compatible_with([3, 49, 512]) >>> >>> # When pad_end is enabled, the final two frames are kept (padded with zeros). >>> frames = tf.signal.frame(audio, 512, 180, pad_end=True) >>> frames.shape.assert_is_compatible_with([3, 51, 512])\n\nIf the dimension along `axis` is N, and `pad_end=False`, the number of frames can be computed by: ```python num_frames = 1 + (N\n\n- frame_size) // frame_step ``` If `pad_end=True`, the number of frames can be computed by: ```python num_frames = -(-N // frame_step) # ceiling division ```\n##### Args\n* **signal**: A `[..., samples, ...]` `Tensor`. The rank and dimensions\n  may be unknown. Rank must be at least 1.\n\n* **frame_length**: The frame length in samples. An integer or scalar `Tensor`.\n\n* **frame_step**: The frame hop size in samples. An integer or scalar `Tensor`.\n\n* **pad_end**: Whether to pad the end of `signal` with `pad_value`.\n\n* **pad_value**: An optional scalar `Tensor` to use where the input signal\n  does not exist when `pad_end` is True.\n\n* **axis**: A scalar integer `Tensor` indicating the axis to frame. Defaults to\n  the last axis. Supports negative values for indexing from the end.\n\n* **name**: An optional name for the operation.\n\n##### Returns\n"
}