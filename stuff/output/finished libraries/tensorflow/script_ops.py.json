{
    "source file": "script_ops.py",
    "line number": "566",
    "func name": "numpy_function",
    "func arg": "(func, inp, Tout, name)",
    "comments": "Wraps a python function and uses it as a TensorFlow op.\n\nGiven a python function `func` wrap this function as an operation in a TensorFlow function. `func` must take numpy arrays as its arguments and return numpy arrays as its outputs.\n\nThe following example creates a TensorFlow graph with `np.sinh()` as an operation in the graph:\n\n>>> def my_numpy_func(x): ...\n\n # x will be a numpy array with the contents of the input to the ...\n\n # tf.function ...\n\n return np.sinh(x) >>> @tf.function(input_signature=[tf.TensorSpec(None, tf.float32)]) ... def tf_function(input): ...\n\n y = tf.numpy_function(my_numpy_func, [input], tf.float32) ...\n\n return y * y >>> tf_function(tf.constant(1.)) <tf.Tensor: shape=(), dtype=float32, numpy=1.3810978>\n\nComparison to `tf.py_function`: `tf.py_function` and `tf.numpy_function` are very similar, except that `tf.numpy_function` takes numpy arrays, and not `tf.Tensor`s. If you want the function to contain `tf.Tensors`, and have any TensorFlow operations executed in the function be differentiable, please use `tf.py_function`.\n\nNote: The `tf.numpy_function` operation has the following known limitations:\n\n* The body of the function (i.e. `func`) will not be serialized in a `tf.SavedModel`. Therefore, you should not use this function if you need to serialize your model and restore it in a different environment.\n\n* The operation must run in the same address space as the Python program that calls `tf.numpy_function()`. If you are using distributed TensorFlow, you must run a `tf.distribute.Server` in the same process as the program that calls `tf.numpy_function`\n\nyou must pin the created operation to a device in that server (e.g. using `with tf.device():`).\n\n* Since the function takes numpy arrays, you cannot take gradients through a numpy_function. If you require something that is differentiable, please consider using tf.py_function.\n\n* The resulting function is assumed stateful and will never be optimized.\n##### Args\n* **func**: A Python function, which accepts `numpy.ndarray` objects as arguments\n  and returns a list of `numpy.ndarray` objects (or a single\n  `numpy.ndarray`). This function must accept as many arguments as there are\n  tensors in `inp`, and these argument types will match the corresponding\n  `tf.Tensor` objects in `inp`. The returns `numpy.ndarray`s must match the\n  number and types defined `Tout`.\n  Important Note\n\n* **inp**: A list of `tf.Tensor` objects.\n\n* **Tout**: A list or tuple of tensorflow data types or a single tensorflow data\n  type if there is only one, indicating what `func` returns.\n\n* **name**: (Optional) A name for the operation.\n\n##### Returns\n"
}