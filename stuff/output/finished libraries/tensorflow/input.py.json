{
    "source file": "input.py",
    "line number": "1517",
    "func name": "maybe_shuffle_batch_join",
    "func arg": "(tensors_list, batch_size, capacity, min_after_dequeue, keep_input, seed, enqueue_many, shapes, allow_smaller_final_batch, shared_name, name)",
    "comments": "Create batches by randomly shuffling conditionally-enqueued tensors.\n\nSee docstring in `shuffle_batch_join` for more details.\n##### Args\n* **tensors_list**: A list of tuples or dictionaries of tensors to enqueue.\n\n* **batch_size**: An integer. The new batch size pulled from the queue.\n\n* **capacity**: An integer. The maximum number of elements in the queue.\n\n* **min_after_dequeue**: Minimum number elements in the queue after a\n  dequeue, used to ensure a level of mixing of elements.\n\n* **keep_input**: A `bool` Tensor.  This tensor controls whether the input is\n  added to the queue or not.  If it is a scalar and evaluates `True`, then\n  `tensors` are all added to the queue. If it is a vector and `enqueue_many`\n  is `True`, then each example is added to the queue only if the\n  corresponding value in `keep_input` is `True`. This tensor essentially\n  acts as a filtering mechanism.\n\n* **seed**: Seed for the random shuffling within the queue.\n\n* **enqueue_many**: Whether each tensor in `tensor_list_list` is a single\n  example.\n\n* **shapes**: (Optional) The shapes for each example.  Defaults to the\n  inferred shapes for `tensors_list[i]`.\n\n* **allow_smaller_final_batch**: (Optional) Boolean. If `True`, allow the final\n  batch to be smaller if there are insufficient items left in the queue.\n\n* **shared_name**: (optional). If set, this queue will be shared under the given\n  name across multiple sessions.\n\n* **name**: (Optional) A name for the operations.\n\n##### Returns\n"
}