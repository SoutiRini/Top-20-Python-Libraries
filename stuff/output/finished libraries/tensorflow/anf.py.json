{
    "source file": "anf.py",
    "line number": "527",
    "func name": "transform",
    "func arg": "(node, ctx, config)",
    "comments": "Converts the given node to A-normal form (ANF).\n\nThe general idea of A-normal form: https://en.wikipedia.org/wiki/A-normal_form\n\nThe specific converters used here are based on Python AST semantics as documented at https://greentreesnakes.readthedocs.io/en/latest/.\n\nWhat exactly should be considered A-normal form for any given programming language is not completely obvious.\n\nThe transformation defined here is therefore configurable as to which syntax to replace with a fresh variable and which to leave be.\n\nThe configuration is intentionally flexible enough to define very precise variable insertion transformations, should that be desired.\n\nThe configuration is a list of syntax rules, each of which is a 2-tuple:\n\n- An `ASTEdgePattern` (which see) defining a type of AST edge, and\n\n- Whether to transform children of such edges. The special object `anf.ANY` may be used as a pattern that matches all edges.\n\nEach replacement directive is one of three possible things:\n\n- The object `anf.REPLACE`, meaning \"Replace this child node with a variable\",\n\n- The object `anf.LEAVE`, meaning \"Do not replace this child node with a variable\", or\n\n- A Python callable.\n\nIf a callable, it is called with the parent node, the field name, and the child node, and must compute a boolean indicating whether to transform the child node or not.\n\nThe callable is free to use whatever context information it chooses.\n\nThe callable may be invoked more than once on the same link, and must produce the same answer each time.\n\nThe syntax rules are tested in order, and the first match governs.\n\nIf no rule matches, the node is not transformed.\n\nThe above rules notwithstanding,\n\n- Variable references are never replaced with (fresh) variables, as that would accomplish nothing.\n\n- The left-hand children of Assign and AugAssign nodes, and the children of Del nodes, are never replaced with variables, as that would break their semantics.\n\n- The right-hand children of Assign nodes are never replaced with variables, as the original assignment would still have to be present in the result to define the new variable.\n\n(That is, there's no point in transforming `x = sin(y)` into `tmp = sin(y); x = tmp`.)\n\n- The right-hand children of AugAssign nodes are never replaced with variables either, but only because the difference from Assign was considered a potential source of confusion (and it would have been slightly awkward in the code to treat the RHS differently than the LHS).\n\n- Various special-purpose AST nodes are not exposed to the configuration, lest the transform produce invalid syntax like, e.g., `tmp = +; x = 1 tmp 2`.\n\nFor example, the configuration ```python [(anf.ASTEdgePattern(anf.ANY, anf.ANY, gast.expr), anf.REPLACE)] ``` gives explicit fresh names to all expressions regardless of context (except as outlined above), whereas ```python [(anf.ASTEdgePattern(gast.If, \"test\", anf.ANY), anf.REPLACE)] ``` only transforms the conditionals of `if` statements (but not, e.g., `while`).\n\nIf no configuration is supplied, the default behavior is to transform all expressions except literal constants, which is defined as a configuration as ```python # For Python 3, and gast library versions before 0.3 literals = (gast.Num, gast.Str, gast.Bytes, gast.NameConstant) [(anf.ASTEdgePattern(anf.ANY, anf.ANY, literals), anf.LEAVE), (anf.ASTEdgePattern(anf.ANY, anf.ANY, gast.expr), anf.REPLACE)] ```\n##### Args\n* **node**: The node to transform.\n\n* **ctx**: transformer.EntityInfo.  TODO(mdan)\n\n* **config**: Optional ANF configuration.  If omitted, ANF replaces all expression\n  expect literal constants.\n\n"
}