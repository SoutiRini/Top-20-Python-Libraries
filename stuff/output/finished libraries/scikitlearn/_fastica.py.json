{
    "source file": "_fastica.py",
    "line number": "151",
    "func name": "fastica",
    "func arg": "(X, n_components)",
    "comments": "Perform Fast Independent Component Analysis.\n\nRead more in the :ref:`User Guide <ICA>`.\n\nParameters ---------- X : array-like, shape (n_samples, n_features) Training vector, where n_samples is the number of samples and n_features is the number of features.\n\nn_components : int, optional Number of components to extract. If None no dimension reduction is performed.\n\nalgorithm : {'parallel', 'deflation'}, optional Apply a parallel or deflational FASTICA algorithm.\n\nwhiten : boolean, optional If True perform an initial whitening of the data. If False, the data is assumed to have already been preprocessed: it should be centered, normed and white. Otherwise you will get incorrect results. In this case the parameter n_components will be ignored.\n\nfun : string or function, optional. Default: 'logcosh' The functional form of the G function used in the approximation to neg-entropy. Could be either 'logcosh', 'exp', or 'cube'. You can also provide your own function. It should return a tuple containing the value of the function, and of its derivative, in the point. The derivative should be averaged along its last dimension. Example:\n\ndef my_g(x): return x ** 3, np.mean(3 * x ** 2, axis=-1)\n\nfun_args : dictionary, optional Arguments to send to the functional form. If empty or None and if fun='logcosh', fun_args will take value {'alpha' : 1.0}\n\nmax_iter : int, optional Maximum number of iterations to perform.\n\ntol : float, optional A positive scalar giving the tolerance at which the un-mixing matrix is considered to have converged.\n\nw_init : (n_components, n_components) array, optional Initial un-mixing array of dimension (n.comp,n.comp). If None (default) then an array of normal r.v.'s is used.\n\nrandom_state : int, RandomState instance, default=None Used to initialize ``w_init`` when not specified, with a normal distribution. Pass an int, for reproducible results across multiple function calls. See :term:`Glossary <random_state>`.\n\nreturn_X_mean : bool, optional If True, X_mean is returned too.\n\ncompute_sources : bool, optional If False, sources are not computed, but only the rotation matrix. This can save memory when working with big data. Defaults to True.\n\nreturn_n_iter : bool, optional Whether or not to return the number of iterations.\n##### Returns\n* **K **: array, shape (n_components, n_features) | None.\n    If whiten is 'True', K is the pre-whitening matrix that projects data\n    onto the first n_components principal components. If whiten is 'False',\n    K is 'None'.\n\n* **W **: array, shape (n_components, n_components)\n    The square matrix that unmixes the data after whitening.\n    The mixing matrix is the pseudo-inverse of matrix ``W K``\n    if K is not None, else it is the inverse of W.\n\n* **S **: array, shape (n_samples, n_components) | None\n    Estimated source matrix\n\n* **X_mean **: array, shape (n_features, )\n    The mean over features. Returned only if return_X_mean is True.\n\n* **n_iter **: int\n    If the algorithm is \"deflation\", n_iter is the\n    maximum number of iterations run across all components. Else\n    they are just the number of iterations taken to converge. This is\n    returned only when return_n_iter is set to `True`.\n\n* **Implemented using FastICA**: \n\n* ***A. Hyvarinen and E. Oja, Independent Component Analysis**: \n\n"
}