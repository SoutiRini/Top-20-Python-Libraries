{
    "source file": "_nmf.py",
    "line number": "845",
    "func name": "non_negative_factorization",
    "func arg": "(X, W, H, n_components)",
    "comments": "Compute Non-negative Matrix Factorization (NMF)\n\nFind two non-negative matrices (W, H) whose product approximates the non- negative matrix X. This factorization can be used for example for dimensionality reduction, source separation or topic extraction.\n\nThe objective function is::\n\n0.5 * ||X\n\n- WH||_Fro^2 + alpha * l1_ratio * ||vec(W)||_1 + alpha * l1_ratio * ||vec(H)||_1 + 0.5 * alpha * (1\n\n- l1_ratio) * ||W||_Fro^2 + 0.5 * alpha * (1\n\n- l1_ratio) * ||H||_Fro^2\n\nWhere::\n\n||A||_Fro^2 = \\sum_{i,j} A_{ij}^2 (Frobenius norm) ||vec(A)||_1 = \\sum_{i,j} abs(A_{ij}) (Elementwise L1 norm)\n\nFor multiplicative-update ('mu') solver, the Frobenius norm (0.5 * ||X\n\n- WH||_Fro^2) can be changed into another beta-divergence loss, by changing the beta_loss parameter.\n\nThe objective function is minimized with an alternating minimization of W and H. If H is given and update_H=False, it solves for W only.\n\nParameters ---------- X : array-like, shape (n_samples, n_features) Constant matrix.\n\nW : array-like, shape (n_samples, n_components) If init='custom', it is used as initial guess for the solution.\n\nH : array-like, shape (n_components, n_features) If init='custom', it is used as initial guess for the solution. If update_H=False, it is used as a constant, to solve for W only.\n\nn_components : integer Number of components, if n_components is not set all features are kept.\n\ninit : None | 'random' | 'nndsvd' | 'nndsvda' | 'nndsvdar' | 'custom' Method used to initialize the procedure. Default: None.\n\nValid options:\n\n- None: 'nndsvd' if n_components < n_features, otherwise 'random'.\n\n- 'random': non-negative random matrices, scaled with: sqrt(X.mean() / n_components)\n\n- 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD) initialization (better for sparseness)\n\n- 'nndsvda': NNDSVD with zeros filled with the average of X (better when sparsity is not desired)\n\n- 'nndsvdar': NNDSVD with zeros filled with small random values (generally faster, less accurate alternative to NNDSVDa for when sparsity is not desired)\n\n- 'custom': use custom matrices W and H if `update_H=True`. If `update_H=False`, then only custom matrix H is used.\n\n.. versionchanged:: 0.23 The default value of `init` changed from 'random' to None in 0.23.\n\nupdate_H : boolean, default: True Set to True, both W and H will be estimated from initial guesses. Set to False, only W will be estimated.\n\nsolver : 'cd' | 'mu' Numerical solver to use:\n\n- 'cd' is a Coordinate Descent solver that uses Fast Hierarchical Alternating Least Squares (Fast HALS).\n\n- 'mu' is a Multiplicative Update solver.\n\n.. versionadded:: 0.17 Coordinate Descent solver.\n\n.. versionadded:: 0.19 Multiplicative Update solver.\n\nbeta_loss : float or string, default 'frobenius' String must be in {'frobenius', 'kullback-leibler', 'itakura-saito'}. Beta divergence to be minimized, measuring the distance between X and the dot product WH. Note that values different from 'frobenius' (or 2) and 'kullback-leibler' (or 1) lead to significantly slower fits. Note that for beta_loss <= 0 (or 'itakura-saito'), the input matrix X cannot contain zeros. Used only in 'mu' solver.\n\n.. versionadded:: 0.19\n\ntol : float, default: 1e-4 Tolerance of the stopping condition.\n\nmax_iter : integer, default: 200 Maximum number of iterations before timing out.\n\nalpha : double, default: 0. Constant that multiplies the regularization terms.\n\nl1_ratio : double, default: 0. The regularization mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1_ratio = 1 it is an elementwise L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.\n\nregularization : 'both' | 'components' | 'transformation' | None Select whether the regularization affects the components (H), the transformation (W), both or none of them.\n\nrandom_state : int, RandomState instance, default=None Used for NMF initialisation (when ``init`` == 'nndsvdar' or 'random'), and in Coordinate Descent. Pass an int for reproducible results across multiple function calls. See :term:`Glossary <random_state>`.\n\nverbose : integer, default: 0 The verbosity level.\n\nshuffle : boolean, default: False If true, randomize the order of coordinates in the CD solver.\n##### Returns\n* **W **: array-like, shape (n_samples, n_components)\n    Solution to the non-negative least squares problem.\n\n* **H **: array-like, shape (n_components, n_features)\n    Solution to the non-negative least squares problem.\n\n* **n_iter **: int\n    Actual number of iterations.\n\n* **computer sciences 92.3**: 708-721, 2009.\n\n"
}