{
    "source file": "class_weight.py",
    "line number": "76",
    "func name": "compute_sample_weight",
    "func arg": "(class_weight, y)",
    "comments": "Estimate sample weights by class for unbalanced datasets.\n\nParameters ---------- class_weight : dict, list of dicts, \"balanced\", or None, optional Weights associated with classes in the form ``{class_label: weight}``. If not given, all classes are supposed to have weight one. For multi-output problems, a list of dicts can be provided in the same order as the columns of y.\n\nNote that for multioutput (including multilabel) weights should be defined for each class of every column in its own dict. For example, for four-class multilabel classification weights should be [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of [{1:1}, {2:5}, {3:1}, {4:1}].\n\nThe \"balanced\" mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data: ``n_samples / (n_classes * np.bincount(y))``.\n\nFor multi-output, the weights of each column of y will be multiplied.\n\ny : array-like of shape (n_samples,) or (n_samples, n_outputs) Array of original class labels per sample.\n\nindices : array-like, shape (n_subsample,), or None Array of indices to be used in a subsample. Can be of length less than n_samples in the case of a subsample, or equal to n_samples in the case of a bootstrap subsample with repeated indices. If None, the sample weight will be calculated over the full sample. Only \"balanced\" is supported for class_weight if this is provided.\n##### Returns\n* **sample_weight_vect **: ndarray, shape (n_samples,)\n    Array with sample weights as applied to the original y\n\n"
}