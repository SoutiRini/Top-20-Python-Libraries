{
    "source file": "_graph.py",
    "line number": "118",
    "func name": "radius_neighbors_graph",
    "func arg": "(X, radius)",
    "comments": "Computes the (weighted) graph of Neighbors for points in X\n\nNeighborhoods are restricted the points at a distance lower than radius.\n\nRead more in the :ref:`User Guide <unsupervised_neighbors>`.\n\nParameters ---------- X : array-like of shape (n_samples, n_features) or BallTree Sample data, in the form of a numpy array or a precomputed :class:`BallTree`.\n\nradius : float Radius of neighborhoods.\n\nmode : {'connectivity', 'distance'}, default='connectivity' Type of returned matrix: 'connectivity' will return the connectivity matrix with ones and zeros, and 'distance' will return the distances between neighbors according to the given metric.\n\nmetric : str, default='minkowski' The distance metric used to calculate the neighbors within a given radius for each sample point. The DistanceMetric class gives a list of available metrics. The default distance is 'euclidean' ('minkowski' metric with the param equal to 2.)\n\np : int, default=2 Power parameter for the Minkowski metric. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.\n\nmetric_params : dict, default=None additional keyword arguments for the metric function.\n\ninclude_self : bool or 'auto', default=False Whether or not to mark each sample as the first nearest neighbor to itself. If 'auto', then True is used for mode='connectivity' and False for mode='distance'.\n\nn_jobs : int, default=None The number of parallel jobs to run for neighbors search. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.\n##### Returns\n* **A **: sparse matrix of shape (n_samples, n_samples)\n    Graph where A[i, j] is assigned the weight of edge that connects\n    i to j. The matrix is of CSR format.\n\n"
}