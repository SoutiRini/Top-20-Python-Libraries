{
    "source file": "_dict_learning.py",
    "line number": "624",
    "func name": "dict_learning_online",
    "func arg": "(X, n_components)",
    "comments": "Solves a dictionary learning matrix factorization problem online.\n\nFinds the best dictionary and the corresponding sparse code for approximating the data matrix X by solving::\n\n(U^*, V^*) = argmin 0.5 || X\n\n- U V ||_2^2 + alpha * || U ||_1 (U,V) with || V_k ||_2 = 1 for all\n\n0 <= k < n_components\n\nwhere V is the dictionary and U is the sparse code. This is accomplished by repeatedly iterating over mini-batches by slicing the input data.\n\nRead more in the :ref:`User Guide <DictionaryLearning>`.\n\nParameters ---------- X : ndarray of shape (n_samples, n_features) Data matrix.\n\nn_components : int, default=2 Number of dictionary atoms to extract.\n\nalpha : float, default=1 Sparsity controlling parameter.\n\nn_iter : int, default=100 Number of mini-batch iterations to perform.\n\nreturn_code : bool, default = True Whether to also return the code U or just the dictionary V.\n\ndict_init : ndarray of shape (n_components, n_features), default = None Initial value for the dictionary for warm restart scenarios.\n\ncallback : callable, default=None callable that gets invoked every five iterations\n\nbatch_size : int, default=3 The number of samples to take in each batch.\n\nverbose : bool, default=False To control the verbosity of the procedure.\n\nshuffle : bool, default=True Whether to shuffle the data before splitting it in batches.\n\nn_jobs : int, default=None Number of parallel jobs to run. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.\n\nmethod : {'lars', 'cd'}, default='lars' lars: uses the least angle regression method to solve the lasso problem (linear_model.lars_path) cd: uses the coordinate descent method to compute the Lasso solution (linear_model.Lasso). Lars will be faster if the estimated components are sparse.\n\niter_offset : int, default=0 Number of previous iterations completed on the dictionary used for initialization.\n\nrandom_state : int or RandomState instance, default=None Used for initializing the dictionary when ``dict_init`` is not specified, randomly shuffling the data when ``shuffle`` is set to ``True``, and updating the dictionary. Pass an int for reproducible results across multiple function calls. See :term:`Glossary <random_state>`.\n\nreturn_inner_stats : bool, default=False Return the inner statistics A (dictionary covariance) and B (data approximation). Useful to restart the algorithm in an online setting. If return_inner_stats is True, return_code is ignored\n\ninner_stats : tuple of (A, B) ndarrays, default=None Inner sufficient statistics that are kept by the algorithm. Passing them at initialization is useful in online settings, to avoid losing the history of the evolution. A (n_components, n_components) is the dictionary covariance matrix. B (n_features, n_components) is the data approximation matrix\n\nreturn_n_iter : bool, default=False Whether or not to return the number of iterations.\n\npositive_dict : bool, default=False Whether to enforce positivity when finding the dictionary.\n\n.. versionadded:: 0.20\n\npositive_code : bool, default=False Whether to enforce positivity when finding the code.\n\n.. versionadded:: 0.20\n\nmethod_max_iter : int, default=1000 Maximum number of iterations to perform when solving the lasso problem.\n\n.. versionadded:: 0.22\n##### Returns\n* **code **: ndarray of shape (n_samples, n_components),\n    the sparse code (only returned if `return_code=True`)\n\n* **dictionary **: ndarray of shape (n_components, n_features),\n    the solutions to the dictionary learning problem\n\n* **n_iter **: int\n    Number of iterations run. Returned only if `return_n_iter` is\n    set to `True`.\n\n"
}