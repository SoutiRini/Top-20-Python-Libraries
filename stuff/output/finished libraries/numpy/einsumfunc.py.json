{
    "source file": "einsumfunc.py",
    "line number": "998",
    "func name": "einsum",
    "func arg": "(**kwargs)",
    "comments": "einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe', optimize=False)\n\nEvaluates the Einstein summation convention on the operands.\n\nUsing the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In *implicit* mode `einsum` computes these values.\n\nIn *explicit* mode, `einsum` provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.\n\nSee the notes and examples for clarification.\n\nParameters ---------- subscripts : str Specifies the subscripts for summation as comma separated list of subscript labels. An implicit (classical Einstein summation) calculation is performed unless the explicit indicator '->' is included as well as subscript labels of the precise output form. operands : list of array_like These are the arrays for the operation. out : ndarray, optional If provided, the calculation is done into this array. dtype : {data-type, None}, optional If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal `casting` parameter to allow the conversions. Default is None. order : {'C', 'F', 'A', 'K'}, optional Controls the memory layout of the output. 'C' means it should be C contiguous. 'F' means it should be Fortran contiguous, 'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise. 'K' means it should be as close to the layout as the inputs as is possible, including arbitrarily permuted axes. Default is 'K'. casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional Controls what kind of data casting may occur.\n\nSetting this to 'unsafe' is not recommended, as it can adversely affect accumulations.\n\n* 'no' means the data types should not be cast at all. * 'equiv' means only byte-order changes are allowed. * 'safe' means only casts which can preserve values are allowed. * 'same_kind' means only safe casts or casts within a kind, like float64 to float32, are allowed. * 'unsafe' means any data conversions may be done.\n\nDefault is 'safe'. optimize : {False, True, 'greedy', 'optimal'}, optional Controls if intermediate optimization should occur. No optimization will occur if False and True will default to the 'greedy' algorithm. Also accepts an explicit contraction list from the ``np.einsum_path`` function. See ``np.einsum_path`` for more details. Defaults to False.\n##### Returns\n* **output **: ndarray\n    The calculation based on the Einstein summation convention.\n\n* **.. versionadded**: \n\n* **which can be computed by `einsum`, is shown below along with examples**: \n\n* *** Trace of an array, **: py\n\n* *** Return a diagonal, **: py\n\n* *** Array axis summations, **: py\n\n* *** Transpositions and permutations, **: py\n\n* *** Matrix multiplication and dot product, **: py\n\n* *** Vector inner and outer products, **: py\n\n* *** Broadcasting, element-wise and scalar multiplication, **: py\n\n* *** Tensor contractions, **: py\n\n* *** Chained array operations, in efficient calculation order, **: py\n\n* **is equivalent to **: py\n\n* ****: py\n\n* **to **: py\n\n* **``np.einsum('i->', a)`` is like **: py\n\n* **and ``np.einsum('ii->i', a)`` is like **: py\n\n* **have the same effect as **: py\n\n* **See **: py\n\n* **Trace of a matrix**: \n\n* **Extract the diagonal (requires explicit form)**: \n\n* **Sum over an axis (requires explicit form)**: \n\n* **For higher dimensional arrays summing a single axis can be done with ellipsis**: \n\n* **Compute a matrix transpose, or reorder any number of axes**: \n\n* **Vector inner products**: \n\n* **Matrix vector multiplication**: \n\n* **Broadcasting and scalar multiplication**: \n\n* **Vector outer product**: \n\n* **Tensor contraction**: \n\n* **Writeable returned arrays (since version 1.10.0)**: \n\n* **>>> np.einsum('ii->i', a)[**: ] = 1\n\n* **Example of ellipsis use**: \n\n* **particularly significant with larger arrays**: \n\n* **Basic `einsum`**: ~1520ms  (benchmarked on 3.1GHz Intel i5.)\n\n* **>>> for iteration in range(500)**: \n\n* **Sub-optimal `einsum` (due to repeated path calculation time)**: ~330ms\n\n* **Greedy `einsum` (faster optimal path approximation)**: ~160ms\n\n* **Optimal `einsum` (best usage pattern in some use cases)**: ~110ms\n\n"
}